{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This guide is designed to introduce you to PowerShell, a powerful command-line interface and scripting language built by Microsoft. Whether you are new to PowerShell or are looking to expand your skills, this guide will provide you with the necessary information to get started. Windows Powershell PowerShell is an automation solution that consists of a command-line shell, a scripting language, and a configuration-management framework. Installation PowerShell is pre-installed on Windows 10 and Windows Server 2016 and later, but you may need to update it to the latest version. To install PowerShell on older versions of Windows, visit the PowerShell GitHub repository and follow the installation instructions. Getting Started with PowerShell Before we dive into the commands, let's first open PowerShell. There are a few ways to do this: Click on the Start menu, search for PowerShell , and click on the Windows PowerShell option. Press the Windows key + R to open the Run dialog box, type in powershell , and press Enter . If you are using Windows 10, you can also right-click on the Start menu and select Windows PowerShell or Windows PowerShell (Admin) . Once you have PowerShell open, you can start entering commands. Command-line Shell Windows PowerShell superseded the Windows command-line interface (cmd.exe) and the limited functionality of its batch file scripting language. PowerShell accepts and returns .NET objects and includes: A command-line history. Tab completion and prediction. Support for command and parameter aliases . Chaining commands that use the Pipeline feature . A robust in-console help system Initially, Windows PowerShell was a platform built on the .NET Framework and only worked on Windows operating systems. However, with its recent releases, PowerShell uses the .NET Core and can run on Windows, macOS, and Linux platforms. Due to their multi-platform support, these recent releases are referred to as PowerShell (rather than Windows PowerShell). PowerShell Basics PowerShell commands are called cmdlets, and they follow a simple verb-noun syntax. For example, the command to get a list of files in a directory is Get-ChildItem. Here are some basic PowerShell commands to get you started: Get-Help : Get help for a cmdlet Get-Member : Essential tool for exploring objects and their properties, methods, and events Get-Process : Get information about running processes Get-Service : Get information about running services Get-ChildItem : Get a list of files and folders in a directory Set-Location : Change the current working directory Clear-Host : Clear the PowerShell console screen Exit : Exit PowerShell Commands provide PowerShell\u2019s main functionality. There are many varieties of commands, including cmdlets (pronounced command-lets), functions, filters, scripts, applications, configurations, and workflows. Commands are building blocks that you piece together by using the Windows PowerShell scripting language. Using commands enables you to create custom solutions to complex administrative problems. Alternatively, you can run commands directly within the PowerShell console to complete a single task. The console is the CLI for PowerShell and is the primary way in which you'll interact with PowerShell. Cmdlets use a Verb-Noun naming convention. For example, you can use the Get-Command cmdlet to list all cmdlets and functions that are registered in the command shell. The verb identifies the action for the cmdlet to perform, and the noun identifies the resource on which the cmdlet will perform its action. Working with Files and Folders PowerShell is particularly useful for working with files and folders. Here are some useful commands: New-Item : Create a new file or folder Remove-Item : Delete a file or folder Copy-Item : Copy a file or folder Move-Item : Move a file or folder Rename-Item : Rename a file or folder Get-Content : Get the contents of a file Set-Content : Set the contents of a file A Scripting Language PowerShell scripts are saved as .ps1 files and can be run from the command line or by double-clicking on the file. Here are some tips for writing PowerShell scripts: Use comments to explain your code Use variables to store data Use loops and conditional statements to control the flow of your script Use functions to reuse code Advanced PowerShell PowerShell is a very powerful tool, and there are many advanced features that you can use to make your scripts even more powerful. Here are some advanced topics to explore: Remoting: Run PowerShell commands on remote computers Modules: Extend PowerShell with additional functionality Desired State Configuration: Automate the configuration of your environment Error Handling: Handle errors in your scripts Configuration management framework PowerShell incorporates the PowerShell Desired State Configuration (DSC) management framework. This framework enables you to manage enterprise infrastructure with code to help with: Using declarative configurations and repeatable scripts for repeatable deployments. Enforcing configurations settings and identifying when configuration drift takes place from standard requirements. Deploying configuration settings using push or pull models. Applications and services with PowerShell\u2013based administrative functions are consistent in how they work. This attribute means that you can quickly apply the lessons you learned. Also, when you use automation scripts to administer a software application, you can reuse them among other applications. Conclusion PowerShell is a powerful tool that can help you automate repetitive tasks and manage your environment. By learning the basics of PowerShell, you can greatly improve your productivity and efficiency as an IT professional. With PowerShell, you can: Automate administrative tasks and eliminate manual work Manage and configure Windows operating systems and applications Integrate with other technologies and tools, such as Azure and Visual Studio Code Analyze and transform data using PowerShell commands and scripts In addition, PowerShell has a strong and supportive community of users and developers who are constantly creating new scripts, modules, and tools to extend its functionality. Whether you are a sysadmin, a developer, or just someone who wants to learn a powerful scripting language, PowerShell is a valuable tool to add to your skillset. With its robust features and wide range of applications, PowerShell can help you become more efficient and effective in your work. So why not give it a try and see what you can accomplish with PowerShell!","title":"Home"},{"location":"#windows-powershell","text":"PowerShell is an automation solution that consists of a command-line shell, a scripting language, and a configuration-management framework.","title":"Windows Powershell"},{"location":"#installation","text":"PowerShell is pre-installed on Windows 10 and Windows Server 2016 and later, but you may need to update it to the latest version. To install PowerShell on older versions of Windows, visit the PowerShell GitHub repository and follow the installation instructions.","title":"Installation"},{"location":"#getting-started-with-powershell","text":"Before we dive into the commands, let's first open PowerShell. There are a few ways to do this: Click on the Start menu, search for PowerShell , and click on the Windows PowerShell option. Press the Windows key + R to open the Run dialog box, type in powershell , and press Enter . If you are using Windows 10, you can also right-click on the Start menu and select Windows PowerShell or Windows PowerShell (Admin) . Once you have PowerShell open, you can start entering commands.","title":"Getting Started with PowerShell"},{"location":"#command-line-shell","text":"Windows PowerShell superseded the Windows command-line interface (cmd.exe) and the limited functionality of its batch file scripting language. PowerShell accepts and returns .NET objects and includes: A command-line history. Tab completion and prediction. Support for command and parameter aliases . Chaining commands that use the Pipeline feature . A robust in-console help system Initially, Windows PowerShell was a platform built on the .NET Framework and only worked on Windows operating systems. However, with its recent releases, PowerShell uses the .NET Core and can run on Windows, macOS, and Linux platforms. Due to their multi-platform support, these recent releases are referred to as PowerShell (rather than Windows PowerShell).","title":"Command-line Shell"},{"location":"#powershell-basics","text":"PowerShell commands are called cmdlets, and they follow a simple verb-noun syntax. For example, the command to get a list of files in a directory is Get-ChildItem. Here are some basic PowerShell commands to get you started: Get-Help : Get help for a cmdlet Get-Member : Essential tool for exploring objects and their properties, methods, and events Get-Process : Get information about running processes Get-Service : Get information about running services Get-ChildItem : Get a list of files and folders in a directory Set-Location : Change the current working directory Clear-Host : Clear the PowerShell console screen Exit : Exit PowerShell Commands provide PowerShell\u2019s main functionality. There are many varieties of commands, including cmdlets (pronounced command-lets), functions, filters, scripts, applications, configurations, and workflows. Commands are building blocks that you piece together by using the Windows PowerShell scripting language. Using commands enables you to create custom solutions to complex administrative problems. Alternatively, you can run commands directly within the PowerShell console to complete a single task. The console is the CLI for PowerShell and is the primary way in which you'll interact with PowerShell. Cmdlets use a Verb-Noun naming convention. For example, you can use the Get-Command cmdlet to list all cmdlets and functions that are registered in the command shell. The verb identifies the action for the cmdlet to perform, and the noun identifies the resource on which the cmdlet will perform its action.","title":"PowerShell Basics"},{"location":"#working-with-files-and-folders","text":"PowerShell is particularly useful for working with files and folders. Here are some useful commands: New-Item : Create a new file or folder Remove-Item : Delete a file or folder Copy-Item : Copy a file or folder Move-Item : Move a file or folder Rename-Item : Rename a file or folder Get-Content : Get the contents of a file Set-Content : Set the contents of a file","title":"Working with Files and Folders"},{"location":"#a-scripting-language","text":"PowerShell scripts are saved as .ps1 files and can be run from the command line or by double-clicking on the file. Here are some tips for writing PowerShell scripts: Use comments to explain your code Use variables to store data Use loops and conditional statements to control the flow of your script Use functions to reuse code","title":"A Scripting Language"},{"location":"#advanced-powershell","text":"PowerShell is a very powerful tool, and there are many advanced features that you can use to make your scripts even more powerful. Here are some advanced topics to explore: Remoting: Run PowerShell commands on remote computers Modules: Extend PowerShell with additional functionality Desired State Configuration: Automate the configuration of your environment Error Handling: Handle errors in your scripts","title":"Advanced PowerShell"},{"location":"#configuration-management-framework","text":"PowerShell incorporates the PowerShell Desired State Configuration (DSC) management framework. This framework enables you to manage enterprise infrastructure with code to help with: Using declarative configurations and repeatable scripts for repeatable deployments. Enforcing configurations settings and identifying when configuration drift takes place from standard requirements. Deploying configuration settings using push or pull models. Applications and services with PowerShell\u2013based administrative functions are consistent in how they work. This attribute means that you can quickly apply the lessons you learned. Also, when you use automation scripts to administer a software application, you can reuse them among other applications.","title":"Configuration management framework"},{"location":"#conclusion","text":"PowerShell is a powerful tool that can help you automate repetitive tasks and manage your environment. By learning the basics of PowerShell, you can greatly improve your productivity and efficiency as an IT professional. With PowerShell, you can: Automate administrative tasks and eliminate manual work Manage and configure Windows operating systems and applications Integrate with other technologies and tools, such as Azure and Visual Studio Code Analyze and transform data using PowerShell commands and scripts In addition, PowerShell has a strong and supportive community of users and developers who are constantly creating new scripts, modules, and tools to extend its functionality. Whether you are a sysadmin, a developer, or just someone who wants to learn a powerful scripting language, PowerShell is a valuable tool to add to your skillset. With its robust features and wide range of applications, PowerShell can help you become more efficient and effective in your work. So why not give it a try and see what you can accomplish with PowerShell!","title":"Conclusion"},{"location":"GetStart/","text":"Getting started with PowerShell is easy, and here are the steps to help you: Find and run PowerShell PowerShell is pre-installed on most modern Windows operating systems. To find it, click on the \"Start\" menu, type \"PowerShell\" in the search box, and select the \"Windows PowerShell\" or \"PowerShell 7\" option depending on which version you want to use. Alternatively, you can press the \"Windows Key + X\" key combination and select \"Windows PowerShell\" from the Power User menu. Check the PowerShell version To check which version of PowerShell you have installed, open a PowerShell session and run the following command: $PSVersionTable This will display the PowerShell version number and other version-related information, such as the CLR version, the .NET Framework version, and the OS version. Update PowerShell If you have an older version of PowerShell, you can update it to the latest version. Winget, the Windows Package Manager, is a command-line tool enables users to discover, install, upgrade, remove, and configure applications on Windows client computers. This tool is the client interface to the Windows Package Manager service. The following commands can be used to install PowerShell using the published winget packages: Search for the latest version of PowerShell winget search Microsoft . PowerShell Then, install PowerShell or PowerShell Preview using the id parameter winget install - -id Microsoft . Powershell - -source winget winget install - -id Microsoft . Powershell . Preview - -source winget Use PowerShell help PowerShell includes a comprehensive help system that you can use to learn about PowerShell cmdlets, functions, and modules. To use the help system, open a PowerShell session and run the following command: Get-Help < cmdlet or topic > Replace with the name of the cmdlet or topic you want to learn about. For example, to learn about the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem This will display the help information for the Get-ChildItem cmdlet, including a description, syntax, parameters, examples, and related topics. By following these steps, you can get started with PowerShell, check for its version, update it to the latest version, and use the built-in help system to learn more about PowerShell and its various features. More on the use of Get-Help The Get-Help cmdlet is a powerful feature of PowerShell that provides help information for cmdlets, functions, modules, and other PowerShell components. Here are some examples of how to use the Get-Help cmdlet: Get help for a specific cmdlet: To get help for a specific cmdlet, run the following command: Get-Help < cmdlet name > Replace with the name of the cmdlet you want to learn about. For example, to get help for the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem This will display the help information for the Get-ChildItem cmdlet, including a description, syntax, parameters, examples, and related topics. Get help for a specific parameter: To get help for a specific parameter of a cmdlet, run the following command: Get-Help < cmdlet name > -Parameter < parameter name > Replace with the name of the cmdlet and with the name of the parameter you want to learn about. For example, to get help for the Path parameter of the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem -Parameter Path This will display the help information for the Path parameter of the Get-ChildItem cmdlet. Get help for a specific topic: To get help for a specific topic, such as operators or variables, run the following command: Get-Help < topic > Replace with the name of the topic you want to learn about. For example, to get help for operators, you would run the following command: Get-Help about_operators This will display the help information for operators in PowerShell. Use wildcard with Get-Help: You can use wildcard characters to search for cmdlets or topics that match a certain pattern. For example, to search for all cmdlets that start with \"Get\", you would run the following command: Get-Help Get -* This will display help information for all cmdlets that start with \"Get\", including Get-ChildItem, Get-Item, Get-Process, and others. In summary, the Get-Help cmdlet is a valuable tool for learning about PowerShell and its various components. By using Get-Help with different parameters and wildcard characters, you can quickly find the information you need and improve your PowerShell skills.","title":"Getting Started"},{"location":"GetStart/#find-and-run-powershell","text":"PowerShell is pre-installed on most modern Windows operating systems. To find it, click on the \"Start\" menu, type \"PowerShell\" in the search box, and select the \"Windows PowerShell\" or \"PowerShell 7\" option depending on which version you want to use. Alternatively, you can press the \"Windows Key + X\" key combination and select \"Windows PowerShell\" from the Power User menu.","title":"Find and run PowerShell"},{"location":"GetStart/#check-the-powershell-version","text":"To check which version of PowerShell you have installed, open a PowerShell session and run the following command: $PSVersionTable This will display the PowerShell version number and other version-related information, such as the CLR version, the .NET Framework version, and the OS version.","title":"Check the PowerShell version"},{"location":"GetStart/#update-powershell","text":"If you have an older version of PowerShell, you can update it to the latest version. Winget, the Windows Package Manager, is a command-line tool enables users to discover, install, upgrade, remove, and configure applications on Windows client computers. This tool is the client interface to the Windows Package Manager service. The following commands can be used to install PowerShell using the published winget packages: Search for the latest version of PowerShell winget search Microsoft . PowerShell Then, install PowerShell or PowerShell Preview using the id parameter winget install - -id Microsoft . Powershell - -source winget winget install - -id Microsoft . Powershell . Preview - -source winget","title":"Update PowerShell"},{"location":"GetStart/#use-powershell-help","text":"PowerShell includes a comprehensive help system that you can use to learn about PowerShell cmdlets, functions, and modules. To use the help system, open a PowerShell session and run the following command: Get-Help < cmdlet or topic > Replace with the name of the cmdlet or topic you want to learn about. For example, to learn about the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem This will display the help information for the Get-ChildItem cmdlet, including a description, syntax, parameters, examples, and related topics. By following these steps, you can get started with PowerShell, check for its version, update it to the latest version, and use the built-in help system to learn more about PowerShell and its various features.","title":"Use PowerShell help"},{"location":"GetStart/#more-on-the-use-of-get-help","text":"The Get-Help cmdlet is a powerful feature of PowerShell that provides help information for cmdlets, functions, modules, and other PowerShell components. Here are some examples of how to use the Get-Help cmdlet: Get help for a specific cmdlet: To get help for a specific cmdlet, run the following command: Get-Help < cmdlet name > Replace with the name of the cmdlet you want to learn about. For example, to get help for the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem This will display the help information for the Get-ChildItem cmdlet, including a description, syntax, parameters, examples, and related topics. Get help for a specific parameter: To get help for a specific parameter of a cmdlet, run the following command: Get-Help < cmdlet name > -Parameter < parameter name > Replace with the name of the cmdlet and with the name of the parameter you want to learn about. For example, to get help for the Path parameter of the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem -Parameter Path This will display the help information for the Path parameter of the Get-ChildItem cmdlet. Get help for a specific topic: To get help for a specific topic, such as operators or variables, run the following command: Get-Help < topic > Replace with the name of the topic you want to learn about. For example, to get help for operators, you would run the following command: Get-Help about_operators This will display the help information for operators in PowerShell. Use wildcard with Get-Help: You can use wildcard characters to search for cmdlets or topics that match a certain pattern. For example, to search for all cmdlets that start with \"Get\", you would run the following command: Get-Help Get -* This will display help information for all cmdlets that start with \"Get\", including Get-ChildItem, Get-Item, Get-Process, and others. In summary, the Get-Help cmdlet is a valuable tool for learning about PowerShell and its various components. By using Get-Help with different parameters and wildcard characters, you can quickly find the information you need and improve your PowerShell skills.","title":"More on the use of Get-Help"},{"location":"comparison/","text":"The Compare-Object cmdlet (which has the alias diff) allows you to compare two objects and display the differences between them. In this sense, it allows you to compare a snapshot of processes (or services, or anything else) from a system with a more current snapshot. For example, you can generate a snapshot of the system's processes: get-process | export-clixml processes . xml ... and later, compare it with the processes that are running at that time: diff -Ref ( Import-Clixml .\\ processes . xml ) -Diff ( get-process ) -Property name The previous command is interpreted as follows: Parentheses are interpreted the same as in algebra: the commands that are inside parentheses are executed first, and their results are passed to the outermost command. The -Ref parameter (-ReferenceObject in full) indicates the object that will be used as the basis for the comparison (in this case, the snapshot that was previously saved). The -Diff parameter (-DifferenceObject in full) indicates the object that will be compared against the base (in this case, the current list of processes). The -Property parameter indicates the property that is being compared, in this case, the names of the processes. The output of the command is similar to this: name SideIndicator ---- ------------- WindowsInternal.ComposableShell.Experiences.TextInput.InputApp => YourPhone => LockApp <= Microsoft.Photos <= notepad <= The names of the processes appear, with an arrow pointing to the left or right: \u2022 If the arrow points to the right, it indicates a name that is in the new snapshot but not in the original. \u2022 If the arrow points to the left, it indicates a name that is in the original snapshot but not in the new one.","title":"Object Comparison"},{"location":"config_profile/","text":"Configuring your PowerShell profile is an essential step to personalize your PowerShell environment and make your work more efficient. Your profile is a PowerShell script file that executes every time you start a PowerShell session. You can use it to customize your environment by adding aliases, functions, variables, and modules. Here's an example of how to configure your profile in PowerShell: Open PowerShell and run the following command to create a new profile file if it doesn't exist: if ( ! ( Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } Open your profile file with your preferred text editor or IDE. You can find the location of your profile file by running the following command: notepad $PROFILE This will open your profile file in Notepad. Add any customizations you want to your profile file. For example, you can add an alias to simplify a frequently used command. To create an alias for the Get-ChildItem cmdlet, add the following line to your profile: Set-Alias -Name ls -Value Get-ChildItem This creates an alias named ls that runs the Get-ChildItem cmdlet. Save and close your profile file. Restart PowerShell to apply your changes. Your customizations should now be available in your PowerShell session. In addition to aliases, you can also use your profile to configure your PowerShell prompt, set default parameters for cmdlets, load modules automatically, and define functions that you frequently use. By taking advantage of the customization options available in your profile, you can make your PowerShell experience more efficient and tailored to your needs. Here is an example of a common $profile script for PowerShell: # Add custom PowerShell functions function Get-Weather { param ([ string ] $location = \"New York\" ) Invoke-RestMethod -Uri \"https://wttr.in/ $location ?format=%C+%t\" -UseBasicParsing } # Load useful PowerShell modules Import-Module Pester Import-Module PSReadline Import-Module Microsoft.PowerShell.Management # Set default parameters for cmdlets $PSDefaultParameterValues = @ { \"Get-ChildItem:Recurse\" = $true \"Out-File:Encoding\" = \"utf8\" } # Add custom aliases Set-Alias -Name l -Value Get-ChildItem Set-Alias -Name gac -Value Get-ChildItem -ParameterName FullName -ArgumentList \"C:\\Windows\\Microsoft.NET\\assembly\\GAC*\" # Configure PowerShell prompt $host .UI.RawUI.WindowTitle = \" $env :USERNAME@ $env :COMPUTERNAME\" $host .UI.RawUI.ForegroundColor = \"Green\" $host .UI.RawUI.BackgroundColor = \"Black\" $host .UI.RawUI.WindowSize = New-Object System.Management.Automation.Host.Size ( 120 ,50 ) This $profile script defines several customizations for the PowerShell environment, including: A custom function named Get-Weather that uses the Invoke-RestMethod cmdlet to retrieve weather information for a specified location. The loading of several useful PowerShell modules, including Pester, PSReadline, and Microsoft.PowerShell.Management. Default parameter values for the Get-ChildItem and Out-File cmdlets. Custom aliases for the Get-ChildItem cmdlet and a common path for the Get-ChildItem cmdlet. Configuration of the PowerShell prompt, including the window title, foreground and background colors, and window size. By using a $profile script like this one, you can customize your PowerShell environment to suit your needs and make your work more efficient.","title":"Config Profile"},{"location":"files_folders/","text":"PowerShell provides a variety of cmdlets for working with files and folders. In PowerShell, an \"item\" is a generic term used to refer to a file, folder, registry key, or other object that can be manipulated by cmdlets in the PowerShell environment. The term \"item\" is used in cmdlet names such as Get-Item, Set-Item, and Remove-Item, which can be used to manipulate different types of items in PowerShell. Items Here are some examples of how to use these cmdlets: Cmdlet Description Alias Get-ChildItem Gets the items and child items in one or more specified locations gci, dir, ls Set-Location Sets the working location to a specified location cd, sl, chdir Copy-Item Copies an item from one location to another location cp, copy Move-Item Moves an item from one location to another location mv, move Remove-Item Deletes the specified items ri, rmdir, rd, del, erase New-Item Creates a new item at the specified location ni Rename-Item Renames an item at the specified location rni Note that some of these cmdlets have additional parameters that can be used to control their behavior. For example, you can use the -Recurse parameter with Remove-Item to delete a directory and all its contents. You can also use wildcards with many of these cmdlets to perform operations on multiple files or directories at once. Get-ChildItem This cmdlet lists the contents of a directory. By default, it displays both files and directories. Example: Get-ChildItem C :\\ Users Set-Location This cmdlet changes the current working directory. Example: Set-Location C :\\ Users \\ UserName \\ Desktop Copy-Item This cmdlet copies a file or directory to a new location. Example: Copy-Item C :\\ Users \\ UserName \\ Desktop \\ MyFile . txt C :\\ Temp \\ Move-Item This cmdlet moves a file or directory to a new location. Example: Move-Item C :\\ Users \\ UserName \\ Desktop \\ MyFile . txt C :\\ Temp \\ Rename-Item This cmdlet renames a file or directory. Example: Rename-Item C :\\ Temp \\ MyFile . txt MyNewFile . txt New-Item This cmdlet creates a new file or directory. Example: New-Item -ItemType File -Path C :\\ Temp \\ NewFile . txt Remove-Item This cmdlet deletes a file or directory. Example: Remove-Item C :\\ Temp \\ MyFile . txt Properties In PowerShell, cmdlets whose names end with \"Property\" are used to retrieve or manipulate the properties of objects. Properties are attributes or characteristics of an object, such as its name, size, or creation date. The most common cmdlet that ends with \"Property\" is the Get-ItemProperty cmdlet, which is used to retrieve the properties of a file, folder, or registry key. For example, you can use the Get-ItemProperty cmdlet to retrieve the version number of a file or the registry key value for a particular setting. Other examples of cmdlets that end with \"Property\" include the Get-ServiceProperty cmdlet, which is used to retrieve the properties of a Windows service, and the Get-ADUserProperty cmdlet, which is used to retrieve the properties of an Active Directory user. In general, cmdlets that end with \"Property\" are useful for retrieving specific information about an object, which can be used in scripts or further manipulated using other PowerShell cmdlets. Cmdlet Description New-ItemProperty Creates a new property for an item at the specified location Get-ItemProperty Gets the properties of the specified items Set-ItemProperty Sets the value of a property for the specified item Remove-ItemProperty Removes a property from an item at the specified location Some interesting properties are: CreationTime, FullName, LastAccessTime, LastWriteTime, Attributes. For example, to check the creation time of a file: get-itemproperty -path filename -name CreationTime To check the attributes (permissions) of the file: get-itemproperty -path file -name Attributes To set the attributes, the Set-Itemproperty command is used, for example: set-itemproperty -path file -name Attributes -value \"ReadOnly\" Some permission values are ReadOnly, Hidden, System. If you want to set multiple permissions at once, separate their names with commas, and enclose the entire set in quotation marks (as in the example). Paths In PowerShell, cmdlets whose names end with \"Path\" are used to work with file and directory paths. These cmdlets are commonly used to manipulate or retrieve information about file and directory paths, such as their locations, names, or extensions. One of the most commonly used cmdlets that ends with \"Path\" is the Split-Path cmdlet, which is used to split a file or directory path into its individual components, such as the directory, filename, and extension. For example, the command \"Split-Path C:\\Temp\\test.txt -Leaf\" would return \"test.txt\", while \"Split-Path C:\\Temp\\test.txt -Parent\" would return \"C:\\Temp\". Another example is the Join-Path cmdlet, which is used to combine two or more path strings into a single path. For example, the command \"Join-Path C:\\Temp test.txt\" would return \"C:\\Temp\\test.txt\". Other examples of cmdlets that end with \"Path\" include the Resolve-Path cmdlet, which is used to resolve a path to its full, absolute form, and the Test-Path cmdlet, which is used to test whether a file or directory path exists. In general, cmdlets that end with \"Path\" are useful for manipulating file and directory paths, which can be useful for scripting or automating tasks that involve working with files and directories. Cmdlet Description Test-Path Determines whether all elements of a path exist Join-Path Joins two or more parts of a path into a single path Split-Path Returns specific parts of a path Convert-Path Converts a path from a relative path to a full path or from a full path to a relative path Directories or Folders Operation Command Creation new-item -itemtype directory -name directory_name Deletion remove-item -path directory_name -Recurse Rename rename-item -path directory_name -newname new_directory_name -Recurse Move move-item -path directory_name -destination new_location Enter cd directory_name Show current directory Get-Location or pwd (same as Linux) Note .(dot) indicates the current directory and ..(dot dot) indicates the parent of the current directory. Files Operation Command Creation new-item -itemtype file -name file_name [-value content] Deletion remove-item -path file_name Renaming rename-item -path file_name -newname new_name Moving move-item -path file_name -destination new_location Text files can be displayed on the console using the Get-Content command, which has the alias \"type\".","title":"Files & Folders"},{"location":"files_folders/#items","text":"Here are some examples of how to use these cmdlets: Cmdlet Description Alias Get-ChildItem Gets the items and child items in one or more specified locations gci, dir, ls Set-Location Sets the working location to a specified location cd, sl, chdir Copy-Item Copies an item from one location to another location cp, copy Move-Item Moves an item from one location to another location mv, move Remove-Item Deletes the specified items ri, rmdir, rd, del, erase New-Item Creates a new item at the specified location ni Rename-Item Renames an item at the specified location rni Note that some of these cmdlets have additional parameters that can be used to control their behavior. For example, you can use the -Recurse parameter with Remove-Item to delete a directory and all its contents. You can also use wildcards with many of these cmdlets to perform operations on multiple files or directories at once.","title":"Items"},{"location":"files_folders/#get-childitem","text":"This cmdlet lists the contents of a directory. By default, it displays both files and directories. Example: Get-ChildItem C :\\ Users","title":"Get-ChildItem"},{"location":"files_folders/#set-location","text":"This cmdlet changes the current working directory. Example: Set-Location C :\\ Users \\ UserName \\ Desktop","title":"Set-Location"},{"location":"files_folders/#copy-item","text":"This cmdlet copies a file or directory to a new location. Example: Copy-Item C :\\ Users \\ UserName \\ Desktop \\ MyFile . txt C :\\ Temp \\","title":"Copy-Item"},{"location":"files_folders/#move-item","text":"This cmdlet moves a file or directory to a new location. Example: Move-Item C :\\ Users \\ UserName \\ Desktop \\ MyFile . txt C :\\ Temp \\","title":"Move-Item"},{"location":"files_folders/#rename-item","text":"This cmdlet renames a file or directory. Example: Rename-Item C :\\ Temp \\ MyFile . txt MyNewFile . txt","title":"Rename-Item"},{"location":"files_folders/#new-item","text":"This cmdlet creates a new file or directory. Example: New-Item -ItemType File -Path C :\\ Temp \\ NewFile . txt","title":"New-Item"},{"location":"files_folders/#remove-item","text":"This cmdlet deletes a file or directory. Example: Remove-Item C :\\ Temp \\ MyFile . txt","title":"Remove-Item"},{"location":"files_folders/#properties","text":"In PowerShell, cmdlets whose names end with \"Property\" are used to retrieve or manipulate the properties of objects. Properties are attributes or characteristics of an object, such as its name, size, or creation date. The most common cmdlet that ends with \"Property\" is the Get-ItemProperty cmdlet, which is used to retrieve the properties of a file, folder, or registry key. For example, you can use the Get-ItemProperty cmdlet to retrieve the version number of a file or the registry key value for a particular setting. Other examples of cmdlets that end with \"Property\" include the Get-ServiceProperty cmdlet, which is used to retrieve the properties of a Windows service, and the Get-ADUserProperty cmdlet, which is used to retrieve the properties of an Active Directory user. In general, cmdlets that end with \"Property\" are useful for retrieving specific information about an object, which can be used in scripts or further manipulated using other PowerShell cmdlets. Cmdlet Description New-ItemProperty Creates a new property for an item at the specified location Get-ItemProperty Gets the properties of the specified items Set-ItemProperty Sets the value of a property for the specified item Remove-ItemProperty Removes a property from an item at the specified location Some interesting properties are: CreationTime, FullName, LastAccessTime, LastWriteTime, Attributes. For example, to check the creation time of a file: get-itemproperty -path filename -name CreationTime To check the attributes (permissions) of the file: get-itemproperty -path file -name Attributes To set the attributes, the Set-Itemproperty command is used, for example: set-itemproperty -path file -name Attributes -value \"ReadOnly\" Some permission values are ReadOnly, Hidden, System. If you want to set multiple permissions at once, separate their names with commas, and enclose the entire set in quotation marks (as in the example).","title":"Properties"},{"location":"files_folders/#paths","text":"In PowerShell, cmdlets whose names end with \"Path\" are used to work with file and directory paths. These cmdlets are commonly used to manipulate or retrieve information about file and directory paths, such as their locations, names, or extensions. One of the most commonly used cmdlets that ends with \"Path\" is the Split-Path cmdlet, which is used to split a file or directory path into its individual components, such as the directory, filename, and extension. For example, the command \"Split-Path C:\\Temp\\test.txt -Leaf\" would return \"test.txt\", while \"Split-Path C:\\Temp\\test.txt -Parent\" would return \"C:\\Temp\". Another example is the Join-Path cmdlet, which is used to combine two or more path strings into a single path. For example, the command \"Join-Path C:\\Temp test.txt\" would return \"C:\\Temp\\test.txt\". Other examples of cmdlets that end with \"Path\" include the Resolve-Path cmdlet, which is used to resolve a path to its full, absolute form, and the Test-Path cmdlet, which is used to test whether a file or directory path exists. In general, cmdlets that end with \"Path\" are useful for manipulating file and directory paths, which can be useful for scripting or automating tasks that involve working with files and directories. Cmdlet Description Test-Path Determines whether all elements of a path exist Join-Path Joins two or more parts of a path into a single path Split-Path Returns specific parts of a path Convert-Path Converts a path from a relative path to a full path or from a full path to a relative path","title":"Paths"},{"location":"files_folders/#directories-or-folders","text":"Operation Command Creation new-item -itemtype directory -name directory_name Deletion remove-item -path directory_name -Recurse Rename rename-item -path directory_name -newname new_directory_name -Recurse Move move-item -path directory_name -destination new_location Enter cd directory_name Show current directory Get-Location or pwd (same as Linux) Note .(dot) indicates the current directory and ..(dot dot) indicates the parent of the current directory.","title":"Directories or Folders"},{"location":"files_folders/#files","text":"Operation Command Creation new-item -itemtype file -name file_name [-value content] Deletion remove-item -path file_name Renaming rename-item -path file_name -newname new_name Moving move-item -path file_name -destination new_location Text files can be displayed on the console using the Get-Content command, which has the alias \"type\".","title":"Files"},{"location":"get_member/","text":"The Get-Member cmdlet in PowerShell is an essential tool for exploring objects and their properties, methods, and events. It retrieves the members (properties, methods, and events) of an object and displays their definitions and syntax, which can help users understand the object and how to interact with it. Syntax The syntax for using Get-Member is as follows: Get-Member [ -InputObject ] < PSObject > [ -MemberType { Property | Method | Event | NoteProperty | AliasProperty | ScriptProperty | PropertySet | All }] [ -Force ] [ -Static ] Here's an explanation of the parameters: InputObject: specifies the object for which to retrieve the members. It can be piped to Get-Member or specified as an argument. MemberType: specifies the type of members to retrieve. It can be one of the following: Property (instance properties), Method (instance methods), Event (instance events), NoteProperty (extended properties), AliasProperty (aliases), ScriptProperty (script properties), PropertySet (property sets), or All (all members). Force: forces Get-Member to retrieve hidden or non-public members. Static: retrieves static members of a class. Examples View the properties of an object: Get-Process | Get-Member -MemberType Property This command retrieves the list of properties associated with the Get-Process cmdlet. View the methods of an object: Get-ChildItem | Get-Member -MemberType Method This command retrieves the list of methods associated with the Get-ChildItem cmdlet. Filter the results by name or type: Get-Process | Get-Member -Name \"<Name>\" This command retrieves only the properties with the name \" \" from the Get-Process cmdlet. View the static properties of a .NET class: [System.Math] | Get-Member -Static -MemberType Property This command retrieves the static properties of the .NET class System.Math.","title":"GetMember"},{"location":"get_member/#syntax","text":"The syntax for using Get-Member is as follows: Get-Member [ -InputObject ] < PSObject > [ -MemberType { Property | Method | Event | NoteProperty | AliasProperty | ScriptProperty | PropertySet | All }] [ -Force ] [ -Static ] Here's an explanation of the parameters: InputObject: specifies the object for which to retrieve the members. It can be piped to Get-Member or specified as an argument. MemberType: specifies the type of members to retrieve. It can be one of the following: Property (instance properties), Method (instance methods), Event (instance events), NoteProperty (extended properties), AliasProperty (aliases), ScriptProperty (script properties), PropertySet (property sets), or All (all members). Force: forces Get-Member to retrieve hidden or non-public members. Static: retrieves static members of a class.","title":"Syntax"},{"location":"get_member/#examples","text":"View the properties of an object: Get-Process | Get-Member -MemberType Property This command retrieves the list of properties associated with the Get-Process cmdlet. View the methods of an object: Get-ChildItem | Get-Member -MemberType Method This command retrieves the list of methods associated with the Get-ChildItem cmdlet. Filter the results by name or type: Get-Process | Get-Member -Name \"<Name>\" This command retrieves only the properties with the name \" \" from the Get-Process cmdlet. View the static properties of a .NET class: [System.Math] | Get-Member -Static -MemberType Property This command retrieves the static properties of the .NET class System.Math.","title":"Examples"},{"location":"getalias/","text":"In PowerShell, an alias is an alternate name or shortcut that you can use to refer to a cmdlet, function, executable, or script. Aliases can be used to save time and typing effort, and they can also be customized to match your preferences and habits. For example, instead of typing Get-ChildItem every time you want to list the contents of a directory, you can use the alias ls instead. Similarly, instead of typing Set-Location to change the current directory, you can use the alias cd instead. PowerShell comes with a set of built-in aliases that map common commands to shorter names, such as ls for Get-ChildItem, cd for Set-Location, and dir for Get-ChildItem -Directory. You can use the Get-Alias cmdlet to view the list of built-in aliases. In addition to the built-in aliases, you can create your own aliases or modify existing ones using the New-Alias and Set-Alias cmdlets. For example, you could create an alias wd for Set-Location -Path C:\\Windows, or you could modify the ls alias to include the -Force parameter by using Set-Alias. ls Get-ChildItem -Force While aliases can be useful in PowerShell for saving time and reducing typing, there are also some limitations and potential issues to be aware of: Clarity: Aliases can make code harder to understand, especially for other users who may not be familiar with the specific aliases you're using. It's generally recommended to use the full cmdlet names in scripts and functions to make the code more clear and self-explanatory. Conflicts: Multiple aliases can be defined for the same cmdlet, and aliases can also be defined for other aliases. This can lead to confusion and potential conflicts, especially when using modules or scripts that define their own aliases. Portability: Aliases are specific to the PowerShell session in which they are defined. If you use a script or module that relies on specific aliases, you may run into issues if those aliases are not defined on the system where the script is being run. Autocomplete: PowerShell's autocomplete feature may not work with aliases, depending on the specific environment and tools you're using. Overall, while aliases can be useful in certain situations, it's important to use them judiciously and be aware of their limitations and potential issues. It's generally best to use the full cmdlet names in scripts and functions to ensure clarity and portability, and to avoid potential conflicts with other aliases or scripts. Get-Alias Get-Alias is a PowerShell cmdlet that is used to display the aliases for cmdlets, functions, and scripts. It allows you to see the built-in aliases that are available in PowerShell, as well as any custom aliases that you or other users have created. Here are some common ways to use Get-Alias: List all aliases You can use the Get-Alias cmdlet without any parameters to list all the aliases available in your PowerShell session. Get-Alias List aliases for a specific command You can use the -Definition parameter followed by the name of the command to list all the aliases for that command. Get-Alias -Definition Get-ChildItem Search for a specific alias You can use the -Name parameter followed by a search pattern to find a specific alias or a group of aliases that match the pattern. Get-Alias -Name * s * Export aliases to a file You can use the Export-Alias cmdlet with the -Path parameter followed by the name and location of the file to export the aliases to a file. Get-Alias | Export-Alias -Path C :\\ Aliases . txt Import aliases from a file You can use the Import-Alias cmdlet with the -Path parameter followed by the name and location of the file to import the aliases from a file. Import-Alias -Path C :\\ Aliases . txt Overall, the Get-Alias cmdlet is a powerful tool for managing and customizing your PowerShell experience. It can help you save time and increase your productivity by allowing you to use shorthand commands and aliases that are easier to remember and type. New-Alias In PowerShell, the New-Alias cmdlet is used to create a new alias for a cmdlet, function, or script. The most common usage of New-Alias is to create a shorter, more convenient name for a longer, more complex command that you use frequently. For example, if you use the Get-ChildItem cmdlet frequently to list the contents of a directory, you could create an alias ls that maps to Get-ChildItem. Then, instead of typing Get-ChildItem, you could simply type ls to achieve the same result. This can save you time and typing effort, especially when working with long or complex commands. Here is an example of how to use New-Alias to create an alias: New-Alias -Name ls -Value Get-ChildItem This creates a new alias named ls that maps to the Get-ChildItem cmdlet. You can then use ls to list the contents of a directory, like this: ls C :\\ Windows This will list the contents of the C:\\Windows directory using the Get-ChildItem cmdlet, but you can use the shorter ls alias instead. Another example: new-alias -Name np -Value Notepad Another common use case for New-Alias is to create an alias for a function or script that you use frequently. For example, if you have a script named MyScript.ps1 that you want to run frequently, you could create an alias like this: New-Alias -Name myscript -Value C :\\ Scripts \\ MyScript . ps1 This creates a new alias named myscript that maps to the MyScript.ps1 script located at C:\\Scripts\\MyScript.ps1. You can then use myscript to run the script, like this: myscript This will run the MyScript.ps1 script, but you can use the shorter myscript alias instead. Overall, New-Alias is a useful cmdlet for creating custom aliases that can save you time and typing effort, especially when working with long or complex commands. Set-Alias In PowerShell, the Set-Alias cmdlet is used to change the definition of an existing alias. The most common usage of Set-Alias is to update an existing alias to map to a different cmdlet, function, or script. For example, if you have an alias named ls that currently maps to the Get-ChildItem cmdlet, but you want to change it to map to the Set-Location cmdlet instead, you can use Set-Alias like this: Set-Alias -Name ls -Value Set-Location This changes the definition of the ls alias to map to the Set-Location cmdlet instead of Get-ChildItem. You can then use ls to change to a different directory, like this: ls C :\\ Windows This will change to the C:\\Windows directory using the Set-Location cmdlet, which is now mapped to the ls alias. Another common use case for Set-Alias is to update an alias that was created by a module or script that you are using. For example, if a module that you are using creates an alias named gci that maps to the Get-ChildItem cmdlet, but you want to change it to map to a different cmdlet or function, you can use Set-Alias to update it. Set-Alias -Name gci -Value Get-Content This changes the definition of the gci alias to map to the Get-Content cmdlet instead of Get-ChildItem. You can then use gci to read the contents of a file, like this: gci C :\\ MyFile . txt This will read the contents of the C:\\MyFile.txt file using the Get-Content cmdlet, which is now mapped to the gci alias. Overall, Set-Alias is a useful cmdlet for updating existing aliases to map to different cmdlets, functions, or scripts. This can help you customize your PowerShell environment to better suit your needs and preferences. Other cmdlets In PowerShell, the Import-Alias, Export-Alias, and Remove-Alias cmdlets are used for managing aliases. Here's a brief explanation of each: Import-Alias This cmdlet is used to import a list of aliases from a file or another PowerShell session. It can be useful for setting up a consistent set of aliases across multiple systems or sessions. For example, you could use Import-Alias to load a set of aliases defined in a PowerShell profile or script. Example: Import-Alias -Path C :\\ Aliases \\ MyAliases . txt Export-Alias This cmdlet is used to export a list of aliases to a file or another PowerShell session. It can be useful for backing up or sharing sets of aliases. For example, you could use Export-Alias to save a set of aliases defined on your system and then import them on another system. Example: Export-Alias -Path C :\\ Aliases \\ MyAliases . txt Remove-Alias This cmdlet is used to remove an existing alias. It can be useful for cleaning up aliases that are no longer needed or that are causing conflicts with other aliases or cmdlets. Example: Remove-Alias -Name myAlias Note that when using Remove-Alias, you need to specify the name of the alias you want to remove. If the alias is defined in a PowerShell module or script, you may also need to remove it from those locations in order to fully clean up the alias.","title":"GetAlias"},{"location":"getalias/#get-alias","text":"Get-Alias is a PowerShell cmdlet that is used to display the aliases for cmdlets, functions, and scripts. It allows you to see the built-in aliases that are available in PowerShell, as well as any custom aliases that you or other users have created. Here are some common ways to use Get-Alias: List all aliases You can use the Get-Alias cmdlet without any parameters to list all the aliases available in your PowerShell session. Get-Alias List aliases for a specific command You can use the -Definition parameter followed by the name of the command to list all the aliases for that command. Get-Alias -Definition Get-ChildItem Search for a specific alias You can use the -Name parameter followed by a search pattern to find a specific alias or a group of aliases that match the pattern. Get-Alias -Name * s * Export aliases to a file You can use the Export-Alias cmdlet with the -Path parameter followed by the name and location of the file to export the aliases to a file. Get-Alias | Export-Alias -Path C :\\ Aliases . txt Import aliases from a file You can use the Import-Alias cmdlet with the -Path parameter followed by the name and location of the file to import the aliases from a file. Import-Alias -Path C :\\ Aliases . txt Overall, the Get-Alias cmdlet is a powerful tool for managing and customizing your PowerShell experience. It can help you save time and increase your productivity by allowing you to use shorthand commands and aliases that are easier to remember and type.","title":"Get-Alias"},{"location":"getalias/#new-alias","text":"In PowerShell, the New-Alias cmdlet is used to create a new alias for a cmdlet, function, or script. The most common usage of New-Alias is to create a shorter, more convenient name for a longer, more complex command that you use frequently. For example, if you use the Get-ChildItem cmdlet frequently to list the contents of a directory, you could create an alias ls that maps to Get-ChildItem. Then, instead of typing Get-ChildItem, you could simply type ls to achieve the same result. This can save you time and typing effort, especially when working with long or complex commands. Here is an example of how to use New-Alias to create an alias: New-Alias -Name ls -Value Get-ChildItem This creates a new alias named ls that maps to the Get-ChildItem cmdlet. You can then use ls to list the contents of a directory, like this: ls C :\\ Windows This will list the contents of the C:\\Windows directory using the Get-ChildItem cmdlet, but you can use the shorter ls alias instead. Another example: new-alias -Name np -Value Notepad Another common use case for New-Alias is to create an alias for a function or script that you use frequently. For example, if you have a script named MyScript.ps1 that you want to run frequently, you could create an alias like this: New-Alias -Name myscript -Value C :\\ Scripts \\ MyScript . ps1 This creates a new alias named myscript that maps to the MyScript.ps1 script located at C:\\Scripts\\MyScript.ps1. You can then use myscript to run the script, like this: myscript This will run the MyScript.ps1 script, but you can use the shorter myscript alias instead. Overall, New-Alias is a useful cmdlet for creating custom aliases that can save you time and typing effort, especially when working with long or complex commands.","title":"New-Alias"},{"location":"getalias/#set-alias","text":"In PowerShell, the Set-Alias cmdlet is used to change the definition of an existing alias. The most common usage of Set-Alias is to update an existing alias to map to a different cmdlet, function, or script. For example, if you have an alias named ls that currently maps to the Get-ChildItem cmdlet, but you want to change it to map to the Set-Location cmdlet instead, you can use Set-Alias like this: Set-Alias -Name ls -Value Set-Location This changes the definition of the ls alias to map to the Set-Location cmdlet instead of Get-ChildItem. You can then use ls to change to a different directory, like this: ls C :\\ Windows This will change to the C:\\Windows directory using the Set-Location cmdlet, which is now mapped to the ls alias. Another common use case for Set-Alias is to update an alias that was created by a module or script that you are using. For example, if a module that you are using creates an alias named gci that maps to the Get-ChildItem cmdlet, but you want to change it to map to a different cmdlet or function, you can use Set-Alias to update it. Set-Alias -Name gci -Value Get-Content This changes the definition of the gci alias to map to the Get-Content cmdlet instead of Get-ChildItem. You can then use gci to read the contents of a file, like this: gci C :\\ MyFile . txt This will read the contents of the C:\\MyFile.txt file using the Get-Content cmdlet, which is now mapped to the gci alias. Overall, Set-Alias is a useful cmdlet for updating existing aliases to map to different cmdlets, functions, or scripts. This can help you customize your PowerShell environment to better suit your needs and preferences.","title":"Set-Alias"},{"location":"getalias/#other-cmdlets","text":"In PowerShell, the Import-Alias, Export-Alias, and Remove-Alias cmdlets are used for managing aliases. Here's a brief explanation of each:","title":"Other cmdlets"},{"location":"getalias/#import-alias","text":"This cmdlet is used to import a list of aliases from a file or another PowerShell session. It can be useful for setting up a consistent set of aliases across multiple systems or sessions. For example, you could use Import-Alias to load a set of aliases defined in a PowerShell profile or script. Example: Import-Alias -Path C :\\ Aliases \\ MyAliases . txt","title":"Import-Alias"},{"location":"getalias/#export-alias","text":"This cmdlet is used to export a list of aliases to a file or another PowerShell session. It can be useful for backing up or sharing sets of aliases. For example, you could use Export-Alias to save a set of aliases defined on your system and then import them on another system. Example: Export-Alias -Path C :\\ Aliases \\ MyAliases . txt","title":"Export-Alias"},{"location":"getalias/#remove-alias","text":"This cmdlet is used to remove an existing alias. It can be useful for cleaning up aliases that are no longer needed or that are causing conflicts with other aliases or cmdlets. Example: Remove-Alias -Name myAlias Note that when using Remove-Alias, you need to specify the name of the alias you want to remove. If the alias is defined in a PowerShell module or script, you may also need to remove it from those locations in order to fully clean up the alias.","title":"Remove-Alias"},{"location":"gethelp/","text":"The Get-Help cmdlet is a powerful tool in PowerShell that provides information about commands, cmdlets, and modules. It has several parameters that allow you to customize the help output to suit your needs. Here are some of the most common parameters for the Get-Help cmdlet with examples: 1. -Name This parameter specifies the name of the command or cmdlet that you want help with. For example: Get-Help -Name Get-ChildItem This command will display help for the Get-ChildItem cmdlet, which is used to list the contents of a directory. 2. -Category This parameter specifies the category of help that you want to display. For example: Get-Help -Category Navigation This command will display all cmdlets related to navigation. 3. -Detailed This parameter displays detailed help information, including examples and parameter descriptions. For example: Get-Help -Name Get-ChildItem -Detailed This command will display detailed help information for the Get-ChildItem cmdlet. 4. -Examples This parameter displays examples of how to use the command or cmdlet. For example: Get-Help -Name Get-ChildItem -Examples This command will display examples of how to use the Get-ChildItem cmdlet. 5. -Full This parameter displays the full help information, including syntax and parameter descriptions. For example: Get-Help -Name Get-ChildItem -Full This command will display the full help information for the Get-ChildItem cmdlet. 6. -Parameter This parameter displays help information for a specific parameter of a command or cmdlet. For example: Get-Help -Name Get-ChildItem -Parameter Path This command will display help information for the Path parameter of the Get-ChildItem cmdlet. 7. -Online This parameter opens the online version of the help file for the command or cmdlet. For example: ``` Get-Help -Name Get-ChildItem -Online ``` This command will open the online version of the help file for the Get-ChildItem cmdlet. In summary, the Get-Help cmdlet is a versatile tool that can provide a lot of information about commands, cmdlets, and modules in PowerShell. By using the appropriate parameters, you can customize the help output to suit your needs and become more proficient in PowerShell.","title":"GetHelp"},{"location":"gethelp/#1-name","text":"This parameter specifies the name of the command or cmdlet that you want help with. For example: Get-Help -Name Get-ChildItem This command will display help for the Get-ChildItem cmdlet, which is used to list the contents of a directory.","title":"1. -Name"},{"location":"gethelp/#2-category","text":"This parameter specifies the category of help that you want to display. For example: Get-Help -Category Navigation This command will display all cmdlets related to navigation.","title":"2. -Category"},{"location":"gethelp/#3-detailed","text":"This parameter displays detailed help information, including examples and parameter descriptions. For example: Get-Help -Name Get-ChildItem -Detailed This command will display detailed help information for the Get-ChildItem cmdlet.","title":"3. -Detailed"},{"location":"gethelp/#4-examples","text":"This parameter displays examples of how to use the command or cmdlet. For example: Get-Help -Name Get-ChildItem -Examples This command will display examples of how to use the Get-ChildItem cmdlet.","title":"4. -Examples"},{"location":"gethelp/#5-full","text":"This parameter displays the full help information, including syntax and parameter descriptions. For example: Get-Help -Name Get-ChildItem -Full This command will display the full help information for the Get-ChildItem cmdlet.","title":"5. -Full"},{"location":"gethelp/#6-parameter","text":"This parameter displays help information for a specific parameter of a command or cmdlet. For example: Get-Help -Name Get-ChildItem -Parameter Path This command will display help information for the Path parameter of the Get-ChildItem cmdlet.","title":"6. -Parameter"},{"location":"gethelp/#7-online","text":"This parameter opens the online version of the help file for the command or cmdlet. For example: ``` Get-Help -Name Get-ChildItem -Online ``` This command will open the online version of the help file for the Get-ChildItem cmdlet. In summary, the Get-Help cmdlet is a versatile tool that can provide a lot of information about commands, cmdlets, and modules in PowerShell. By using the appropriate parameters, you can customize the help output to suit your needs and become more proficient in PowerShell.","title":"7. -Online"},{"location":"out_format/","text":"Here is a detailed table of the most common cmdlets available for reading and writing files in different formats in PowerShell: File Format Cmdlet for Reading Cmdlet for Writing Text Files (.txt) Get-Content Set-Content CSV Files (.csv) Import-Csv Export-Csv JSON Files (.json) ConvertFrom-Json ConvertTo-Json XML Files (.xml) Select-Xml Export-Clixml HTML Files Get-Content ConvertTo-Html Here are some examples of how to use these cmdlets: Text Get-Content The Get-Content cmdlet gets the content of the item at the location specified by the path, such as the text in a file or the content of a function. For files, the content is read one line at a time and returns a collection of objects, each of which represents a line of content. Beginning in PowerShell 3.0, Get-Content can also get a specified number of lines from the beginning or end of an item. Get-Content C :\\ example . txt Set-Content Set-Content is a string-processing cmdlet that writes new content or replaces the content in a file. Set-Content replaces the existing content and differs from the Add-Content cmdlet that appends content to a file. To send content to Set-Content you can use the Value parameter on the command line or send content through the pipeline. If you need to create files or directories for the following examples, see New-Item. Set-Content C :\\ example . txt \"This is some text.\" This command will write the text \"This is some text\" to the file file.txt located in the C:\\ directory. If the file already exists, its content will be overwritten. If the file does not exist, it will be created. Add-Content The Add-Content cmdlet appends content to a specified item or file. You can specify the content by typing the content in the command or by specifying an object that contains the content. If you need to create files or directories for the following examples, see New-Item. Add-Content -Path .\\*. txt -Exclude help * -Value 'End of file' The Path parameter specifies all .txt files in the current directory, but the Exclude parameter ignores file names that match the specified pattern. The Value parameter specifies the text string that is written to the files. Use Get-Content to display the contents of these files. Clear-Content The Clear-Content cmdlet deletes the contents of an item, such as deleting the text from a file, but it does not delete the item. As a result, the item exists, but it is empty. Clear-Content is similar to Clear-Item, but it works on items with contents, instead of items with values. Clear-Content \"..\\SmpUsers\\*\\init.txt\" This command deletes all of the content from the init.txt files in all subdirectories of the SmpUsers directory. The files are not deleted, but they are empty. CSV A CSV (Comma Separated Values) file is a plain text file format that stores tabular data in a simple, structured way, where each line represents a row, and the data within each row is separated by commas. The first line of the file usually contains the headers, which specify the column names. When working with CSV files in PowerShell, it's important to keep in mind that the file format is very simple and flexible, but can also be prone to errors if the data is not well-formed. It's important to validate and clean the data before working with it, and to always specify the correct headers and data types when importing or exporting CSV files. I/O Import-Csv C :\\ example . csv Import-CSV This cmdlet reads a CSV file and creates custom objects for each row, using the headers as the property names. You can then work with these objects as you would with any other PowerShell object. Here's an example: $csv = Import-CSV C :\\ data \\ users . csv foreach ( $user in $csv ) { Write-Output $user . Name } This code imports a CSV file containing user data, and then outputs the Name property of each user object. Export-CSV $data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | Export-Csv C :\\ example . csv -NoTypeInformation This cmdlet writes a collection of objects to a CSV file, using the object properties as the column names. Here's an example: $users = Get-ADUser -Filter * $users | Select-Object Name , EmailAddress | Export-CSV C :\\ data \\ users . csv -NoTypeInformation This code retrieves all users from Active Directory, selects the Name and EmailAddress properties, and then exports them to a CSV file. Conversion To/From ConvertTo-CSV This cmdlet converts a collection of objects to a CSV format, but does not write it to a file. You can then use other cmdlets (like Out-File or Set-Content) to write the CSV to a file. Here's an example: $processes = Get-Process $processes | Select-Object Name , ID , CPU | ConvertTo-CSV | Out-File C :\\ data \\ processes . csv This code retrieves information about running processes, selects the Name, ID, and CPU properties, converts it to CSV format, and then writes it to a file. Here's another example of how to use ConvertTo-CSV: # Create an array of objects $people = @( [PSCustomObject] @{ Name = \"John\" Age = 35 Occupation = \"Software Engineer\" }, [PSCustomObject] @{ Name = \"Jane\" Age = 28 Occupation = \"Project Manager\" } ) # Convert the objects to CSV format $csv = $people | ConvertTo-CSV # Output the CSV data $csv In this example, we first create an array of custom objects representing people with different attributes like name, age, and occupation. We then pipe this array to the ConvertTo-CSV cmdlet to convert it to CSV format and store the output in a variable called $csv. Finally, we output the CSV data using the $csv variable. ConvertFrom-CSV ConvertFrom-CSV is a cmdlet that allows you to convert CSV data back into PowerShell objects. This cmdlet takes the input CSV data, converts it into PowerShell objects, and outputs the objects. Here's an example of how to use ConvertFrom-CSV: # Convert CSV data to PowerShell objects $csvData = @\" Name,Age,Occupation John,35,Software Engineer Jane,28,Project Manager \"@ | ConvertFrom-CSV # Output the objects $csvData In this example, we first define a CSV string containing data about people, with each person represented as a row with columns for name, age, and occupation. We then pipe this CSV string to the ConvertFrom-CSV cmdlet to convert it into PowerShell objects and store the output in a variable called $csvData. Finally, we output the objects using the $csvData variable. JSON Reading a JSON file $json = Get-Content .\\ example . json | ConvertFrom-Json Writing to a JSON file $data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | ConvertTo-Json | Out-File .\\ example . json Testing a JSON file \"{'name': 'Ashley', 'age': 25}\" | Test-Json XML Reading an XML file $xml = Select-Xml -Path C :\\ example . xml -XPath \"//book\" Writing to an XML file $data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | Export-Clixml C :\\ example . xml HTML PowerShell provides a variety of cmdlets that can be used to manipulate HTML files, such as Invoke-WebRequest, Invoke-RestMethod, and ConvertTo-Html. Here are some examples of how to use these cmdlets to manipulate HTML files in PowerShell: Downloading an HTML file using Invoke-WebRequest: Invoke-WebRequest -Uri https :// example . com -OutFile example . html Extracting data from an HTML file using Invoke-RestMethod: $response = Invoke-RestMethod -Uri https :// example . com $response . Tables [ 0 ] | ConvertTo-Html -Fragment Converting a PowerShell object to an HTML table using ConvertTo-Html: Get-Process | Select-Object Name , CPU , WorkingSet | ConvertTo-Html -Head \"Process Report\" -PreContent \"<h1>Current Processes</h1>\" These are just a few examples of how to manipulate HTML files in PowerShell. The possibilities are endless, and these cmdlets can be combined with other PowerShell commands to perform more complex tasks. OUTPUT TO FILE OR PRINTER If you want to save the output of a command to an unformatted plain text file, you can use either of these methods (using the get-process command as an example): get-process > processes.txt (using redirection) get-process | out-file processes.txt (using the pipeline) Both versions are functionally equivalent, but the out-file command can receive parameters to change the line width and to avoid overwriting an existing file. To read a plain text file as text strings, you use the Get-Content cmdlet (with aliases cat or type): Get-Content processes . txt If you want to send the output of a command to the printer, you use the out-printer cmdlet: get-process | out-printer","title":"Output Format"},{"location":"out_format/#text","text":"","title":"Text"},{"location":"out_format/#get-content","text":"The Get-Content cmdlet gets the content of the item at the location specified by the path, such as the text in a file or the content of a function. For files, the content is read one line at a time and returns a collection of objects, each of which represents a line of content. Beginning in PowerShell 3.0, Get-Content can also get a specified number of lines from the beginning or end of an item. Get-Content C :\\ example . txt","title":"Get-Content"},{"location":"out_format/#set-content","text":"Set-Content is a string-processing cmdlet that writes new content or replaces the content in a file. Set-Content replaces the existing content and differs from the Add-Content cmdlet that appends content to a file. To send content to Set-Content you can use the Value parameter on the command line or send content through the pipeline. If you need to create files or directories for the following examples, see New-Item. Set-Content C :\\ example . txt \"This is some text.\" This command will write the text \"This is some text\" to the file file.txt located in the C:\\ directory. If the file already exists, its content will be overwritten. If the file does not exist, it will be created.","title":"Set-Content"},{"location":"out_format/#add-content","text":"The Add-Content cmdlet appends content to a specified item or file. You can specify the content by typing the content in the command or by specifying an object that contains the content. If you need to create files or directories for the following examples, see New-Item. Add-Content -Path .\\*. txt -Exclude help * -Value 'End of file' The Path parameter specifies all .txt files in the current directory, but the Exclude parameter ignores file names that match the specified pattern. The Value parameter specifies the text string that is written to the files. Use Get-Content to display the contents of these files.","title":"Add-Content"},{"location":"out_format/#clear-content","text":"The Clear-Content cmdlet deletes the contents of an item, such as deleting the text from a file, but it does not delete the item. As a result, the item exists, but it is empty. Clear-Content is similar to Clear-Item, but it works on items with contents, instead of items with values. Clear-Content \"..\\SmpUsers\\*\\init.txt\" This command deletes all of the content from the init.txt files in all subdirectories of the SmpUsers directory. The files are not deleted, but they are empty.","title":"Clear-Content"},{"location":"out_format/#csv","text":"A CSV (Comma Separated Values) file is a plain text file format that stores tabular data in a simple, structured way, where each line represents a row, and the data within each row is separated by commas. The first line of the file usually contains the headers, which specify the column names. When working with CSV files in PowerShell, it's important to keep in mind that the file format is very simple and flexible, but can also be prone to errors if the data is not well-formed. It's important to validate and clean the data before working with it, and to always specify the correct headers and data types when importing or exporting CSV files.","title":"CSV"},{"location":"out_format/#io","text":"Import-Csv C :\\ example . csv","title":"I/O"},{"location":"out_format/#import-csv","text":"This cmdlet reads a CSV file and creates custom objects for each row, using the headers as the property names. You can then work with these objects as you would with any other PowerShell object. Here's an example: $csv = Import-CSV C :\\ data \\ users . csv foreach ( $user in $csv ) { Write-Output $user . Name } This code imports a CSV file containing user data, and then outputs the Name property of each user object.","title":"Import-CSV"},{"location":"out_format/#export-csv","text":"$data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | Export-Csv C :\\ example . csv -NoTypeInformation This cmdlet writes a collection of objects to a CSV file, using the object properties as the column names. Here's an example: $users = Get-ADUser -Filter * $users | Select-Object Name , EmailAddress | Export-CSV C :\\ data \\ users . csv -NoTypeInformation This code retrieves all users from Active Directory, selects the Name and EmailAddress properties, and then exports them to a CSV file.","title":"Export-CSV"},{"location":"out_format/#conversion-tofrom","text":"","title":"Conversion To/From"},{"location":"out_format/#convertto-csv","text":"This cmdlet converts a collection of objects to a CSV format, but does not write it to a file. You can then use other cmdlets (like Out-File or Set-Content) to write the CSV to a file. Here's an example: $processes = Get-Process $processes | Select-Object Name , ID , CPU | ConvertTo-CSV | Out-File C :\\ data \\ processes . csv This code retrieves information about running processes, selects the Name, ID, and CPU properties, converts it to CSV format, and then writes it to a file. Here's another example of how to use ConvertTo-CSV: # Create an array of objects $people = @( [PSCustomObject] @{ Name = \"John\" Age = 35 Occupation = \"Software Engineer\" }, [PSCustomObject] @{ Name = \"Jane\" Age = 28 Occupation = \"Project Manager\" } ) # Convert the objects to CSV format $csv = $people | ConvertTo-CSV # Output the CSV data $csv In this example, we first create an array of custom objects representing people with different attributes like name, age, and occupation. We then pipe this array to the ConvertTo-CSV cmdlet to convert it to CSV format and store the output in a variable called $csv. Finally, we output the CSV data using the $csv variable.","title":"ConvertTo-CSV"},{"location":"out_format/#convertfrom-csv","text":"ConvertFrom-CSV is a cmdlet that allows you to convert CSV data back into PowerShell objects. This cmdlet takes the input CSV data, converts it into PowerShell objects, and outputs the objects. Here's an example of how to use ConvertFrom-CSV: # Convert CSV data to PowerShell objects $csvData = @\" Name,Age,Occupation John,35,Software Engineer Jane,28,Project Manager \"@ | ConvertFrom-CSV # Output the objects $csvData In this example, we first define a CSV string containing data about people, with each person represented as a row with columns for name, age, and occupation. We then pipe this CSV string to the ConvertFrom-CSV cmdlet to convert it into PowerShell objects and store the output in a variable called $csvData. Finally, we output the objects using the $csvData variable.","title":"ConvertFrom-CSV"},{"location":"out_format/#json","text":"","title":"JSON"},{"location":"out_format/#reading-a-json-file","text":"$json = Get-Content .\\ example . json | ConvertFrom-Json","title":"Reading a JSON file"},{"location":"out_format/#writing-to-a-json-file","text":"$data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | ConvertTo-Json | Out-File .\\ example . json","title":"Writing to a JSON file"},{"location":"out_format/#testing-a-json-file","text":"\"{'name': 'Ashley', 'age': 25}\" | Test-Json","title":"Testing a JSON file"},{"location":"out_format/#xml","text":"","title":"XML"},{"location":"out_format/#reading-an-xml-file","text":"$xml = Select-Xml -Path C :\\ example . xml -XPath \"//book\"","title":"Reading an XML file"},{"location":"out_format/#writing-to-an-xml-file","text":"$data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | Export-Clixml C :\\ example . xml","title":"Writing to an XML file"},{"location":"out_format/#html","text":"PowerShell provides a variety of cmdlets that can be used to manipulate HTML files, such as Invoke-WebRequest, Invoke-RestMethod, and ConvertTo-Html. Here are some examples of how to use these cmdlets to manipulate HTML files in PowerShell: Downloading an HTML file using Invoke-WebRequest: Invoke-WebRequest -Uri https :// example . com -OutFile example . html Extracting data from an HTML file using Invoke-RestMethod: $response = Invoke-RestMethod -Uri https :// example . com $response . Tables [ 0 ] | ConvertTo-Html -Fragment Converting a PowerShell object to an HTML table using ConvertTo-Html: Get-Process | Select-Object Name , CPU , WorkingSet | ConvertTo-Html -Head \"Process Report\" -PreContent \"<h1>Current Processes</h1>\" These are just a few examples of how to manipulate HTML files in PowerShell. The possibilities are endless, and these cmdlets can be combined with other PowerShell commands to perform more complex tasks.","title":"HTML"},{"location":"out_format/#output-to-file-or-printer","text":"If you want to save the output of a command to an unformatted plain text file, you can use either of these methods (using the get-process command as an example): get-process > processes.txt (using redirection) get-process | out-file processes.txt (using the pipeline) Both versions are functionally equivalent, but the out-file command can receive parameters to change the line width and to avoid overwriting an existing file. To read a plain text file as text strings, you use the Get-Content cmdlet (with aliases cat or type): Get-Content processes . txt If you want to send the output of a command to the printer, you use the out-printer cmdlet: get-process | out-printer","title":"OUTPUT TO FILE OR PRINTER"},{"location":"pipeline/","text":"The pipeline in PowerShell is a feature that allows you to take the output of one command and pass it as input to another command. This makes it possible to create more complex commands by chaining simple commands together. The pipeline operator, represented by the \"|\" character, is used to connect commands together. Here are some examples of how to use the pipeline in PowerShell: Example 1: Get-ChildItem and Select-Object The Get-ChildItem command is used to list the files and folders in a specified directory. The Select-Object command is used to select specific properties of the objects returned by Get-ChildItem. By using the pipeline, you can pass the output of Get-ChildItem to Select-Object to filter the results. Get-ChildItem | Select-Object Name , Length , LastWriteTime This command lists the files and folders in the current directory and then selects the Name, Length, and LastWriteTime properties of each item. Example 2: Get-Process and Sort-Object The Get-Process command is used to list the running processes on a system. The Sort-Object command is used to sort the results based on a specific property. By using the pipeline, you can pass the output of Get-Process to Sort-Object to sort the results by CPU usage. Get-Process | Sort-Object CPU -Descending This command lists the running processes and then sorts them in descending order based on their CPU usage. Example 3: Get-Service and Where-Object The Get-Service command is used to list the services on a system. The Where-Object command is used to filter the results based on a specific condition. By using the pipeline, you can pass the output of Get-Service to Where-Object to filter the results to only show services that are currently running. Get-Service | Where-Object Status -eq \"Running\" This command lists all of the services on the system and then filters the results to only show services that have a Status property equal to \"Running\". In each of these examples, the pipeline is used to pass the output of one command to another command. This allows you to create more powerful commands by combining simple commands together. Order & Selection The pipeline can be used to select properties of objects that are not displayed by default when using a cmdlet. It can also be used to filter results (using search criteria). To sort, the Sort-Object cmdlet (abbreviated sort) is used, and to select properties, Select-Object (abbreviated select) is used. For example, the process list is normally displayed in alphabetical order by process name. To sort it by Process ID, the command is: get-process | sort id To sort it by virtual memory usage in descending order: get-process | sort vm -desc Note that in this last example, it is sorting by a field that is not normally displayed on the screen. To change the fields that are displayed, select is used: get-process | select -property id , name , vm | sort vm -desc This example shows a table with the identifier, name, and virtual memory usage of the machine's processes, ordered in descending order by virtual memory usage. Remember that to view the properties of an object (the fields that can be displayed), the Get-Member cmdlet (abbreviated gm) is used: Get-Process | gm Passing parameters In a pipeline of the type: Command_A | Command_B ...parameters can be passed in two ways: By value (ByValue) In this case, PowerShell analyzes the output type of Command_A and determines which parameter of Command_B can receive this output. Example: Analyzing the command Get-Process | Stop-Process In this case, Get-Process produces Process type objects. Examining the help for Stop-Process, the following parameter is found: -InputObject <Process[]> Specifies the process objects to stop. Enter a variable that contains the objects, or type a command or expression that gets the objects. Required? true Position? 0 Default value None Accept pipeline input? True (ByValue) Accept wildcard characters? false As you can see, this parameter can receive values from the pipeline, using the ByValue method. For this reason, the command works. If you try to connect two commands to the pipeline that do not have compatible output and parameter types, an error occurs. It can also happen that data is passed through the wrong parameter. For example, suppose the file computers.txt contains the names of several computers, and you want to display the list of services on each of these computers. You could use the command: Get-Content computers . txt | get-service This command produces an error because the required parameter (ComputerName) does not accept input through the pipeline using the ByValue method. The command can then be executed using parentheses: get-service -computername ( get-content computers . txt ) By parameter name (ByPropertyName) In this method, you must specify the parameter names. For example, consider a file called alias.txt with the following content: Name,Value np,notepad sel,Select-Object go,Invoke-Command The idea is to use the contents of this file to input it to the new-alias command and create the aliases listed in the file. Note that the first line of the file corresponds to the column headers. If this file is imported with Import-Csv, the following is obtained: PS C :\\ Users \\ Usuario \\ powershell > Import-Csv .\\ alias . txt Name Value ---- ----- np notepad sel Select-Object go Invoke-Command If you use Get-Member to analyze this output, you get: TypeName: System.Management.Automation.PSCustomObject Name MemberType Definition ---- ---------- ---------- Equals Method bool Equals(System.Object obj) GetHashCode Method int GetHashCode() GetType Method type GetType() ToString Method string ToString() Name NoteProperty string Name=np Value NoteProperty string Value=notepad It can be seen that the last two properties are of type String. Let's now analyze the parameters of the New-Alias command: New-Alias [-Name] <String> [-Value] <String> [-Confirm] [-Description <String>] [-Force] [-Option {None | ReadOnly | Constant | Private | AllScope | Unspecified}] [-PassThru] [-Scope <String>] [-WhatIf] [<CommonParameters>] The Name and Value parameters receive String inputs. And if you review the complete help, you can verify that both parameters receive values through the pipeline using the ByPropertyName mode: -Name <String> Specifies the new alias. You can use any alphanumeric characters in an alias, but the first character cannot be a number. Required? true Position? 0 Default value None Accept pipeline input? True (ByPropertyName) Accept wildcard characters? false -Value <String> Specifies the name of the cmdlet or command element that is being aliased. Required? true Position? 1 Default value None Accept pipeline input? True (ByPropertyName) Accept wildcard characters? false Therefore, information can be passed from one command to another in the following way: import-csv alias . txt | new-alias","title":"Pipeline"},{"location":"pipeline/#order-selection","text":"The pipeline can be used to select properties of objects that are not displayed by default when using a cmdlet. It can also be used to filter results (using search criteria). To sort, the Sort-Object cmdlet (abbreviated sort) is used, and to select properties, Select-Object (abbreviated select) is used. For example, the process list is normally displayed in alphabetical order by process name. To sort it by Process ID, the command is: get-process | sort id To sort it by virtual memory usage in descending order: get-process | sort vm -desc Note that in this last example, it is sorting by a field that is not normally displayed on the screen. To change the fields that are displayed, select is used: get-process | select -property id , name , vm | sort vm -desc This example shows a table with the identifier, name, and virtual memory usage of the machine's processes, ordered in descending order by virtual memory usage. Remember that to view the properties of an object (the fields that can be displayed), the Get-Member cmdlet (abbreviated gm) is used: Get-Process | gm","title":"Order &amp; Selection"},{"location":"pipeline/#passing-parameters","text":"In a pipeline of the type: Command_A | Command_B ...parameters can be passed in two ways:","title":"Passing parameters"},{"location":"pipeline/#by-value-byvalue","text":"In this case, PowerShell analyzes the output type of Command_A and determines which parameter of Command_B can receive this output. Example: Analyzing the command Get-Process | Stop-Process In this case, Get-Process produces Process type objects. Examining the help for Stop-Process, the following parameter is found: -InputObject <Process[]> Specifies the process objects to stop. Enter a variable that contains the objects, or type a command or expression that gets the objects. Required? true Position? 0 Default value None Accept pipeline input? True (ByValue) Accept wildcard characters? false As you can see, this parameter can receive values from the pipeline, using the ByValue method. For this reason, the command works. If you try to connect two commands to the pipeline that do not have compatible output and parameter types, an error occurs. It can also happen that data is passed through the wrong parameter. For example, suppose the file computers.txt contains the names of several computers, and you want to display the list of services on each of these computers. You could use the command: Get-Content computers . txt | get-service This command produces an error because the required parameter (ComputerName) does not accept input through the pipeline using the ByValue method. The command can then be executed using parentheses: get-service -computername ( get-content computers . txt )","title":"By value (ByValue)"},{"location":"pipeline/#by-parameter-name-bypropertyname","text":"In this method, you must specify the parameter names. For example, consider a file called alias.txt with the following content: Name,Value np,notepad sel,Select-Object go,Invoke-Command The idea is to use the contents of this file to input it to the new-alias command and create the aliases listed in the file. Note that the first line of the file corresponds to the column headers. If this file is imported with Import-Csv, the following is obtained: PS C :\\ Users \\ Usuario \\ powershell > Import-Csv .\\ alias . txt Name Value ---- ----- np notepad sel Select-Object go Invoke-Command If you use Get-Member to analyze this output, you get: TypeName: System.Management.Automation.PSCustomObject Name MemberType Definition ---- ---------- ---------- Equals Method bool Equals(System.Object obj) GetHashCode Method int GetHashCode() GetType Method type GetType() ToString Method string ToString() Name NoteProperty string Name=np Value NoteProperty string Value=notepad It can be seen that the last two properties are of type String. Let's now analyze the parameters of the New-Alias command: New-Alias [-Name] <String> [-Value] <String> [-Confirm] [-Description <String>] [-Force] [-Option {None | ReadOnly | Constant | Private | AllScope | Unspecified}] [-PassThru] [-Scope <String>] [-WhatIf] [<CommonParameters>] The Name and Value parameters receive String inputs. And if you review the complete help, you can verify that both parameters receive values through the pipeline using the ByPropertyName mode: -Name <String> Specifies the new alias. You can use any alphanumeric characters in an alias, but the first character cannot be a number. Required? true Position? 0 Default value None Accept pipeline input? True (ByPropertyName) Accept wildcard characters? false -Value <String> Specifies the name of the cmdlet or command element that is being aliased. Required? true Position? 1 Default value None Accept pipeline input? True (ByPropertyName) Accept wildcard characters? false Therefore, information can be passed from one command to another in the following way: import-csv alias . txt | new-alias","title":"By parameter name (ByPropertyName)"},{"location":"tables_lists/","text":"OUTPUT FORMAT: TABLES, LISTS, WIDE DISPLAY Powershell commands present their output in tables or lists, depending on the command being used and the attributes it is asked to display. The Select-Object command (abbreviated as Select) can be used to determine the attributes that are displayed. However, the display is limited to the attributes related to the invoked command. For example: Get Process | select name , vm ...displays a list of processes, made up only of the name of each process and the amount of virtual memory it uses. The formatting commands allow, in addition to printing the standard attributes, to display attributes calculated from the basic attributes. The display can be done in table, list or wide format mode. TABLE FORMAT The Format-Table cmdlet (abbreviated as ft) allows you to display the output of a command in table format. The parameters received by this command are the following: Parameters Meaning -Property Allows you to specify the attributes (native or calculated) that you want to display. The wildcard * can be used to specify all of them. -Autosize Allows the command to accommodate the width of the columns in the best possible way. Normally this width is fixed, but this parameter adjusts the width of the columns to the longest value of each attribute. -Groupby This parameter specifies one of the fields. Each time there is a change in the value of this field, a new set of headers is printed. It is recommended to use Sort-Object before doing a Format-Table with Groupby, to avoid unnecessary repetition of headers. -Wrap When a field's value is excessively long, Powershell wraps it, indicating this with an ellipsis (...). The Wrap parameter causes long values to span one or more additional lines, depending on the length of the value. Examples: get-process | ft-Property * ... tries to print all the attributes of the processes. Powershell reviews all lines of the output, and does its best to accommodate all possible fields. Due to this hotfix, the command takes a relatively long time to execute. get-process | ft -Property ID , Name , Responding -AutoSize ...gets a list of processes with ID, Name, and Responding attributes. The width of the columns is optimized. get-process | ft -Property * -autosize ... tries to print all the attributes of the processes. However, this command runs faster, since the width of the columns is optimized. Get-Service | sortStatus | ft Name , Status , DisplayName -groupby Status ... prints a list of services divided into two sections: One of stopped services (Stopped) and another of running services (Running). Get-Service | ft Name , Status , DisplayName -autosize -wrap ...prints a list of services with the attributes Name, Status and DisplayName. The DisplayName attribute (which is the longest) will span multiple lines if necessary. LIST FORMAT The Format-List cmdlet (abbreviated fl) allows you to display attributes as a series of name-value pairs, for example: Get-Service -name bits | fl -Property * Name : bits RequiredServices : { RpcSs } CanPauseAndContinue : False CanShutdown : False CanStop : False DisplayName : Background Intelligent Transfer Service DependentServices : {} MachineName : . ServiceName : bits ServicesDependedOn : { RpcSs } ServiceHandle : Status : Stopped ServiceType : Win32ShareProcess StartType : Manual Site : Container : Note that the output of the Get-Service command was filtered here, to get only the information for the BITS service (otherwise, Format-List would have returned a similar set of lines for each service). Here Format-List was asked to display all attributes of the service (the -Property parameter with wildcard). WIDE FORMAT The wide format allows you to display two or more columns of a particular object property, much like the Linux ls command. The Format-Wide (abbreviated fw) cmdlet is used for this purpose. Examples: get-process | format-wide ... displays two columns of process names (Format-wide defaults to the Name property). get-process | format-wide name -col 4 ...shows 4 columns of process names. CHANGE OF NAMES OF ATTRIBUTES An example of renaming an attribute is the following: get service | ft @{ name = 'Service' ; expression ={ $_ . Name }}, Status , DisplayName In this case, a new column is defined, using the expression between the @{ } symbols. Name indicates the name that the column will have. It can be abbreviated as n. Expression defines the content of the column. It can be abbreviated as e. $ is a special variable that holds the object that is currently being processed. For this example, $ .Name means: \"Of the current object, take the Name property.\" The above command could be abbreviated like this: get service | ft @{ n = 'Service' ; e ={ $_ . Name }}, Status , DisplayName The following command: get-process | ft Name ,@{ n = 'VM (MB)' ; e ={ $_ . VM / 1MB }} ...displays a process table with two columns: Name (native property) and VM (MB), which shows the amount of virtual memory used by the process, in megabytes. The command: get-process | ft Name ,@{ n = 'VM (MB)' ; e ={ $_ . VM / 1MB -as [int] }} -AutoSize ...displays a table similar to the one in the previous example, but rounds the virtual memory to an integer value. USING THE FORMAT COMMANDS The formatting command to be used (ft, fl or fw) must be the last one in the pipeline before printing to the screen. The output of a format command can only be redirected to a TEXT file. If you try to convert the output to another format (CSV, HTML, XML) the results will be inconsistent. MORE FILTERING STRATEGIES Command output can be filtered in several ways: Using wildcards in the parameters that support it. For example: get-service -name s * ...displays a list of services whose name starts with S. If the parameter does not support wildcards, the Where-Object (abbreviated Where) cmdlet can be used in the pipeline. For example: Get-Service | where -filter { $_ . Status -like \"Run*\" } ...displays a list of services whose status starts with \"Run\" Some of the comparison operators that can be used are: Operator Meaning -eq Equal -ne not equal -gt Greater than -ge Greater than or equal -lt Less Than -le Less than or equal -like Matches the expression with wildcards -notlike Does not match the expression with wildcards For example: Get-Service | where -filter { $_ . Status -eq \"Running\" } String comparisons are normally not case sensitive. If it is required to do so, a c is placed before the operators (-ceq, -cne, -cgt, -cge...). You can also use the connectives -and and -or. For more information, see the help topic about_comparison_operators. A COMPLETE EXAMPLE OF COMPLEX FILTERING It is required to draw a list that includes the 10 processes that are consuming the most virtual memory, not including Powershell. At the end, the total virtual memory that these 10 processes are consuming should be presented. The listing should only include the Name and VM columns. The first step (filtering Powershell processes) can be done like this: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } Then it is organized by the VM column, in descending order, and the columns that you want to show are specified: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } | sort VM -desc | select name , vm Finally, the Measure-Object cmdlet is used to find the total virtual memory usage: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } | sort VM | select name , vm -first 10 | Measure-Object -Property vm -sum","title":"Formatting"},{"location":"tables_lists/#output-format-tables-lists-wide-display","text":"Powershell commands present their output in tables or lists, depending on the command being used and the attributes it is asked to display. The Select-Object command (abbreviated as Select) can be used to determine the attributes that are displayed. However, the display is limited to the attributes related to the invoked command. For example: Get Process | select name , vm ...displays a list of processes, made up only of the name of each process and the amount of virtual memory it uses. The formatting commands allow, in addition to printing the standard attributes, to display attributes calculated from the basic attributes. The display can be done in table, list or wide format mode.","title":"OUTPUT FORMAT: TABLES, LISTS, WIDE DISPLAY"},{"location":"tables_lists/#table-format","text":"The Format-Table cmdlet (abbreviated as ft) allows you to display the output of a command in table format. The parameters received by this command are the following: Parameters Meaning -Property Allows you to specify the attributes (native or calculated) that you want to display. The wildcard * can be used to specify all of them. -Autosize Allows the command to accommodate the width of the columns in the best possible way. Normally this width is fixed, but this parameter adjusts the width of the columns to the longest value of each attribute. -Groupby This parameter specifies one of the fields. Each time there is a change in the value of this field, a new set of headers is printed. It is recommended to use Sort-Object before doing a Format-Table with Groupby, to avoid unnecessary repetition of headers. -Wrap When a field's value is excessively long, Powershell wraps it, indicating this with an ellipsis (...). The Wrap parameter causes long values to span one or more additional lines, depending on the length of the value. Examples: get-process | ft-Property * ... tries to print all the attributes of the processes. Powershell reviews all lines of the output, and does its best to accommodate all possible fields. Due to this hotfix, the command takes a relatively long time to execute. get-process | ft -Property ID , Name , Responding -AutoSize ...gets a list of processes with ID, Name, and Responding attributes. The width of the columns is optimized. get-process | ft -Property * -autosize ... tries to print all the attributes of the processes. However, this command runs faster, since the width of the columns is optimized. Get-Service | sortStatus | ft Name , Status , DisplayName -groupby Status ... prints a list of services divided into two sections: One of stopped services (Stopped) and another of running services (Running). Get-Service | ft Name , Status , DisplayName -autosize -wrap ...prints a list of services with the attributes Name, Status and DisplayName. The DisplayName attribute (which is the longest) will span multiple lines if necessary.","title":"TABLE FORMAT"},{"location":"tables_lists/#list-format","text":"The Format-List cmdlet (abbreviated fl) allows you to display attributes as a series of name-value pairs, for example: Get-Service -name bits | fl -Property * Name : bits RequiredServices : { RpcSs } CanPauseAndContinue : False CanShutdown : False CanStop : False DisplayName : Background Intelligent Transfer Service DependentServices : {} MachineName : . ServiceName : bits ServicesDependedOn : { RpcSs } ServiceHandle : Status : Stopped ServiceType : Win32ShareProcess StartType : Manual Site : Container : Note that the output of the Get-Service command was filtered here, to get only the information for the BITS service (otherwise, Format-List would have returned a similar set of lines for each service). Here Format-List was asked to display all attributes of the service (the -Property parameter with wildcard).","title":"LIST FORMAT"},{"location":"tables_lists/#wide-format","text":"The wide format allows you to display two or more columns of a particular object property, much like the Linux ls command. The Format-Wide (abbreviated fw) cmdlet is used for this purpose. Examples: get-process | format-wide ... displays two columns of process names (Format-wide defaults to the Name property). get-process | format-wide name -col 4 ...shows 4 columns of process names.","title":"WIDE FORMAT"},{"location":"tables_lists/#change-of-names-of-attributes","text":"An example of renaming an attribute is the following: get service | ft @{ name = 'Service' ; expression ={ $_ . Name }}, Status , DisplayName In this case, a new column is defined, using the expression between the @{ } symbols. Name indicates the name that the column will have. It can be abbreviated as n. Expression defines the content of the column. It can be abbreviated as e. $ is a special variable that holds the object that is currently being processed. For this example, $ .Name means: \"Of the current object, take the Name property.\" The above command could be abbreviated like this: get service | ft @{ n = 'Service' ; e ={ $_ . Name }}, Status , DisplayName The following command: get-process | ft Name ,@{ n = 'VM (MB)' ; e ={ $_ . VM / 1MB }} ...displays a process table with two columns: Name (native property) and VM (MB), which shows the amount of virtual memory used by the process, in megabytes. The command: get-process | ft Name ,@{ n = 'VM (MB)' ; e ={ $_ . VM / 1MB -as [int] }} -AutoSize ...displays a table similar to the one in the previous example, but rounds the virtual memory to an integer value.","title":"CHANGE OF NAMES OF ATTRIBUTES"},{"location":"tables_lists/#using-the-format-commands","text":"The formatting command to be used (ft, fl or fw) must be the last one in the pipeline before printing to the screen. The output of a format command can only be redirected to a TEXT file. If you try to convert the output to another format (CSV, HTML, XML) the results will be inconsistent.","title":"USING THE FORMAT COMMANDS"},{"location":"tables_lists/#more-filtering-strategies","text":"Command output can be filtered in several ways: Using wildcards in the parameters that support it. For example: get-service -name s * ...displays a list of services whose name starts with S. If the parameter does not support wildcards, the Where-Object (abbreviated Where) cmdlet can be used in the pipeline. For example: Get-Service | where -filter { $_ . Status -like \"Run*\" } ...displays a list of services whose status starts with \"Run\" Some of the comparison operators that can be used are: Operator Meaning -eq Equal -ne not equal -gt Greater than -ge Greater than or equal -lt Less Than -le Less than or equal -like Matches the expression with wildcards -notlike Does not match the expression with wildcards For example: Get-Service | where -filter { $_ . Status -eq \"Running\" } String comparisons are normally not case sensitive. If it is required to do so, a c is placed before the operators (-ceq, -cne, -cgt, -cge...). You can also use the connectives -and and -or. For more information, see the help topic about_comparison_operators.","title":"MORE FILTERING STRATEGIES"},{"location":"tables_lists/#a-complete-example-of-complex-filtering","text":"It is required to draw a list that includes the 10 processes that are consuming the most virtual memory, not including Powershell. At the end, the total virtual memory that these 10 processes are consuming should be presented. The listing should only include the Name and VM columns. The first step (filtering Powershell processes) can be done like this: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } Then it is organized by the VM column, in descending order, and the columns that you want to show are specified: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } | sort VM -desc | select name , vm Finally, the Measure-Object cmdlet is used to find the total virtual memory usage: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } | sort VM | select name , vm -first 10 | Measure-Object -Property vm -sum","title":"A COMPLETE EXAMPLE OF COMPLEX FILTERING"},{"location":"wmi_cmi/","text":"WMI and CMI basics A Windows computer contains thousands of items of management information. The WMI (Windows Management Instrumentation) and CIM (Common Information Model) frameworks seek to facilitate and organize these elements. Information in WMI is organized by namespaces. The root\\CIMv2 namespace contains all information about the Windows operating system and the underlying hardware. On client computers, the namespace root\\SecurityCenter2 ( root\\SecurityCenter in earlier versions of the operating system) contains information about firewall, antivirus, and antispyware software installed on the computer. Within each namespace, WMI includes a series of classes. Each class represents a type of management component that WMI knows how to query. For example, the Win32_LogicalDisk class in the root\\CIMv2 namespace contains information about logical disks, while the AntiSpywareProduct class in the root\\SecurityCenterv2 namespace contains information about antispyware products. . If manageable components exist for a certain class, they will appear as instances of that class. Class names in the root\\CIMv2 namespace usually start with Win32_ (even on 64-bit machines) or CIM_ . Typically, the properties of such instances are read-only (that is, you cannot make changes to the parameter values). There are different tools designed to explore the different classes of WMI. One of them is WMI Explorer Get-WmiObject You can use the Get-WmiObject cmdlet to explore WMI namespaces. For example, if you wanted to query the classes related to disks, you could use the following command: Get-WmiObject -Namespace root \\ CIMv2 -list | where name -like '*disk*' The following command displays a complete list of classes within the root\\CIMv2 namespace: Get-WmiObject -Namespace root \\ CIMv2 -list To interrogate a specific class, use the -class parameter: Get-WmiObject -Namespace root \\ CIMv2 -class win32_desktop The above command can be abbreviated, since the default namespace is root\\CIMv2 , and the -class parameter are both positional: Get-WmiObject win32_desktop Get-CimInstance The Get-CimInstance command was introduced in Powershell version 3, and works much like Get-WmiObject , except for the following: The -ClassName parameter is used instead of -Class . There is no -list parameter to list all classes in a namespace. The Get-CimClass cmdlet must be used with the -Namespace parameter. Examples: List the instances of the Win32_LogicalDisk class: Get-CimInstance -ClassName win32_logicaldisk Get the list of classes from root\\CIMv2 , filtering out those that have to do with disks: Get-CimClass -Namespace root \\ CIMv2 | where cimclassname -Like '*disk*'","title":"Windows Management"},{"location":"wmi_cmi/#wmi-and-cmi-basics","text":"A Windows computer contains thousands of items of management information. The WMI (Windows Management Instrumentation) and CIM (Common Information Model) frameworks seek to facilitate and organize these elements. Information in WMI is organized by namespaces. The root\\CIMv2 namespace contains all information about the Windows operating system and the underlying hardware. On client computers, the namespace root\\SecurityCenter2 ( root\\SecurityCenter in earlier versions of the operating system) contains information about firewall, antivirus, and antispyware software installed on the computer. Within each namespace, WMI includes a series of classes. Each class represents a type of management component that WMI knows how to query. For example, the Win32_LogicalDisk class in the root\\CIMv2 namespace contains information about logical disks, while the AntiSpywareProduct class in the root\\SecurityCenterv2 namespace contains information about antispyware products. . If manageable components exist for a certain class, they will appear as instances of that class. Class names in the root\\CIMv2 namespace usually start with Win32_ (even on 64-bit machines) or CIM_ . Typically, the properties of such instances are read-only (that is, you cannot make changes to the parameter values). There are different tools designed to explore the different classes of WMI. One of them is WMI Explorer","title":"WMI and CMI basics"},{"location":"wmi_cmi/#get-wmiobject","text":"You can use the Get-WmiObject cmdlet to explore WMI namespaces. For example, if you wanted to query the classes related to disks, you could use the following command: Get-WmiObject -Namespace root \\ CIMv2 -list | where name -like '*disk*' The following command displays a complete list of classes within the root\\CIMv2 namespace: Get-WmiObject -Namespace root \\ CIMv2 -list To interrogate a specific class, use the -class parameter: Get-WmiObject -Namespace root \\ CIMv2 -class win32_desktop The above command can be abbreviated, since the default namespace is root\\CIMv2 , and the -class parameter are both positional: Get-WmiObject win32_desktop","title":"Get-WmiObject"},{"location":"wmi_cmi/#get-ciminstance","text":"The Get-CimInstance command was introduced in Powershell version 3, and works much like Get-WmiObject , except for the following: The -ClassName parameter is used instead of -Class . There is no -list parameter to list all classes in a namespace. The Get-CimClass cmdlet must be used with the -Namespace parameter. Examples: List the instances of the Win32_LogicalDisk class: Get-CimInstance -ClassName win32_logicaldisk Get the list of classes from root\\CIMv2 , filtering out those that have to do with disks: Get-CimClass -Namespace root \\ CIMv2 | where cimclassname -Like '*disk*'","title":"Get-CimInstance"},{"location":"Exercises/Exercises1/","text":"Exercises on Get-Help usage Verify if there are cmdlets that allow converting the output of another cmdlet to HTML format. Click me for proposed solution help * html * Verify which cmdlets allow directing output to a printer or a file. Click me for proposed solution Out-Printer Out-File Verify how many cmdlets are used to manage processes. Click me for proposed solution help * Process * Which cmdlet can be used to write an entry to an event log? Click me for proposed solution Write-EventLog Which cmdlets can be used to manage aliases? Click me for proposed solution help * alias * Is there a way to keep a transcript of a PowerShell session and save it to a file? Click me for proposed solution Start-Transcript -Path \"C:\\transcripts\\transcript0.txt\" -NoClobber How can you get the 100 most recent records from the SECURITY event log on a system? Click me for proposed solution Get-EventLog -LogName SECURITY -Newest 100 Is there a way to obtain the list of services that are running on a remote computer? Click me for proposed solution Answer: Yes, you can use the Get-Service cmdlet with the -ComputerName parameter followed by the name of the remote computer to obtain the list of services running on that computer. Example: Get-Service -ComputerName RemoteComputerName Is there a way to obtain the list of services that are running on a remote computer? Click me for proposed solution Answer: Yes, you can use the Get-Process cmdlet with the -ComputerName parameter followed by the name of the remote computer to obtain the list of processes running on that computer. Example: Get-Process -ComputerName RemoteComputerName Review the help of the Out-File cmdlet. What is the line size used by this cmdlet by default? Is there a parameter that allows you to change this size? Click me for proposed solution Answer: The line size used by default by the Out-File cmdlet is 80 characters. You can change this size using the -Width parameter followed by the desired width. Example: Get-Process | Out-File -FilePath C :\\ Processes . txt -Width 120 By default, Out-File overwrites the output file if it already exists. Is there a parameter that prevents the overwriting of an existing file? Click me for proposed solution Answer: Yes, the -NoClobber parameter can be used to prevent the overwriting of an existing file. If this parameter is used and the output file already exists, Out-File will not overwrite the file and will instead display an error message. Example: Get-Process | Out-File -FilePath C :\\ Processes . txt -NoClobber","title":"Exercise 1"},{"location":"Exercises/Exercises1/#exercises-on-get-help-usage","text":"Verify if there are cmdlets that allow converting the output of another cmdlet to HTML format. Click me for proposed solution help * html * Verify which cmdlets allow directing output to a printer or a file. Click me for proposed solution Out-Printer Out-File Verify how many cmdlets are used to manage processes. Click me for proposed solution help * Process * Which cmdlet can be used to write an entry to an event log? Click me for proposed solution Write-EventLog Which cmdlets can be used to manage aliases? Click me for proposed solution help * alias * Is there a way to keep a transcript of a PowerShell session and save it to a file? Click me for proposed solution Start-Transcript -Path \"C:\\transcripts\\transcript0.txt\" -NoClobber How can you get the 100 most recent records from the SECURITY event log on a system? Click me for proposed solution Get-EventLog -LogName SECURITY -Newest 100 Is there a way to obtain the list of services that are running on a remote computer? Click me for proposed solution Answer: Yes, you can use the Get-Service cmdlet with the -ComputerName parameter followed by the name of the remote computer to obtain the list of services running on that computer. Example: Get-Service -ComputerName RemoteComputerName Is there a way to obtain the list of services that are running on a remote computer? Click me for proposed solution Answer: Yes, you can use the Get-Process cmdlet with the -ComputerName parameter followed by the name of the remote computer to obtain the list of processes running on that computer. Example: Get-Process -ComputerName RemoteComputerName Review the help of the Out-File cmdlet. What is the line size used by this cmdlet by default? Is there a parameter that allows you to change this size? Click me for proposed solution Answer: The line size used by default by the Out-File cmdlet is 80 characters. You can change this size using the -Width parameter followed by the desired width. Example: Get-Process | Out-File -FilePath C :\\ Processes . txt -Width 120 By default, Out-File overwrites the output file if it already exists. Is there a parameter that prevents the overwriting of an existing file? Click me for proposed solution Answer: Yes, the -NoClobber parameter can be used to prevent the overwriting of an existing file. If this parameter is used and the output file already exists, Out-File will not overwrite the file and will instead display an error message. Example: Get-Process | Out-File -FilePath C :\\ Processes . txt -NoClobber","title":"Exercises on Get-Help usage"},{"location":"Exercises/Exercises2/","text":"Create two similar text files (with one or two different lines). Compare them using diff. Click me for proposed solution ##Create 1st file New-Item -Path . -Name \"file1.txt\" -ItemType \"file\" -Value \"Hello World.\\nBonjour Monde!\" -Force ##Create 2nd file New-Item -Path . -Name \"file2.txt\" -ItemType \"file\" -Value \"Hello World!\\nBonjour Monde.\" -Force ##Find the difference between two files diff -ReferenceObject ( cat file1 . txt ) -DifferenceObject ( cat file2 . txt ) InputObject SideIndicator ----------- ------------- Hello World! => Bonjour Monde. => Hello World. <= Bonjour Monde! <= What happens if you run: get-service | export-csv servicios . csv | out-file Why? Click me for proposed solution The output of the above command is: out-file: Cannot process argument because the value of the \"path\" argument is NULL. Change the value of the \"path\" argument to a non-null value. At line:1 char:42 + get-service | export-csv servicios.csv | out-file + ~~~~~~~~ + CategoryInfo : InvalidArgument: (:) [Out-File], PSArgumentNullException + FullyQualifiedErrorId : ArgumentNull,Microsoft.PowerShell.Commands.OutFileCommand This is because export-csv servicios.csv creates the csv file and has null output, therefore out-file is not necessary. How would you create a file delimited by semicolons (;)? HINT: Use export-csv, but with an additional parameter. Click me for proposed solution ps | epcsv -delimiter \";\" example . csv ##Same as Get-Process | Export-Csv -delimiter \";\" example . csv Export-cliXML and Export-CSV modify the system, because they can create and overwrite files. Is there a parameter that prevents overwriting an existing file? Is there a parameter that allows the command to ask before overwriting a file? Click me for proposed solution To prevent overwriting the file if it already exists, the -NoClobber attribute can be used. Example: The following command will not overwrite the result from point 3 ps | epcsv example . csv -NoClobber To ask for confirmation, use the -Confirm parameter. ps | epcsv -delimiter \";\" example . csv -Confirm Windows uses regional settings, which includes the list separator. In English Windows, the list separator is a comma (,). How do you tell Export-CSV to use the system separator instead of the comma? Click me for proposed solution The cmdlet get-culture obtains system configuration information, such as language and writing information. ps | epcsv test2 . csv -Delimiter (( get-culture ). textInfo . listSeparator ) Using cat (alias of Get-Content), we can see that the output uses ';' as the Spanish list separator. cat .\\ test2 . csv Identify a cmdlet that allows generating a random number. Click me for proposed solution The cmdlet get-random returns a pseudo-random 32-bit integer. Identify a cmdlet that displays the current date and time. Click me for proposed solution The cmdlet get-date returns an object that represents the current date and time, which can be represented in various formats such as Windows or UNIX. What type of object does the cmdlet in question 7 produce? Click me for proposed solution Using the cmdlet gm, we can obtain the elements that make up the object and the type. As seen below, the object is part of the System package and its type is DateTime. Get-Date | gm TypeName : System . DateTime Using the cmdlet in question 7 and select-object, display only the day of the week as follows: DayOfWeek --------- Thursday Click me for proposed solution get-date | select -property \"dayofweek\" DayOfWeek --------- Friday Identify a cmdlet that displays information about patches (hotfixes) installed on the system. Click me for proposed solution The cmdlet that returns a list of system patches is: get-hotfix Using the cmdlet from question 10, display a list of installed patches. Then extend the expression to sort the list by installation date, and display on the screen only the installation date, the user who installed the patch, and the patch ID. Remember to examine the property names. Click me for proposed solution The cmdlet that returns a list of system patches is: get-hotfix | sort -property installedon | select -property installedon , installedby , hotfixid Complement the solution to question 11 so that the system sorts the results by the patch description, and includes the description, patch ID, and installation date in the listing. Write the results to an HTML file. Click me for proposed solution The cmdlet that returns a list of system patches is: get-hotFix | sort -property description | select -property hotfixid , description , installedon | convertto-html | Out-File hotfix . html Display a list of the 50 newest entries from the System event log. Sort the list so that the oldest entries appear first, and entries produced at the same time should be sorted by index number. Show the index number, time, and source for each entry. Write this information to a plain text file. Click me for proposed solution The cmdlet that returns a list of system patches is: get-eventlog -newest 50 -logname system | sort -property index | sort -property timegenerated -descending | select -property index , timegenerated , source > exercise13 . txt","title":"Exercise 2"},{"location":"Exercises/Exercises3/","text":"Show a table that includes only the names of the processes, their IDs, and whether they are responding to Windows (the Responding property shows that). Make the table take up a minimum of horizontal space, but don't allow the information to be truncated. Click me for proposed solution ps | ft -Property name , id , responding -Wrap Display a table that includes the names of the processes and their IDs. Also include columns for physical and virtual memory usage; Express those values \u200b\u200bin megabytes (MB). Click me for proposed solution ps | ft -Property name , id , @{ n = 'vm [MB]' ; e ={ $_ . vm / 1MB -as [INT] }}, @{ n = 'pm [MB]' ; e ={ $_ . pm / 1MB -as [INT] }} Use the cmdlet Get-EventLog to display a list of available event logs (check the help to find the parameter that will allow you to get that information). Format the output as a table that includes the log display name and the retention period. Column headers must be LogName and Per-Retention. Click me for proposed solution get-eventlog -list | ft -property @{ n = 'NombreLog' ; e ={ $_ . log }}, @{ n = 'Per-Retencion' ; e ={ $_ . MinimumRetentionDays }} Display a list of services, so that the services that are started and those that are stopped are grouped together. Those who are initiated must appear first. Click me for proposed solution gsv | sort -property status -descending | ft -groupby status Display a four-column list of all directories that are at the root of drive C: Click me for proposed solution ls 'C:/' | format-wide name -col 4 Create a formatted list of all .exe files in the C:\\Windows directory. The name, version information, and size of the file should be displayed. The size property is called length in Powershell, but for clarity, the column should be called Size in your listing. Click me for proposed solution ls 'C:\\Windows/*.exe' | ft name , @{ n = 'Size' ; e ={ $_ . Length }}, versionInfo -Wrap Import the NetAdapter module (using the Import-Module NetAdapter command). Using the Get-NetAdapter cmdlet, display a list of non-virtual adapters (adapters whose Virtual property is false. The boolean false is represented by Powershell as $False). Click me for proposed solution Get-NetAdapter | ? { $_ . Virtual -eq $False } | fl Import the DnsClient module. Using the Get-DnsClientCache cmdlet, list the A and AAAA records that are in the cache. Tip: If the cache is empty, visit some websites to populate it. Click me for proposed solution Get-DnsClientCache -type 'A' , 'AAAA' | fl Display a list of all .exe files in the C:\\Windows\\System32 directory that are larger than 5 MB. Click me for proposed solution ls 'C:\\Windows\\System32/*.exe' | ? { $_ . length -gt 5MB } | fl Display a list of patches that are security updates. Click me for proposed solution Get-HotFix | ? { $_ . description -eq \"Security Update\" } | fl Display a list of patches that have been installed by the Administrator user, which are updates. If you don't have any, look for user-installed patches System. Click me for proposed solution Get-HotFix | ? { $_ . Description -like \"*Update*\" -and $_ . InstalledBy -like \"*System*\" } | fl Generate a list of all running processes with the name Conhost or Svchost. Click me for proposed solution ps | ? { $_ . Name -eq 'conhost' -or $_ . Name -eq 'svchost' } | fl","title":"Exercise 3"},{"location":"Exercises/Exercises4/","text":"Which class can be used to query the IP address of a network adapter? Does that class have a method to release a DHCP address lease? Click me for proposed solution Get-WmiObject -List | where name -like ' * networkadapter * ## Method to release a DHCP address gwmi Win32_NetworkAdapter | gm | ? { $_ . membertype -like \"method\" } gwmi Win32_NetworkAdapterConfiguration | gm | ? { $_ . membertype -like \"method\" } Display a list of patches using WMI (Microsoft refers to patches as quick-fix engineering). Is the listing different from the one produced by the Get-Hotfix cmdlet? Click me for proposed solution gwmi Win32_QuickFixEngineering ## No difference with get-hotfix cmdlet diff -ReferenceObject ( gwmi Win32_QuickFixEngineering ) -DifferenceObject ( Get-Hotfix ) Using WMI, display a list of services, including their current status, their startup mode, and the accounts they use to login. Click me for proposed solution gwmi win32_service | fl status , startmode , startname Using CIM cmdlets, list all classes in the SecurityCenter2 namespace, which have product as part of the name. Click me for proposed solution get-cimclass -names root \\ SecurityCenter2 | ? cimclassname -like '*product*' Using CIM cmdlets, and the results of the previous exercise, display the names of the antispyware applications installed on the system. You can also check if there are antivirus products installed on the system. Click me for proposed solution ## Antivirus get-ciminstance -names root \\ SecurityCenter2 -class AntiVirusProduct ## Antispyware get-ciminstance -names root \\ SecurityCenter2 -class AntiSpywareProduct","title":"Exercise 4"},{"location":"Install/differences/","text":"Powershell 5 and Powershell ISE PowerShell 5 is a major version of the Windows PowerShell command-line shell and scripting language that was released in February 2016. It was designed primarily for Windows operating systems and provides a powerful tool for automating administrative tasks and managing systems. Some of the key features of PowerShell 5 include: Classes and enums for creating custom types Enhanced debugging support, including the ability to step through scripts and inspect variables Improved security with the introduction of Just Enough Administration (JEA) and PowerShell Scriptblock Logging PowerShell ISE (Integrated Scripting Environment) is an integrated development environment (IDE) that is included with PowerShell 5. It provides a graphical user interface (GUI) for developing, testing, and debugging PowerShell scripts and modules. Some of the key features of PowerShell ISE include: A code editor with syntax highlighting, code folding, and IntelliSense A console pane for executing PowerShell commands and scripts Debugging tools, including breakpoints and variable inspection Integration with version control systems like Git and Team Foundation Server PowerShell ISE was designed to make it easier for developers and system administrators to work with PowerShell scripts and modules, but it has been deprecated in favor of the new PowerShell 7 Integrated Console. The PowerShell 7 Integrated Console provides many of the same features as PowerShell ISE, but in a more modern and flexible interface that can be used on Windows, Linux, and macOS. Key Differences between Powershell 7 and 5 Cross-Platform Support One of the biggest differences between PowerShell 7 and 5 is cross-platform support. While PowerShell 5 was primarily designed for Windows operating systems, PowerShell 7 is designed to work on Windows, Linux, and macOS. This means that you can use PowerShell 7 to manage and automate tasks on a wide variety of systems, making it a more versatile tool. Improved Performance PowerShell 7 is also faster and more efficient than PowerShell 5. This is due in part to the fact that PowerShell 7 uses .NET Core 3.x, which provides better performance than the .NET Framework used by PowerShell 5. In addition, PowerShell 7 includes a number of performance optimizations that make it faster and more responsive. New Features PowerShell 7 includes many new features and improvements over PowerShell 5. Some of the most notable new features include: Pipeline Parallelization : PowerShell 7 can execute commands in parallel on multi-core CPUs, improving performance for certain operations. Ternary Operators : PowerShell 7 introduces a new ternary operator (condition ? true : false) that makes it easier to write concise code. New Data Types : PowerShell 7 adds support for new data types like System.Text.Json.JsonDocument, making it easier to work with JSON data. New cmdlets : PowerShell 7 includes many new cmdlets for managing systems and applications, as well as improved versions of existing cmdlets. Compatibility Finally, it's worth noting that PowerShell 7 is not fully backwards-compatible with PowerShell 5. While most scripts and modules written for PowerShell 5 should work fine in PowerShell 7, there may be some compatibility issues with certain scripts or modules. It's always a good idea to test your scripts and modules in PowerShell 7 before deploying them to production systems. PowerShell 7 Integrated Console in VSCode PowerShell 7 Integrated Console is a new feature in PowerShell 7 that provides many of the same features as PowerShell ISE, but in a more modern and flexible interface that can be used on Windows, Linux, and macOS. Here are some of the key differences between the two: Cross-Platform Support One of the biggest differences between PowerShell 7 Integrated Console and PowerShell ISE is cross-platform support. While PowerShell ISE was primarily designed for Windows operating systems, PowerShell 7 Integrated Console is designed to work on Windows, Linux, and macOS. This means that you can use PowerShell 7 Integrated Console to manage and automate tasks on a wide variety of systems, making it a more versatile tool. Improved Performance PowerShell 7 Integrated Console is also faster and more efficient than PowerShell ISE. This is due in part to the fact that PowerShell 7 uses .NET Core 3.x, which provides better performance than the .NET Framework used by PowerShell ISE. In addition, PowerShell 7 Integrated Console includes a number of performance optimizations that make it faster and more responsive. Features PowerShell 7 Integrated Console includes many of the same features as PowerShell ISE, such as a code editor with syntax highlighting, code folding, and IntelliSense, a console pane for executing PowerShell commands and scripts, and debugging tools like breakpoints and variable inspection. However, PowerShell 7 Integrated Console also includes some new features, such as: Interactive Notebooks : PowerShell 7 Integrated Console includes a new feature called Interactive Notebooks, which provides a way to create and share rich documents that combine text, code, and output. This feature is similar to Jupyter Notebooks in the Python world. Multiple Tabs : PowerShell 7 Integrated Console supports multiple tabs, so you can work on multiple scripts or tasks at the same time within the same window. Improved UI : PowerShell 7 Integrated Console has a modern and flexible user interface that can be customized to suit your needs. Deprecation Finally, it's worth noting that PowerShell ISE has been deprecated in favor of PowerShell 7 Integrated Console. Microsoft has stated that PowerShell ISE will not receive any new features or updates, and it will be removed in future versions of Windows. While PowerShell ISE will still be available in older versions of Windows that include PowerShell 5, it's recommended that you switch to PowerShell 7 Integrated Console for new development and management tasks. Additional Features of VSCode Powershell Extension The PowerShell extension for VSCode includes a number of additional features that aren't available in PowerShell 7 Integrated Console, such as: Code Snippets : The extension provides a library of code snippets that you can use to quickly insert common PowerShell commands and structures into your code. Task Runner : You can use the extension's Task Runner to automate repetitive tasks like running tests, building modules, or deploying scripts. Integrated Source Control : The extension includes support for integrated source control, so you can use Git or another version control system directly from within the VSCode editor. Overall, the PowerShell extension for VSCode provide powerful tools for working with PowerShell scripts and modules.","title":"Versions"},{"location":"Install/differences/#powershell-5-and-powershell-ise","text":"PowerShell 5 is a major version of the Windows PowerShell command-line shell and scripting language that was released in February 2016. It was designed primarily for Windows operating systems and provides a powerful tool for automating administrative tasks and managing systems. Some of the key features of PowerShell 5 include: Classes and enums for creating custom types Enhanced debugging support, including the ability to step through scripts and inspect variables Improved security with the introduction of Just Enough Administration (JEA) and PowerShell Scriptblock Logging PowerShell ISE (Integrated Scripting Environment) is an integrated development environment (IDE) that is included with PowerShell 5. It provides a graphical user interface (GUI) for developing, testing, and debugging PowerShell scripts and modules. Some of the key features of PowerShell ISE include: A code editor with syntax highlighting, code folding, and IntelliSense A console pane for executing PowerShell commands and scripts Debugging tools, including breakpoints and variable inspection Integration with version control systems like Git and Team Foundation Server PowerShell ISE was designed to make it easier for developers and system administrators to work with PowerShell scripts and modules, but it has been deprecated in favor of the new PowerShell 7 Integrated Console. The PowerShell 7 Integrated Console provides many of the same features as PowerShell ISE, but in a more modern and flexible interface that can be used on Windows, Linux, and macOS.","title":"Powershell 5 and Powershell ISE"},{"location":"Install/differences/#key-differences-between-powershell-7-and-5","text":"","title":"Key Differences between Powershell 7 and 5"},{"location":"Install/differences/#cross-platform-support","text":"One of the biggest differences between PowerShell 7 and 5 is cross-platform support. While PowerShell 5 was primarily designed for Windows operating systems, PowerShell 7 is designed to work on Windows, Linux, and macOS. This means that you can use PowerShell 7 to manage and automate tasks on a wide variety of systems, making it a more versatile tool.","title":"Cross-Platform Support"},{"location":"Install/differences/#improved-performance","text":"PowerShell 7 is also faster and more efficient than PowerShell 5. This is due in part to the fact that PowerShell 7 uses .NET Core 3.x, which provides better performance than the .NET Framework used by PowerShell 5. In addition, PowerShell 7 includes a number of performance optimizations that make it faster and more responsive.","title":"Improved Performance"},{"location":"Install/differences/#new-features","text":"PowerShell 7 includes many new features and improvements over PowerShell 5. Some of the most notable new features include: Pipeline Parallelization : PowerShell 7 can execute commands in parallel on multi-core CPUs, improving performance for certain operations. Ternary Operators : PowerShell 7 introduces a new ternary operator (condition ? true : false) that makes it easier to write concise code. New Data Types : PowerShell 7 adds support for new data types like System.Text.Json.JsonDocument, making it easier to work with JSON data. New cmdlets : PowerShell 7 includes many new cmdlets for managing systems and applications, as well as improved versions of existing cmdlets.","title":"New Features"},{"location":"Install/differences/#compatibility","text":"Finally, it's worth noting that PowerShell 7 is not fully backwards-compatible with PowerShell 5. While most scripts and modules written for PowerShell 5 should work fine in PowerShell 7, there may be some compatibility issues with certain scripts or modules. It's always a good idea to test your scripts and modules in PowerShell 7 before deploying them to production systems.","title":"Compatibility"},{"location":"Install/differences/#powershell-7-integrated-console-in-vscode","text":"PowerShell 7 Integrated Console is a new feature in PowerShell 7 that provides many of the same features as PowerShell ISE, but in a more modern and flexible interface that can be used on Windows, Linux, and macOS. Here are some of the key differences between the two:","title":"PowerShell 7 Integrated Console in VSCode"},{"location":"Install/differences/#cross-platform-support_1","text":"One of the biggest differences between PowerShell 7 Integrated Console and PowerShell ISE is cross-platform support. While PowerShell ISE was primarily designed for Windows operating systems, PowerShell 7 Integrated Console is designed to work on Windows, Linux, and macOS. This means that you can use PowerShell 7 Integrated Console to manage and automate tasks on a wide variety of systems, making it a more versatile tool.","title":"Cross-Platform Support"},{"location":"Install/differences/#improved-performance_1","text":"PowerShell 7 Integrated Console is also faster and more efficient than PowerShell ISE. This is due in part to the fact that PowerShell 7 uses .NET Core 3.x, which provides better performance than the .NET Framework used by PowerShell ISE. In addition, PowerShell 7 Integrated Console includes a number of performance optimizations that make it faster and more responsive.","title":"Improved Performance"},{"location":"Install/differences/#features","text":"PowerShell 7 Integrated Console includes many of the same features as PowerShell ISE, such as a code editor with syntax highlighting, code folding, and IntelliSense, a console pane for executing PowerShell commands and scripts, and debugging tools like breakpoints and variable inspection. However, PowerShell 7 Integrated Console also includes some new features, such as: Interactive Notebooks : PowerShell 7 Integrated Console includes a new feature called Interactive Notebooks, which provides a way to create and share rich documents that combine text, code, and output. This feature is similar to Jupyter Notebooks in the Python world. Multiple Tabs : PowerShell 7 Integrated Console supports multiple tabs, so you can work on multiple scripts or tasks at the same time within the same window. Improved UI : PowerShell 7 Integrated Console has a modern and flexible user interface that can be customized to suit your needs.","title":"Features"},{"location":"Install/differences/#deprecation","text":"Finally, it's worth noting that PowerShell ISE has been deprecated in favor of PowerShell 7 Integrated Console. Microsoft has stated that PowerShell ISE will not receive any new features or updates, and it will be removed in future versions of Windows. While PowerShell ISE will still be available in older versions of Windows that include PowerShell 5, it's recommended that you switch to PowerShell 7 Integrated Console for new development and management tasks.","title":"Deprecation"},{"location":"Install/differences/#additional-features-of-vscode-powershell-extension","text":"The PowerShell extension for VSCode includes a number of additional features that aren't available in PowerShell 7 Integrated Console, such as: Code Snippets : The extension provides a library of code snippets that you can use to quickly insert common PowerShell commands and structures into your code. Task Runner : You can use the extension's Task Runner to automate repetitive tasks like running tests, building modules, or deploying scripts. Integrated Source Control : The extension includes support for integrated source control, so you can use Git or another version control system directly from within the VSCode editor. Overall, the PowerShell extension for VSCode provide powerful tools for working with PowerShell scripts and modules.","title":"Additional Features of VSCode Powershell Extension"},{"location":"Install/installation/","text":"PowerShell 7 is the latest major release of PowerShell, and it provides many new features and improvements over previous versions. Here's how to install it on various operating systems: Windows On Windows, you can download the PowerShell 7 installer from the official PowerShell GitHub repository. Choose the MSI installer for your architecture (either x86 or x64) and download the file. Once the installer is downloaded, double-click on the file to start the installation wizard. Follow the on-screen instructions to complete the installation process. After installation is complete, you can open PowerShell 7 from the Start menu or by typing pwsh in the command prompt. Linux On Linux, you can install PowerShell 7 using your distribution's package manager. Here are the commands for some popular distributions: Ubuntu 18.04 and later, and Debian 10 and later: Run the following commands in the terminal: # Update the list of packages sudo apt - get update # Install pre - requisite packages . sudo apt - get install - y wget apt - transport - https software - properties - common # Download the Microsoft repository GPG keys wget - q \"https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb\" # Register the Microsoft repository GPG keys sudo dpkg - i packages - microsoft - prod . deb # Update the list of packages after we added packages . microsoft . com sudo apt - get update # Install PowerShell sudo apt - get install - y powershell # Start PowerShell pwsh macOS On macOS, you can install PowerShell 7 using Homebrew, a popular package manager for macOS. Run the following command in the terminal: brew install -- cask powershell After installation is complete, you can open PowerShell 7 from the Launchpad or by typing pwsh in the terminal.","title":"Multiplatform"},{"location":"Install/installation/#windows","text":"On Windows, you can download the PowerShell 7 installer from the official PowerShell GitHub repository. Choose the MSI installer for your architecture (either x86 or x64) and download the file. Once the installer is downloaded, double-click on the file to start the installation wizard. Follow the on-screen instructions to complete the installation process. After installation is complete, you can open PowerShell 7 from the Start menu or by typing pwsh in the command prompt.","title":"Windows"},{"location":"Install/installation/#linux","text":"On Linux, you can install PowerShell 7 using your distribution's package manager. Here are the commands for some popular distributions: Ubuntu 18.04 and later, and Debian 10 and later: Run the following commands in the terminal: # Update the list of packages sudo apt - get update # Install pre - requisite packages . sudo apt - get install - y wget apt - transport - https software - properties - common # Download the Microsoft repository GPG keys wget - q \"https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb\" # Register the Microsoft repository GPG keys sudo dpkg - i packages - microsoft - prod . deb # Update the list of packages after we added packages . microsoft . com sudo apt - get update # Install PowerShell sudo apt - get install - y powershell # Start PowerShell pwsh","title":"Linux"},{"location":"Install/installation/#macos","text":"On macOS, you can install PowerShell 7 using Homebrew, a popular package manager for macOS. Run the following command in the terminal: brew install -- cask powershell After installation is complete, you can open PowerShell 7 from the Launchpad or by typing pwsh in the terminal.","title":"macOS"},{"location":"Install/recommendations/","text":"When it comes to setting up your environment for programming in PowerShell, there are a few key tools and configurations that can help make your workflow more efficient and effective. Here are some recommendations for the best setup for programming in PowerShell: 1. Install PowerShell 7 PowerShell 7 is the latest version of PowerShell and includes many new features and improvements over previous versions. It's recommended that you install PowerShell 7 to take advantage of these new features and to ensure compatibility with the latest PowerShell modules and scripts. 2. Install an IDE Using a dedicated Text Editor or Integrated Development Environment IDE can help make your workflow more efficient and productive. Popular options for PowerShell development include Visual Studio Code, PowerShell ISE, and the PowerShell extension for Visual Studio. 3. Install the PowerShell Extension for Your IDE If you're using a text editor or IDE, it's recommended that you install the PowerShell extension for that editor or IDE. This extension provides additional tools and features for working with PowerShell scripts and modules, such as syntax highlighting, IntelliSense, debugging, and code formatting. 4. Install PowerShell Modules PowerShell modules are collections of PowerShell commands and scripts that you can use to extend the functionality of PowerShell. Many modules are available through the PowerShell Gallery, which is a repository of PowerShell modules that you can download and install using the Install-Module command. 5. Configure Your Profile PowerShell allows you to configure your profile to set up your environment with your preferred settings and modules every time you start a new session. You can use your profile to set environment variables, define aliases, and load modules automatically. Your profile is stored in a PowerShell script file named $PROFILE, which you can edit using a text editor or IDE. By following these recommendations, you can set up a powerful and efficient environment for programming in PowerShell. Whether you're a beginner or an experienced developer, having the right tools and configurations can help you write better PowerShell code and automate your tasks more effectively.","title":"Recommendations"},{"location":"Install/recommendations/#1-install-powershell-7","text":"PowerShell 7 is the latest version of PowerShell and includes many new features and improvements over previous versions. It's recommended that you install PowerShell 7 to take advantage of these new features and to ensure compatibility with the latest PowerShell modules and scripts.","title":"1. Install PowerShell 7"},{"location":"Install/recommendations/#2-install-an-ide","text":"Using a dedicated Text Editor or Integrated Development Environment IDE can help make your workflow more efficient and productive. Popular options for PowerShell development include Visual Studio Code, PowerShell ISE, and the PowerShell extension for Visual Studio.","title":"2. Install an IDE"},{"location":"Install/recommendations/#3-install-the-powershell-extension-for-your-ide","text":"If you're using a text editor or IDE, it's recommended that you install the PowerShell extension for that editor or IDE. This extension provides additional tools and features for working with PowerShell scripts and modules, such as syntax highlighting, IntelliSense, debugging, and code formatting.","title":"3. Install the PowerShell Extension for Your IDE"},{"location":"Install/recommendations/#4-install-powershell-modules","text":"PowerShell modules are collections of PowerShell commands and scripts that you can use to extend the functionality of PowerShell. Many modules are available through the PowerShell Gallery, which is a repository of PowerShell modules that you can download and install using the Install-Module command.","title":"4. Install PowerShell Modules"},{"location":"Install/recommendations/#5-configure-your-profile","text":"PowerShell allows you to configure your profile to set up your environment with your preferred settings and modules every time you start a new session. You can use your profile to set environment variables, define aliases, and load modules automatically. Your profile is stored in a PowerShell script file named $PROFILE, which you can edit using a text editor or IDE. By following these recommendations, you can set up a powerful and efficient environment for programming in PowerShell. Whether you're a beginner or an experienced developer, having the right tools and configurations can help you write better PowerShell code and automate your tasks more effectively.","title":"5. Configure Your Profile"},{"location":"Scripting/ConsoleIO/","text":"Requesting Info The Read-Host cmdlet displays a request message, and then reads a response from the user. For example: Read-Host \"Enter a computer name\" Enter a computer name: SERVER SERVER The cmdlet adds a colon (:) after the request message, and places the user's response in the pipeline. In most cases, the user's response is captured in a variable, as in the following example: $computer = Read-Host \"Enter a computer name\" Enter a computer name : SERVER Writing Info To write data to the console: Write-Host: Allows you to write data directly to the console, skipping the pipeline. For this reason, its output cannot be captured or redirected to logs. It is recommended not to use it. Write-Output: Allows data to be written to the pipeline. If there is no redirection to another command, the data will be output to the screen. This is the recommended way to print data to the console. Other ways: Powershell has other cmdlets to produce console output. None of them use the pipeline (they function as Write-Host), but their output can be suppressed at will, through the use of environment variables. The commands are the following: Command Description Write-Warning Prints the message in orange, preceded by the word WARNING. Its printing depends on the value of the $WarningPerference variable, which defaults to Continue. Write-Verbose Prints the message in blue, preceded by the word VERBOSE. Its printing depends on the value of the $VerbosePreference variable, which is set to SilentlyContinue by default. Write-Debug Prints the message in blue, preceded by the word DEBUG. Its printing depends on the value of the $DebugPreference variable, which defaults to SilentlyContinue. Write-error Generates an error message. Its printing depends on the value of the $ErrorActionPreference variable, which defaults to Continue. If the variable corresponding to the command has the value Continue, the message is printed. If the value is SilentlyContinue, the printing of the message is suppressed.","title":"Console IO"},{"location":"Scripting/ConsoleIO/#requesting-info","text":"The Read-Host cmdlet displays a request message, and then reads a response from the user. For example: Read-Host \"Enter a computer name\" Enter a computer name: SERVER SERVER The cmdlet adds a colon (:) after the request message, and places the user's response in the pipeline. In most cases, the user's response is captured in a variable, as in the following example: $computer = Read-Host \"Enter a computer name\" Enter a computer name : SERVER","title":"Requesting Info"},{"location":"Scripting/ConsoleIO/#writing-info","text":"To write data to the console: Write-Host: Allows you to write data directly to the console, skipping the pipeline. For this reason, its output cannot be captured or redirected to logs. It is recommended not to use it. Write-Output: Allows data to be written to the pipeline. If there is no redirection to another command, the data will be output to the screen. This is the recommended way to print data to the console. Other ways: Powershell has other cmdlets to produce console output. None of them use the pipeline (they function as Write-Host), but their output can be suppressed at will, through the use of environment variables. The commands are the following: Command Description Write-Warning Prints the message in orange, preceded by the word WARNING. Its printing depends on the value of the $WarningPerference variable, which defaults to Continue. Write-Verbose Prints the message in blue, preceded by the word VERBOSE. Its printing depends on the value of the $VerbosePreference variable, which is set to SilentlyContinue by default. Write-Debug Prints the message in blue, preceded by the word DEBUG. Its printing depends on the value of the $DebugPreference variable, which defaults to SilentlyContinue. Write-error Generates an error message. Its printing depends on the value of the $ErrorActionPreference variable, which defaults to Continue. If the variable corresponding to the command has the value Continue, the message is printed. If the value is SilentlyContinue, the printing of the message is suppressed.","title":"Writing Info"},{"location":"Scripting/ErrorHandling/","text":"Try/Catch/Finally Try { # Do something with a file. } Catch [System.IO.IOException] { Write-Host \"Something went wrong\" } Catch { # Catch all. It's not an IOException but something else. } Finally { # Clean up resources. } Inspecting errors An exception object contains: A message. The message tells you in a few words what went wrong. The stacktrace. The stacktrace tells you which statements ran before the error. Imagine you have a call to function A, followed by B, followed by C. The script stops responding at C. The stacktrace will show that chain of calls. The offending row. The exception object also tells you which row the script was running when the error occurred. This information can help you debug your code. So how do you inspect an exception object? There's a built-in variable, $ , that has an exception property. To get the error message, for example, you would use $ .exception.message. Try { # Do something with a file. } Catch [System.IO.IOException] { Write-Host \"Something IO went wrong: $( $_ . exception . message ) \" } Catch { Write-Host \"Something else went wrong: $( $_ . exception . message ) \" } Raising errors In some situations, you might want to cause an error: Non-terminating errors. For this type of error, PowerShell just notifies you that something went wrong, by using the Write-Error cmdlet, for example. The script continues to run. That might not be the behavior you want. To raise the severity of the error, you can use a parameter like -ErrorAction to cause an error that can be caught with Try/Catch, like so: Try { Get-Content './file.txt' -ErrorAction Stop } Catch { Write-Error \"File can't be found\" } By using the -ErrorAction parameter and the value Stop, you can cause an error that Try/Catch can catch. Business rules. You might have a situation where the code doesn't actually stop responding, but you want it to for business reasons. Imagine you're sanitizing input and you check whether a parameter is a path. A business requirement might specify only certain paths are allowed, or the path needs to look a certain way. If the checks fail, it makes sense to throw an error. In a situation like this, you can use a Throw block: Try { If ( $Path -eq './forbidden' ) { Throw \"Path not allowed\" } # Carry on. } Catch { Write-Error \" $( $_ . exception . message ) \" # Path not allowed. } In general, don't use Throw for parameter validation. Use validation attributes instead. If you can't make your code work with these attributes, a Throw might be OK.","title":"Handling Errors"},{"location":"Scripting/ErrorHandling/#trycatchfinally","text":"Try { # Do something with a file. } Catch [System.IO.IOException] { Write-Host \"Something went wrong\" } Catch { # Catch all. It's not an IOException but something else. } Finally { # Clean up resources. }","title":"Try/Catch/Finally"},{"location":"Scripting/ErrorHandling/#inspecting-errors","text":"An exception object contains: A message. The message tells you in a few words what went wrong. The stacktrace. The stacktrace tells you which statements ran before the error. Imagine you have a call to function A, followed by B, followed by C. The script stops responding at C. The stacktrace will show that chain of calls. The offending row. The exception object also tells you which row the script was running when the error occurred. This information can help you debug your code. So how do you inspect an exception object? There's a built-in variable, $ , that has an exception property. To get the error message, for example, you would use $ .exception.message. Try { # Do something with a file. } Catch [System.IO.IOException] { Write-Host \"Something IO went wrong: $( $_ . exception . message ) \" } Catch { Write-Host \"Something else went wrong: $( $_ . exception . message ) \" }","title":"Inspecting errors"},{"location":"Scripting/ErrorHandling/#raising-errors","text":"In some situations, you might want to cause an error: Non-terminating errors. For this type of error, PowerShell just notifies you that something went wrong, by using the Write-Error cmdlet, for example. The script continues to run. That might not be the behavior you want. To raise the severity of the error, you can use a parameter like -ErrorAction to cause an error that can be caught with Try/Catch, like so: Try { Get-Content './file.txt' -ErrorAction Stop } Catch { Write-Error \"File can't be found\" } By using the -ErrorAction parameter and the value Stop, you can cause an error that Try/Catch can catch. Business rules. You might have a situation where the code doesn't actually stop responding, but you want it to for business reasons. Imagine you're sanitizing input and you check whether a parameter is a path. A business requirement might specify only certain paths are allowed, or the path needs to look a certain way. If the checks fail, it makes sense to throw an error. In a situation like this, you can use a Throw block: Try { If ( $Path -eq './forbidden' ) { Throw \"Path not allowed\" } # Carry on. } Catch { Write-Error \" $( $_ . exception . message ) \" # Path not allowed. } In general, don't use Throw for parameter validation. Use validation attributes instead. If you can't make your code work with these attributes, a Throw might be OK.","title":"Raising errors"},{"location":"Scripting/advanced/","text":"Adding the line [CmdletBinding()] after the help comments makes the script advanced, which allows you to return required parameters, set their data type, add aliases for parameters, etc. The final version of the example script is as follows: <# .SYNOPSIS Get-DiskInventory gets logical disk information for one or more computers. .DESCRIPTION Get-DiskInventory uses CIM to query the instances Win32_LogicalDisk from one or more computers. Display for each disk the drive letter, free space, total space, and percentage of free space. .PARAMETER DriveType The type of unit to query. View the Win32_LogicalDisk documentation for more information. 3 indicates a fixed disk, and is the default. .EXAMPLE Get-DiskInventory -DriveType 3 #> [ CmdletBinding ()] param ( [ Parameter ( Mandatory = $True )] [ Alias ( 'Type' )] [ ValidateSet ( 2 , 3 )] [int] $DriveType = 3 ) Get-CimInstance Win32_logicaldisk ` -filter \"drivetype=$DriveType\" | Sort-Object -Property DeviceID | Select-Object -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} The changes from the previous example are as follows: The directive to return the script advanced is included The parameter is now required, and the alias Type is created for it. The parameter is declared as an integer, and the only valid values \u200b\u200bit receives are 2 and 3.","title":"Advanced Script"},{"location":"Scripting/basic/","text":"Powershell scripts allow you to store a command or series of commands, for easier execution later. To produce a script, it is enough to record the required commands in a text file with the extension .ps1 . For example, consider the following command, which prints a list of fixed disks attached to the system, along with their free space, total size, and free space percentage: Get-CimInstance Win32_logicaldisk ` -filter \"drivetype=3\" | Sort-Object -Property DeviceID | format-table -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} At the end of the first line the backtick ` is used to indicate that the command has not finished yet. In the rest of the lines, this job is done by vertical bars and commas. This way it is easier to read. By copying these lines of code and saving them to a text file called Get-DiskInventory.ps1, a script will be created. Parameterization Scripts can be parameterized, that is, parameters can be created that can be specified at the time the script is executed. For example, in the script of the previous example it is possible to return parameters the name of the computer and the type of unit. The parameterized script would look like this: param ( $DriveType = 3 ) Get-CimInstance Win32_logicaldisk ` -filter \"drivetype=$DriveType\" | Sort-Object -Property DeviceID | format-table -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} Optionally, each parameter can be specified with a default value, as seen in the example above. Run the script The script can be executed by typing its name in the console. If the script is saved in a different directory than the current one, the full path to the file must be written to execute it. In case the script does not execute, it is necessary to change the script execution policy to a more permissive value, using the Set-ExecutionPolicy cmdlet as administrator. See the cmdlet help for more details. An execution policy is a safety feature. Like requiring the path of a script, a policy can stop you from doing unintentional things. You can set the policy on various levels, like the local computer, current user, or particular session. You can also use a Group Policy setting to set execution policies for computers and users. . ./ Get-DiskInventory . ps1 Be sure to include the dot (.) at the beginning of the command. This tells PowerShell to run the script or file that's being called.","title":"Basic Scripting"},{"location":"Scripting/basic/#parameterization","text":"Scripts can be parameterized, that is, parameters can be created that can be specified at the time the script is executed. For example, in the script of the previous example it is possible to return parameters the name of the computer and the type of unit. The parameterized script would look like this: param ( $DriveType = 3 ) Get-CimInstance Win32_logicaldisk ` -filter \"drivetype=$DriveType\" | Sort-Object -Property DeviceID | format-table -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} Optionally, each parameter can be specified with a default value, as seen in the example above.","title":"Parameterization"},{"location":"Scripting/basic/#run-the-script","text":"The script can be executed by typing its name in the console. If the script is saved in a different directory than the current one, the full path to the file must be written to execute it. In case the script does not execute, it is necessary to change the script execution policy to a more permissive value, using the Set-ExecutionPolicy cmdlet as administrator. See the cmdlet help for more details. An execution policy is a safety feature. Like requiring the path of a script, a policy can stop you from doing unintentional things. You can set the policy on various levels, like the local computer, current user, or particular session. You can also use a Group Policy setting to set execution policies for computers and users. . ./ Get-DiskInventory . ps1 Be sure to include the dot (.) at the beginning of the command. This tells PowerShell to run the script or file that's being called.","title":"Run the script"},{"location":"Scripting/comments/","text":"Scripts can be documented in such a way that they provide help similar to that provided by Powershell. The documented script would look like this: <# .SYNOPSIS Get-DiskInventory gets logical disk information for one or more computers. .DESCRIPTION Get-DiskInventory uses CIM to query the instances Win32_LogicalDisk from one or more computers. Display for each disk the drive letter, free space, total space, and percentage of free space. .PARAMETER DriveType The type of unit to query. View the Win32_LogicalDisk documentation for more information. 3 indicates a fixed disk, and is the default. .EXAMPLE Get-DiskInventory -DriveType 3 #> param ( $DriveType = 3 ) Get-CimInstance -Class Win32_logicaldisk ` -filter \"drivetype=$DriveType\" | Sort-Object -Property DeviceID | Select-Object -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} Comments can be specified with a # symbol before each comment line, or with the notation <# #> if there are several consecutive lines of comments. A slight change was also made to the script: instead of using the Format-Table cmdlet, Select-Object is used, so as not to produce a formatted table as output. Using Select-Object the final output of the script is an object, so the end user can chain the script with other commands using the pipeline.","title":"Script Documentation"},{"location":"Scripting/cond/","text":"Flow control refers to how your code runs in your console or script. If, ElseIf, and Else You can use an If construct to determine if an expression is True or False. $True indicates that an expression is True. $False indicates that an expression is False. # _FullyTax.ps1_ # Possible values: 'Minor', 'Adult', 'Senior Citizen' $Status = 'Minor' If ( $Status -eq 'Minor' ) { Write-Host $False } ElseIf ( $Status -eq 'Adult' ) { Write-Host $True } Else { Write-Host $False }","title":"Conditionals"},{"location":"Scripting/cond/#if-elseif-and-else","text":"You can use an If construct to determine if an expression is True or False. $True indicates that an expression is True. $False indicates that an expression is False. # _FullyTax.ps1_ # Possible values: 'Minor', 'Adult', 'Senior Citizen' $Status = 'Minor' If ( $Status -eq 'Minor' ) { Write-Host $False } ElseIf ( $Status -eq 'Adult' ) { Write-Host $True } Else { Write-Host $False }","title":"If, ElseIf, and Else"},{"location":"Scripting/loops/","text":"PowerShell has several loop structures, including For, Do...While, and For...Each. For For ( $i = 1 ; $i -lt 3 ; $i ++) { $i }","title":"Loops"},{"location":"Scripting/loops/#for","text":"For ( $i = 1 ; $i -lt 3 ; $i ++) { $i }","title":"For"},{"location":"Scripting/variables/","text":"Powershell allows you to store values \u200b\u200bin variables. All variable names begin with the $ sign, and are made up of letters, numbers, and the underscore (_). The assignment operator is the equal sign (=). Some examples: Command Description $server = \"localhost\" The variable will contain a text string $number = 5 The variable will contain an integer $services = Get-Service The variable will contain a list of services If you want to query the type of data a variable contains, you can do so with the Get-Member cmdlet. Get-Member also displays the variable's properties and methods. For example, variables of the System.String type have the ToUpper() method, which converts the content of the variable to uppercase. $server . ToUpper () LOCALHOST Variables can be used to replace any parameter in a cmdlet call. You can store all types of values in PowerShell variables. For example, store the results of commands, and store elements that are used in commands and expressions, such as names, paths, settings, and values. To get a list of all the variables in your PowerShell session, type Get-Variable. The variable names are displayed without the preceding dollar ($) sign that is used to reference variables. Variables in Powershell There are several different types of variables in PowerShell. User-created variables : User-created variables are created and maintained by the user. By default, the variables that you create at the PowerShell command line exist only while the PowerShell window is open. When the PowerShell windows is closed, the variables are deleted. To save a variable, add it to your PowerShell profile. You can also create variables in scripts with global, script, or local scope. Automatic variables : Automatic variables store the state of PowerShell. These variables are created by PowerShell, and PowerShell changes their values as required to maintain their accuracy. Users can't change the value of these variables. For example, the $PSHOME variable stores the path to the PowerShell installation directory.For more information, a list, and a description of the automatic variables, see about_Automatic_Variables . Preference variables : Preference variables store user preferences for PowerShell. These variables are created by PowerShell and are populated with default values. Users can change the values of these variables. For example, the $MaximumHistoryCount variable determines the maximum number of entries in the session history. For more information, a list, and a description of the preference variables, see about_Preference_Variables . Working With Variables To create a new variable, use an assignment statement to assign a value to the variable. You don't have to declare the variable before using it. The default value of all variables is $null $MyVariable = 1 , 2 , 3 $Path = \"C:\\Windows\\System32\" Variables are useful for storing the results of commands. For example: $Processes = Get-Process $Today = ( Get-Date ). DateTime To change the value of a variable, assign a new value to the variable. The Variable Cmdlets Cmdlet Name Description Clear-Variable Deletes the value of a variable. Get-Variable Gets the variables in the current console. New-Variable Creates a new variable. Remove-Variable Deletes a variable and its value. Set-Variable Changes the value of a variable. Variable Types You can store any type of object in a variable, including integers, strings, arrays, and hash tables. And, objects that represent processes, services, event logs, and computers. PowerShell variables are loosely typed, which means that they aren't limited to a particular type of object. A single variable can even contain a collection, or array, of different types of objects at the same time. The data type of a variable is determined by the .NET types of the values of the variable. To view a variable's object type, use Get-Member. $a = 12 # System.Int32 $a = \"Word\" # System.String $a = 12 , \"Word\" # array of System.Int32, System.String $a = Get-ChildItem C :\\ Windows # FileInfo and DirectoryInfo types Casting To use cast notation, enter a type name, enclosed in brackets, before the variable name (on the left side of the assignment statement). The following example creates a $number variable that can contain only integers, a $words variable that can contain only strings, and a $dates variable that can contain only DateTime objects. [int] $number = 8 $number = \"12345\" # The string is converted to an integer. $number = \"Hello\" #Casting Error Casting is useful when asking user input: # If no casting the number will be concatenated instead of multiplied PS > [int] $num = read-host \"Enter any number:\" Enter any number : 1024 PS > $num = $num * 10 PS > $num 10240 Using Variables in Commands and Expressions To use a variable in a command or expression, type the variable name, preceded by the dollar ($) sign. If the variable name and dollar sign aren't enclosed in quotation marks, or if they're enclosed in double quotation (\") marks, the value of the variable is used in the command or expression. If the variable name and dollar sign are enclosed in single quotation (') marks, the variable name is used in the expression. For more information about using quotation marks in PowerShell, see about_Quoting_Rules . Single quotes are used to assign to a variable the exact text that is placed between them, for example: PS > $var = 'Hello' PS > $var = 'The content of the variable is $var' PS > $var The content of the variable is $var The single quotes prevent the $ sign from being interpreted as the start of a variable name. To get Powershell to interpret the $ sign as the start of a variable name, the assignment is done with double quotes: PS > $var = 'Hello' PS > $var = \"Variable contains $var\" PS > $var Variable contains Hello The backtick ` causes Powershell to ignore the meaning of the following special character, for example: PS > $var = 'Hello' PS > $var = \"Variable `$ var contains $var\" PS > $var The variable $var contains Hello It can also be used to give special meaning to certain characters (equivalent to \\ in C and Java, for example \\n, \\t...). An example of use is the following: PS > $computername = 'localhost' PS > $phrase = \" `$ computername `n contains `n $computername\" PS > $phrase $computername contains localhost As you can see, `n stands for the carriage return character. To create or display a variable name that includes spaces or special characters, enclose the variable name with the curly braces ({}) characters. The curly braces direct PowerShell to interpret the variable name's characters as literals. ${ save-items } = \"a\" , \"b\" , \"c\" ${ save-items } To reference a variable name that includes braces, enclose the variable name in braces, and use the backtick character to escape the braces. For example, to create a variable named this{value}is type: ${ this `{ value `} is } = \"This variable name uses braces and backticks.\" ${ this `{ value `} is } List Variables It is possible to create a list type variable, separating the values \u200b\u200bof the list with commas: PS > $computers = 'server' , 'localhost' , 'server_2' PS > $computers server localhost server_2 List elements can be accessed by index number. Lists are numbered from zero: PS > $computers [ 0 ] server PS > $computers . count 3 Starting with Powershell version 3, if you pass a list as a parameter to a cmdlet, Powershell iterates over the items in the list. It is also possible to iterate over a list using the Foreach-Object cmdlet. These two commands do the same thing: $computers = $computers . tolower () $computers = $computers | ForEach -Object { $_ . tolower ()}","title":"Variables"},{"location":"Scripting/variables/#variables-in-powershell","text":"There are several different types of variables in PowerShell. User-created variables : User-created variables are created and maintained by the user. By default, the variables that you create at the PowerShell command line exist only while the PowerShell window is open. When the PowerShell windows is closed, the variables are deleted. To save a variable, add it to your PowerShell profile. You can also create variables in scripts with global, script, or local scope. Automatic variables : Automatic variables store the state of PowerShell. These variables are created by PowerShell, and PowerShell changes their values as required to maintain their accuracy. Users can't change the value of these variables. For example, the $PSHOME variable stores the path to the PowerShell installation directory.For more information, a list, and a description of the automatic variables, see about_Automatic_Variables . Preference variables : Preference variables store user preferences for PowerShell. These variables are created by PowerShell and are populated with default values. Users can change the values of these variables. For example, the $MaximumHistoryCount variable determines the maximum number of entries in the session history. For more information, a list, and a description of the preference variables, see about_Preference_Variables .","title":"Variables in Powershell"},{"location":"Scripting/variables/#working-with-variables","text":"To create a new variable, use an assignment statement to assign a value to the variable. You don't have to declare the variable before using it. The default value of all variables is $null $MyVariable = 1 , 2 , 3 $Path = \"C:\\Windows\\System32\" Variables are useful for storing the results of commands. For example: $Processes = Get-Process $Today = ( Get-Date ). DateTime To change the value of a variable, assign a new value to the variable.","title":"Working With Variables"},{"location":"Scripting/variables/#the-variable-cmdlets","text":"Cmdlet Name Description Clear-Variable Deletes the value of a variable. Get-Variable Gets the variables in the current console. New-Variable Creates a new variable. Remove-Variable Deletes a variable and its value. Set-Variable Changes the value of a variable.","title":"The Variable Cmdlets"},{"location":"Scripting/variables/#variable-types","text":"You can store any type of object in a variable, including integers, strings, arrays, and hash tables. And, objects that represent processes, services, event logs, and computers. PowerShell variables are loosely typed, which means that they aren't limited to a particular type of object. A single variable can even contain a collection, or array, of different types of objects at the same time. The data type of a variable is determined by the .NET types of the values of the variable. To view a variable's object type, use Get-Member. $a = 12 # System.Int32 $a = \"Word\" # System.String $a = 12 , \"Word\" # array of System.Int32, System.String $a = Get-ChildItem C :\\ Windows # FileInfo and DirectoryInfo types","title":"Variable Types"},{"location":"Scripting/variables/#casting","text":"To use cast notation, enter a type name, enclosed in brackets, before the variable name (on the left side of the assignment statement). The following example creates a $number variable that can contain only integers, a $words variable that can contain only strings, and a $dates variable that can contain only DateTime objects. [int] $number = 8 $number = \"12345\" # The string is converted to an integer. $number = \"Hello\" #Casting Error Casting is useful when asking user input: # If no casting the number will be concatenated instead of multiplied PS > [int] $num = read-host \"Enter any number:\" Enter any number : 1024 PS > $num = $num * 10 PS > $num 10240","title":"Casting"},{"location":"Scripting/variables/#using-variables-in-commands-and-expressions","text":"To use a variable in a command or expression, type the variable name, preceded by the dollar ($) sign. If the variable name and dollar sign aren't enclosed in quotation marks, or if they're enclosed in double quotation (\") marks, the value of the variable is used in the command or expression. If the variable name and dollar sign are enclosed in single quotation (') marks, the variable name is used in the expression. For more information about using quotation marks in PowerShell, see about_Quoting_Rules . Single quotes are used to assign to a variable the exact text that is placed between them, for example: PS > $var = 'Hello' PS > $var = 'The content of the variable is $var' PS > $var The content of the variable is $var The single quotes prevent the $ sign from being interpreted as the start of a variable name. To get Powershell to interpret the $ sign as the start of a variable name, the assignment is done with double quotes: PS > $var = 'Hello' PS > $var = \"Variable contains $var\" PS > $var Variable contains Hello The backtick ` causes Powershell to ignore the meaning of the following special character, for example: PS > $var = 'Hello' PS > $var = \"Variable `$ var contains $var\" PS > $var The variable $var contains Hello It can also be used to give special meaning to certain characters (equivalent to \\ in C and Java, for example \\n, \\t...). An example of use is the following: PS > $computername = 'localhost' PS > $phrase = \" `$ computername `n contains `n $computername\" PS > $phrase $computername contains localhost As you can see, `n stands for the carriage return character. To create or display a variable name that includes spaces or special characters, enclose the variable name with the curly braces ({}) characters. The curly braces direct PowerShell to interpret the variable name's characters as literals. ${ save-items } = \"a\" , \"b\" , \"c\" ${ save-items } To reference a variable name that includes braces, enclose the variable name in braces, and use the backtick character to escape the braces. For example, to create a variable named this{value}is type: ${ this `{ value `} is } = \"This variable name uses braces and backticks.\" ${ this `{ value `} is }","title":"Using Variables in Commands and Expressions"},{"location":"Scripting/variables/#list-variables","text":"It is possible to create a list type variable, separating the values \u200b\u200bof the list with commas: PS > $computers = 'server' , 'localhost' , 'server_2' PS > $computers server localhost server_2 List elements can be accessed by index number. Lists are numbered from zero: PS > $computers [ 0 ] server PS > $computers . count 3 Starting with Powershell version 3, if you pass a list as a parameter to a cmdlet, Powershell iterates over the items in the list. It is also possible to iterate over a list using the Foreach-Object cmdlet. These two commands do the same thing: $computers = $computers . tolower () $computers = $computers | ForEach -Object { $_ . tolower ()}","title":"List Variables"}]}