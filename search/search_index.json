{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This guide is designed to introduce you to PowerShell, a powerful command-line interface and scripting language built by Microsoft. Whether you are new to PowerShell or are looking to expand your skills, this guide will provide you with the necessary information to get started. Windows Powershell PowerShell is an automation solution that consists of a command-line shell, a scripting language, and a configuration-management framework. Installation PowerShell is pre-installed on Windows 10 and Windows Server 2016 and later, but you may need to update it to the latest version. To install PowerShell on older versions of Windows, visit the PowerShell GitHub repository and follow the installation instructions. Getting Started with PowerShell Before we dive into the commands, let's first open PowerShell. There are a few ways to do this: Click on the Start menu, search for PowerShell , and click on the Windows PowerShell option. Press the Windows key + R to open the Run dialog box, type in powershell , and press Enter . If you are using Windows 10, you can also right-click on the Start menu and select Windows PowerShell or Windows PowerShell (Admin) . Once you have PowerShell open, you can start entering commands. Command-line Shell Windows PowerShell superseded the Windows command-line interface (cmd.exe) and the limited functionality of its batch file scripting language. PowerShell accepts and returns .NET objects and includes: A command-line history. Tab completion and prediction. Support for command and parameter aliases . Chaining commands that use the Pipeline feature . A robust in-console help system Initially, Windows PowerShell was a platform built on the .NET Framework and only worked on Windows operating systems. However, with its recent releases, PowerShell uses the .NET Core and can run on Windows, macOS, and Linux platforms. Due to their multi-platform support, these recent releases are referred to as PowerShell (rather than Windows PowerShell). PowerShell Basics PowerShell commands are called cmdlets, and they follow a simple verb-noun syntax. For example, the command to get a list of files in a directory is Get-ChildItem. Here are some basic PowerShell commands to get you started: Get-Help : Get help for a cmdlet Get-Member : Essential tool for exploring objects and their properties, methods, and events Get-Process : Get information about running processes Get-Service : Get information about running services Get-ChildItem : Get a list of files and folders in a directory Set-Location : Change the current working directory Clear-Host : Clear the PowerShell console screen Exit : Exit PowerShell Commands provide PowerShell\u2019s main functionality. There are many varieties of commands, including cmdlets (pronounced command-lets), functions, filters, scripts, applications, configurations, and workflows. Commands are building blocks that you piece together by using the Windows PowerShell scripting language. Using commands enables you to create custom solutions to complex administrative problems. Alternatively, you can run commands directly within the PowerShell console to complete a single task. The console is the CLI for PowerShell and is the primary way in which you'll interact with PowerShell. Cmdlets use a Verb-Noun naming convention. For example, you can use the Get-Command cmdlet to list all cmdlets and functions that are registered in the command shell. The verb identifies the action for the cmdlet to perform, and the noun identifies the resource on which the cmdlet will perform its action. Working with Files and Folders PowerShell is particularly useful for working with files and folders. Here are some useful commands: New-Item : Create a new file or folder Remove-Item : Delete a file or folder Copy-Item : Copy a file or folder Move-Item : Move a file or folder Rename-Item : Rename a file or folder Get-Content : Get the contents of a file Set-Content : Set the contents of a file A Scripting Language PowerShell scripts are saved as .ps1 files and can be run from the command line or by double-clicking on the file. Here are some tips for writing PowerShell scripts: Use comments to explain your code Use variables to store data Use loops and conditional statements to control the flow of your script Use functions to reuse code Advanced PowerShell PowerShell is a very powerful tool, and there are many advanced features that you can use to make your scripts even more powerful. Here are some advanced topics to explore: Remoting: Run PowerShell commands on remote computers Modules : Extend PowerShell with additional functionality Desired State Configuration: Automate the configuration of your environment Error Handling : Handle errors in your scripts Configuration management framework PowerShell incorporates the PowerShell Desired State Configuration (DSC) management framework. This framework enables you to manage enterprise infrastructure with code to help with: Using declarative configurations and repeatable scripts for repeatable deployments. Enforcing configurations settings and identifying when configuration drift takes place from standard requirements. Deploying configuration settings using push or pull models. Applications and services with PowerShell\u2013based administrative functions are consistent in how they work. This attribute means that you can quickly apply the lessons you learned. Also, when you use automation scripts to administer a software application, you can reuse them among other applications. Conclusion PowerShell is a powerful tool that can help you automate repetitive tasks and manage your environment. By learning the basics of PowerShell, you can greatly improve your productivity and efficiency as an IT professional. With PowerShell, you can: Automate administrative tasks and eliminate manual work Manage and configure Windows operating systems and applications Integrate with other technologies and tools, such as Azure and Visual Studio Code Analyze and transform data using PowerShell commands and scripts In addition, PowerShell has a strong and supportive community of users and developers who are constantly creating new scripts, modules, and tools to extend its functionality. Whether you are a sysadmin, a developer, or just someone who wants to learn a powerful scripting language, PowerShell is a valuable tool to add to your skillset. With its robust features and wide range of applications, PowerShell can help you become more efficient and effective in your work. So why not give it a try and see what you can accomplish with PowerShell!","title":"Home"},{"location":"#windows-powershell","text":"PowerShell is an automation solution that consists of a command-line shell, a scripting language, and a configuration-management framework.","title":"Windows Powershell"},{"location":"#installation","text":"PowerShell is pre-installed on Windows 10 and Windows Server 2016 and later, but you may need to update it to the latest version. To install PowerShell on older versions of Windows, visit the PowerShell GitHub repository and follow the installation instructions.","title":"Installation"},{"location":"#getting-started-with-powershell","text":"Before we dive into the commands, let's first open PowerShell. There are a few ways to do this: Click on the Start menu, search for PowerShell , and click on the Windows PowerShell option. Press the Windows key + R to open the Run dialog box, type in powershell , and press Enter . If you are using Windows 10, you can also right-click on the Start menu and select Windows PowerShell or Windows PowerShell (Admin) . Once you have PowerShell open, you can start entering commands.","title":"Getting Started with PowerShell"},{"location":"#command-line-shell","text":"Windows PowerShell superseded the Windows command-line interface (cmd.exe) and the limited functionality of its batch file scripting language. PowerShell accepts and returns .NET objects and includes: A command-line history. Tab completion and prediction. Support for command and parameter aliases . Chaining commands that use the Pipeline feature . A robust in-console help system Initially, Windows PowerShell was a platform built on the .NET Framework and only worked on Windows operating systems. However, with its recent releases, PowerShell uses the .NET Core and can run on Windows, macOS, and Linux platforms. Due to their multi-platform support, these recent releases are referred to as PowerShell (rather than Windows PowerShell).","title":"Command-line Shell"},{"location":"#powershell-basics","text":"PowerShell commands are called cmdlets, and they follow a simple verb-noun syntax. For example, the command to get a list of files in a directory is Get-ChildItem. Here are some basic PowerShell commands to get you started: Get-Help : Get help for a cmdlet Get-Member : Essential tool for exploring objects and their properties, methods, and events Get-Process : Get information about running processes Get-Service : Get information about running services Get-ChildItem : Get a list of files and folders in a directory Set-Location : Change the current working directory Clear-Host : Clear the PowerShell console screen Exit : Exit PowerShell Commands provide PowerShell\u2019s main functionality. There are many varieties of commands, including cmdlets (pronounced command-lets), functions, filters, scripts, applications, configurations, and workflows. Commands are building blocks that you piece together by using the Windows PowerShell scripting language. Using commands enables you to create custom solutions to complex administrative problems. Alternatively, you can run commands directly within the PowerShell console to complete a single task. The console is the CLI for PowerShell and is the primary way in which you'll interact with PowerShell. Cmdlets use a Verb-Noun naming convention. For example, you can use the Get-Command cmdlet to list all cmdlets and functions that are registered in the command shell. The verb identifies the action for the cmdlet to perform, and the noun identifies the resource on which the cmdlet will perform its action.","title":"PowerShell Basics"},{"location":"#working-with-files-and-folders","text":"PowerShell is particularly useful for working with files and folders. Here are some useful commands: New-Item : Create a new file or folder Remove-Item : Delete a file or folder Copy-Item : Copy a file or folder Move-Item : Move a file or folder Rename-Item : Rename a file or folder Get-Content : Get the contents of a file Set-Content : Set the contents of a file","title":"Working with Files and Folders"},{"location":"#a-scripting-language","text":"PowerShell scripts are saved as .ps1 files and can be run from the command line or by double-clicking on the file. Here are some tips for writing PowerShell scripts: Use comments to explain your code Use variables to store data Use loops and conditional statements to control the flow of your script Use functions to reuse code","title":"A Scripting Language"},{"location":"#advanced-powershell","text":"PowerShell is a very powerful tool, and there are many advanced features that you can use to make your scripts even more powerful. Here are some advanced topics to explore: Remoting: Run PowerShell commands on remote computers Modules : Extend PowerShell with additional functionality Desired State Configuration: Automate the configuration of your environment Error Handling : Handle errors in your scripts","title":"Advanced PowerShell"},{"location":"#configuration-management-framework","text":"PowerShell incorporates the PowerShell Desired State Configuration (DSC) management framework. This framework enables you to manage enterprise infrastructure with code to help with: Using declarative configurations and repeatable scripts for repeatable deployments. Enforcing configurations settings and identifying when configuration drift takes place from standard requirements. Deploying configuration settings using push or pull models. Applications and services with PowerShell\u2013based administrative functions are consistent in how they work. This attribute means that you can quickly apply the lessons you learned. Also, when you use automation scripts to administer a software application, you can reuse them among other applications.","title":"Configuration management framework"},{"location":"#conclusion","text":"PowerShell is a powerful tool that can help you automate repetitive tasks and manage your environment. By learning the basics of PowerShell, you can greatly improve your productivity and efficiency as an IT professional. With PowerShell, you can: Automate administrative tasks and eliminate manual work Manage and configure Windows operating systems and applications Integrate with other technologies and tools, such as Azure and Visual Studio Code Analyze and transform data using PowerShell commands and scripts In addition, PowerShell has a strong and supportive community of users and developers who are constantly creating new scripts, modules, and tools to extend its functionality. Whether you are a sysadmin, a developer, or just someone who wants to learn a powerful scripting language, PowerShell is a valuable tool to add to your skillset. With its robust features and wide range of applications, PowerShell can help you become more efficient and effective in your work. So why not give it a try and see what you can accomplish with PowerShell!","title":"Conclusion"},{"location":"GetStart/","text":"Getting started with PowerShell is easy, and here are the steps to help you: Find and run PowerShell PowerShell is pre-installed on most modern Windows operating systems. To find it, click on the \"Start\" menu, type \"PowerShell\" in the search box, and select the \"Windows PowerShell\" or \"PowerShell 7\" option depending on which version you want to use. Alternatively, you can press the \"Windows Key + X\" key combination and select \"Windows PowerShell\" from the Power User menu. Check the PowerShell version To check which version of PowerShell you have installed, open a PowerShell session and run the following command: $PSVersionTable This will display the PowerShell version number and other version-related information, such as the CLR version, the .NET Framework version, and the OS version. Update PowerShell If you have an older version of PowerShell, you can update it to the latest version. Winget, the Windows Package Manager, is a command-line tool enables users to discover, install, upgrade, remove, and configure applications on Windows client computers. This tool is the client interface to the Windows Package Manager service. The following commands can be used to install PowerShell using the published winget packages: Search for the latest version of PowerShell winget search Microsoft . PowerShell Then, install PowerShell or PowerShell Preview using the id parameter winget install - -id Microsoft . Powershell - -source winget winget install - -id Microsoft . Powershell . Preview - -source winget Use PowerShell help PowerShell includes a comprehensive help system that you can use to learn about PowerShell cmdlets, functions, and modules. To use the help system, open a PowerShell session and run the following command: Get-Help < cmdlet or topic > Replace with the name of the cmdlet or topic you want to learn about. For example, to learn about the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem This will display the help information for the Get-ChildItem cmdlet, including a description, syntax, parameters, examples, and related topics. By following these steps, you can get started with PowerShell, check for its version, update it to the latest version, and use the built-in help system to learn more about PowerShell and its various features. More on the use of Get-Help The Get-Help cmdlet is a powerful feature of PowerShell that provides help information for cmdlets, functions, modules, and other PowerShell components. Here are some examples of how to use the Get-Help cmdlet: Get help for a specific cmdlet: To get help for a specific cmdlet, run the following command: Get-Help < cmdlet name > Replace with the name of the cmdlet you want to learn about. For example, to get help for the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem This will display the help information for the Get-ChildItem cmdlet, including a description, syntax, parameters, examples, and related topics. Get help for a specific parameter: To get help for a specific parameter of a cmdlet, run the following command: Get-Help < cmdlet name > -Parameter < parameter name > Replace with the name of the cmdlet and with the name of the parameter you want to learn about. For example, to get help for the Path parameter of the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem -Parameter Path This will display the help information for the Path parameter of the Get-ChildItem cmdlet. Get help for a specific topic: To get help for a specific topic, such as operators or variables, run the following command: Get-Help < topic > Replace with the name of the topic you want to learn about. For example, to get help for operators, you would run the following command: Get-Help about_operators This will display the help information for operators in PowerShell. Use wildcard with Get-Help: You can use wildcard characters to search for cmdlets or topics that match a certain pattern. For example, to search for all cmdlets that start with \"Get\", you would run the following command: Get-Help Get -* This will display help information for all cmdlets that start with \"Get\", including Get-ChildItem, Get-Item, Get-Process, and others. In summary, the Get-Help cmdlet is a valuable tool for learning about PowerShell and its various components. By using Get-Help with different parameters and wildcard characters, you can quickly find the information you need and improve your PowerShell skills.","title":"Getting Started"},{"location":"GetStart/#find-and-run-powershell","text":"PowerShell is pre-installed on most modern Windows operating systems. To find it, click on the \"Start\" menu, type \"PowerShell\" in the search box, and select the \"Windows PowerShell\" or \"PowerShell 7\" option depending on which version you want to use. Alternatively, you can press the \"Windows Key + X\" key combination and select \"Windows PowerShell\" from the Power User menu.","title":"Find and run PowerShell"},{"location":"GetStart/#check-the-powershell-version","text":"To check which version of PowerShell you have installed, open a PowerShell session and run the following command: $PSVersionTable This will display the PowerShell version number and other version-related information, such as the CLR version, the .NET Framework version, and the OS version.","title":"Check the PowerShell version"},{"location":"GetStart/#update-powershell","text":"If you have an older version of PowerShell, you can update it to the latest version. Winget, the Windows Package Manager, is a command-line tool enables users to discover, install, upgrade, remove, and configure applications on Windows client computers. This tool is the client interface to the Windows Package Manager service. The following commands can be used to install PowerShell using the published winget packages: Search for the latest version of PowerShell winget search Microsoft . PowerShell Then, install PowerShell or PowerShell Preview using the id parameter winget install - -id Microsoft . Powershell - -source winget winget install - -id Microsoft . Powershell . Preview - -source winget","title":"Update PowerShell"},{"location":"GetStart/#use-powershell-help","text":"PowerShell includes a comprehensive help system that you can use to learn about PowerShell cmdlets, functions, and modules. To use the help system, open a PowerShell session and run the following command: Get-Help < cmdlet or topic > Replace with the name of the cmdlet or topic you want to learn about. For example, to learn about the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem This will display the help information for the Get-ChildItem cmdlet, including a description, syntax, parameters, examples, and related topics. By following these steps, you can get started with PowerShell, check for its version, update it to the latest version, and use the built-in help system to learn more about PowerShell and its various features.","title":"Use PowerShell help"},{"location":"GetStart/#more-on-the-use-of-get-help","text":"The Get-Help cmdlet is a powerful feature of PowerShell that provides help information for cmdlets, functions, modules, and other PowerShell components. Here are some examples of how to use the Get-Help cmdlet: Get help for a specific cmdlet: To get help for a specific cmdlet, run the following command: Get-Help < cmdlet name > Replace with the name of the cmdlet you want to learn about. For example, to get help for the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem This will display the help information for the Get-ChildItem cmdlet, including a description, syntax, parameters, examples, and related topics. Get help for a specific parameter: To get help for a specific parameter of a cmdlet, run the following command: Get-Help < cmdlet name > -Parameter < parameter name > Replace with the name of the cmdlet and with the name of the parameter you want to learn about. For example, to get help for the Path parameter of the Get-ChildItem cmdlet, you would run the following command: Get-Help Get-ChildItem -Parameter Path This will display the help information for the Path parameter of the Get-ChildItem cmdlet. Get help for a specific topic: To get help for a specific topic, such as operators or variables, run the following command: Get-Help < topic > Replace with the name of the topic you want to learn about. For example, to get help for operators, you would run the following command: Get-Help about_operators This will display the help information for operators in PowerShell. Use wildcard with Get-Help: You can use wildcard characters to search for cmdlets or topics that match a certain pattern. For example, to search for all cmdlets that start with \"Get\", you would run the following command: Get-Help Get -* This will display help information for all cmdlets that start with \"Get\", including Get-ChildItem, Get-Item, Get-Process, and others. In summary, the Get-Help cmdlet is a valuable tool for learning about PowerShell and its various components. By using Get-Help with different parameters and wildcard characters, you can quickly find the information you need and improve your PowerShell skills.","title":"More on the use of Get-Help"},{"location":"comparison/","text":"The Compare-Object cmdlet (which has the alias diff) allows you to compare two objects and display the differences between them. In this sense, it allows you to compare a snapshot of processes (or services, or anything else) from a system with a more current snapshot. For example, you can generate a snapshot of the system's processes: get-process | export-clixml processes . xml ... and later, compare it with the processes that are running at that time: diff -Ref ( Import-Clixml .\\ processes . xml ) -Diff ( get-process ) -Property name The previous command is interpreted as follows: Parentheses are interpreted the same as in algebra: the commands that are inside parentheses are executed first, and their results are passed to the outermost command. The -Ref parameter (-ReferenceObject in full) indicates the object that will be used as the basis for the comparison (in this case, the snapshot that was previously saved). The -Diff parameter (-DifferenceObject in full) indicates the object that will be compared against the base (in this case, the current list of processes). The -Property parameter indicates the property that is being compared, in this case, the names of the processes. The output of the command is similar to this: name SideIndicator ---- ------------- WindowsInternal.ComposableShell.Experiences.TextInput.InputApp => YourPhone => LockApp <= Microsoft.Photos <= notepad <= The names of the processes appear, with an arrow pointing to the left or right: \u2022 If the arrow points to the right, it indicates a name that is in the new snapshot but not in the original. \u2022 If the arrow points to the left, it indicates a name that is in the original snapshot but not in the new one.","title":"Object Comparison"},{"location":"config_profile/","text":"Configuring your PowerShell profile is an essential step to personalize your PowerShell environment and make your work more efficient. Your profile is a PowerShell script file that executes every time you start a PowerShell session. You can use it to customize your environment by adding aliases, functions, variables, and modules. Here's an example of how to configure your profile in PowerShell: Open PowerShell and run the following command to create a new profile file if it doesn't exist: if ( ! ( Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } Open your profile file with your preferred text editor or IDE. You can find the location of your profile file by running the following command: notepad $PROFILE This will open your profile file in Notepad. Add any customizations you want to your profile file. For example, you can add an alias to simplify a frequently used command. To create an alias for the Get-ChildItem cmdlet, add the following line to your profile: Set-Alias -Name ls -Value Get-ChildItem This creates an alias named ls that runs the Get-ChildItem cmdlet. Save and close your profile file. Restart PowerShell to apply your changes. Your customizations should now be available in your PowerShell session. In addition to aliases, you can also use your profile to configure your PowerShell prompt, set default parameters for cmdlets, load modules automatically, and define functions that you frequently use. By taking advantage of the customization options available in your profile, you can make your PowerShell experience more efficient and tailored to your needs. Here is an example of a common $profile script for PowerShell: # Add custom PowerShell functions function Get-Weather { param ([ string ] $location = \"New York\" ) Invoke-RestMethod -Uri \"https://wttr.in/ $location ?format=%C+%t\" -UseBasicParsing } # Load useful PowerShell modules Import-Module Pester Import-Module PSReadline Import-Module Microsoft.PowerShell.Management # Set default parameters for cmdlets $PSDefaultParameterValues = @ { \"Get-ChildItem:Recurse\" = $true \"Out-File:Encoding\" = \"utf8\" } # Add custom aliases Set-Alias -Name l -Value Get-ChildItem Set-Alias -Name gac -Value Get-ChildItem -ParameterName FullName -ArgumentList \"C:\\Windows\\Microsoft.NET\\assembly\\GAC*\" # Configure PowerShell prompt $host .UI.RawUI.WindowTitle = \" $env :USERNAME@ $env :COMPUTERNAME\" $host .UI.RawUI.ForegroundColor = \"Green\" $host .UI.RawUI.BackgroundColor = \"Black\" $host .UI.RawUI.WindowSize = New-Object System.Management.Automation.Host.Size ( 120 ,50 ) This $profile script defines several customizations for the PowerShell environment, including: A custom function named Get-Weather that uses the Invoke-RestMethod cmdlet to retrieve weather information for a specified location. The loading of several useful PowerShell modules, including Pester, PSReadline, and Microsoft.PowerShell.Management. Default parameter values for the Get-ChildItem and Out-File cmdlets. Custom aliases for the Get-ChildItem cmdlet and a common path for the Get-ChildItem cmdlet. Configuration of the PowerShell prompt, including the window title, foreground and background colors, and window size. By using a $profile script like this one, you can customize your PowerShell environment to suit your needs and make your work more efficient.","title":"Config Profile"},{"location":"enum/","text":"Enumeration is the process of performing a task on each object, one at a time, in a collection. Frequently, PowerShell doesn't require you to explicitly enumerate objects. For example, if you need to stop every running Notepad process on your computer, you can run either of these two commands: Get-Process \u2013 Name Notepad | Stop-Process Stop-Process \u2013 Name Notepad The ForEach-Object command performs enumeration. It has two common aliases: ForEach and %. Like Where-Object, ForEach-Object has a basic syntax and an advanced syntax. Basic Syntax In the basic syntax, you can run a single method or access a single property of the objects that were piped into the command. Get-ChildItem \u2013 Path C :\\ Encrypted \\ File | ForEach Object MemberName Encrypt With this syntax, you don't include the parentheses after the member name if the member is a method. Because this basic syntax is meant to be short, you'll frequently notice it without the -MemberName parameter name, and you might notice it with an alias instead of the full command name. For example, both of the following commands perform the same action: Get-ChildItem \u2013 Path C :\\ Encrypted \\ -File | ForEach Encrypt Get-ChildItem \u2013 Path C :\\ Encrypted \\ -File | % Encrypt You might not run into many scenarios that require enumeration. Each new operating system and version of PowerShell introduces new PowerShell commands. Newer operating systems typically introduce new commands which perform actions that previously required enumeration. Limitations of the basic syntax The basic syntax can access only a single property or method. It can't perform logical comparisons that use -and or -or; it can't make decisions; and it can't run any other commands or code. For example, the following command doesn't run, and it produces an error: Get-Service | ForEach -MemberName Stop -and -MemberName Close Advanced Syntax The advanced syntax for enumeration provides more flexibility and functionality than the basic syntax. Instead of letting you access a single object member, you can run a whole script. That script can include one command, or it can include many commands in sequence. Get-ChildItem \u2013 Path C :\\ ToEncrypt \\ -File | ForEach -Object \u2013 Process { $PSItem . Encrypt () } The ForEach-Object command can accept any number of objects from the pipeline. It has the -Process parameter that accepts a script block. This script block runs one time for each object that was piped in. Every time that the script block runs, the built-in variable $PSItem (or $_) can be used to refer to the current object. In the preceding example command, the Encrypt() method of each file object runs. When used with the advanced syntax, method names are always followed by opening and closing parentheses, even when the method doesn't have any input arguments. For methods that do need input arguments, provide them as a comma-separated list inside the parentheses. Don't include a space or other characters between the method name and the opening parenthesis. Advanced techniques In some situations, you might need to repeat a particular task a specified number of times. You can use ForEach-Object for that purpose when you pass it an input that uses the range operator. The range operator is two periods (..) with no space between them. For example, run the following command: 1 .. 100 | ForEach -Object { Get-Random } In the preceding command, the range operator produces integer objects from 1 through 100. Those 100 objects are piped to ForEach-Object, forcing the script block to run 100 times. However, because neither $_ nor $_PSItem display in the script block, the actual integers aren't used. Instead, the Get-Random command runs 100 times. The integer objects are used only to set the number of times the script block runs.","title":"Enumeration"},{"location":"enum/#basic-syntax","text":"In the basic syntax, you can run a single method or access a single property of the objects that were piped into the command. Get-ChildItem \u2013 Path C :\\ Encrypted \\ File | ForEach Object MemberName Encrypt With this syntax, you don't include the parentheses after the member name if the member is a method. Because this basic syntax is meant to be short, you'll frequently notice it without the -MemberName parameter name, and you might notice it with an alias instead of the full command name. For example, both of the following commands perform the same action: Get-ChildItem \u2013 Path C :\\ Encrypted \\ -File | ForEach Encrypt Get-ChildItem \u2013 Path C :\\ Encrypted \\ -File | % Encrypt You might not run into many scenarios that require enumeration. Each new operating system and version of PowerShell introduces new PowerShell commands. Newer operating systems typically introduce new commands which perform actions that previously required enumeration.","title":"Basic Syntax"},{"location":"enum/#limitations-of-the-basic-syntax","text":"The basic syntax can access only a single property or method. It can't perform logical comparisons that use -and or -or; it can't make decisions; and it can't run any other commands or code. For example, the following command doesn't run, and it produces an error: Get-Service | ForEach -MemberName Stop -and -MemberName Close","title":"Limitations of the basic syntax"},{"location":"enum/#advanced-syntax","text":"The advanced syntax for enumeration provides more flexibility and functionality than the basic syntax. Instead of letting you access a single object member, you can run a whole script. That script can include one command, or it can include many commands in sequence. Get-ChildItem \u2013 Path C :\\ ToEncrypt \\ -File | ForEach -Object \u2013 Process { $PSItem . Encrypt () } The ForEach-Object command can accept any number of objects from the pipeline. It has the -Process parameter that accepts a script block. This script block runs one time for each object that was piped in. Every time that the script block runs, the built-in variable $PSItem (or $_) can be used to refer to the current object. In the preceding example command, the Encrypt() method of each file object runs. When used with the advanced syntax, method names are always followed by opening and closing parentheses, even when the method doesn't have any input arguments. For methods that do need input arguments, provide them as a comma-separated list inside the parentheses. Don't include a space or other characters between the method name and the opening parenthesis.","title":"Advanced Syntax"},{"location":"enum/#advanced-techniques","text":"In some situations, you might need to repeat a particular task a specified number of times. You can use ForEach-Object for that purpose when you pass it an input that uses the range operator. The range operator is two periods (..) with no space between them. For example, run the following command: 1 .. 100 | ForEach -Object { Get-Random } In the preceding command, the range operator produces integer objects from 1 through 100. Those 100 objects are piped to ForEach-Object, forcing the script block to run 100 times. However, because neither $_ nor $_PSItem display in the script block, the actual integers aren't used. Instead, the Get-Random command runs 100 times. The integer objects are used only to set the number of times the script block runs.","title":"Advanced techniques"},{"location":"files_folders/","text":"PowerShell provides a variety of cmdlets for working with files and folders. In PowerShell, an \"item\" is a generic term used to refer to a file, folder, registry key, or other object that can be manipulated by cmdlets in the PowerShell environment. The term \"item\" is used in cmdlet names such as Get-Item, Set-Item, and Remove-Item, which can be used to manipulate different types of items in PowerShell. Items Here are some examples of how to use these cmdlets: Cmdlet Description Alias Get-ChildItem Gets the items and child items in one or more specified locations gci, dir, ls Set-Location Sets the working location to a specified location cd, sl, chdir Copy-Item Copies an item from one location to another location cp, copy Move-Item Moves an item from one location to another location mv, move Remove-Item Deletes the specified items ri, rmdir, rd, del, erase New-Item Creates a new item at the specified location ni Rename-Item Renames an item at the specified location rni Note that some of these cmdlets have additional parameters that can be used to control their behavior. For example, you can use the -Recurse parameter with Remove-Item to delete a directory and all its contents. You can also use wildcards with many of these cmdlets to perform operations on multiple files or directories at once. Get-ChildItem This cmdlet lists the contents of a directory. By default, it displays both files and directories. Example: Get-ChildItem C :\\ Users Set-Location This cmdlet changes the current working directory. Example: Set-Location C :\\ Users \\ UserName \\ Desktop Copy-Item This cmdlet copies a file or directory to a new location. Example: Copy-Item C :\\ Users \\ UserName \\ Desktop \\ MyFile . txt C :\\ Temp \\ Move-Item This cmdlet moves a file or directory to a new location. Example: Move-Item C :\\ Users \\ UserName \\ Desktop \\ MyFile . txt C :\\ Temp \\ Rename-Item This cmdlet renames a file or directory. Example: Rename-Item C :\\ Temp \\ MyFile . txt MyNewFile . txt New-Item This cmdlet creates a new file or directory. Example: New-Item -ItemType File -Path C :\\ Temp \\ NewFile . txt Remove-Item This cmdlet deletes a file or directory. Example: Remove-Item C :\\ Temp \\ MyFile . txt Properties In PowerShell, cmdlets whose names end with \"Property\" are used to retrieve or manipulate the properties of objects. Properties are attributes or characteristics of an object, such as its name, size, or creation date. The most common cmdlet that ends with \"Property\" is the Get-ItemProperty cmdlet, which is used to retrieve the properties of a file, folder, or registry key. For example, you can use the Get-ItemProperty cmdlet to retrieve the version number of a file or the registry key value for a particular setting. Other examples of cmdlets that end with \"Property\" include the Get-ServiceProperty cmdlet, which is used to retrieve the properties of a Windows service, and the Get-ADUserProperty cmdlet, which is used to retrieve the properties of an Active Directory user. In general, cmdlets that end with \"Property\" are useful for retrieving specific information about an object, which can be used in scripts or further manipulated using other PowerShell cmdlets. Cmdlet Description New-ItemProperty Creates a new property for an item at the specified location Get-ItemProperty Gets the properties of the specified items Set-ItemProperty Sets the value of a property for the specified item Remove-ItemProperty Removes a property from an item at the specified location Some interesting properties are: CreationTime, FullName, LastAccessTime, LastWriteTime, Attributes. For example, to check the creation time of a file: get-itemproperty -path filename -name CreationTime To check the attributes (permissions) of the file: get-itemproperty -path file -name Attributes To set the attributes, the Set-Itemproperty command is used, for example: set-itemproperty -path file -name Attributes -value \"ReadOnly\" Some permission values are ReadOnly, Hidden, System. If you want to set multiple permissions at once, separate their names with commas, and enclose the entire set in quotation marks (as in the example). Paths In PowerShell, cmdlets whose names end with \"Path\" are used to work with file and directory paths. These cmdlets are commonly used to manipulate or retrieve information about file and directory paths, such as their locations, names, or extensions. One of the most commonly used cmdlets that ends with \"Path\" is the Split-Path cmdlet, which is used to split a file or directory path into its individual components, such as the directory, filename, and extension. For example, the command \"Split-Path C:\\Temp\\test.txt -Leaf\" would return \"test.txt\", while \"Split-Path C:\\Temp\\test.txt -Parent\" would return \"C:\\Temp\". Another example is the Join-Path cmdlet, which is used to combine two or more path strings into a single path. For example, the command \"Join-Path C:\\Temp test.txt\" would return \"C:\\Temp\\test.txt\". Other examples of cmdlets that end with \"Path\" include the Resolve-Path cmdlet, which is used to resolve a path to its full, absolute form, and the Test-Path cmdlet, which is used to test whether a file or directory path exists. In general, cmdlets that end with \"Path\" are useful for manipulating file and directory paths, which can be useful for scripting or automating tasks that involve working with files and directories. Cmdlet Description Test-Path Determines whether all elements of a path exist Join-Path Joins two or more parts of a path into a single path Split-Path Returns specific parts of a path Convert-Path Converts a path from a relative path to a full path or from a full path to a relative path Directories or Folders Operation Command Creation new-item -itemtype directory -name directory_name Deletion remove-item -path directory_name -Recurse Rename rename-item -path directory_name -newname new_directory_name -Recurse Move move-item -path directory_name -destination new_location Enter cd directory_name Show current directory Get-Location or pwd (same as Linux) Note .(dot) indicates the current directory and ..(dot dot) indicates the parent of the current directory. Files Operation Command Creation new-item -itemtype file -name file_name [-value content] Deletion remove-item -path file_name Renaming rename-item -path file_name -newname new_name Moving move-item -path file_name -destination new_location Text files can be displayed on the console using the Get-Content command, which has the alias \"type\".","title":"Files & Folders"},{"location":"files_folders/#items","text":"Here are some examples of how to use these cmdlets: Cmdlet Description Alias Get-ChildItem Gets the items and child items in one or more specified locations gci, dir, ls Set-Location Sets the working location to a specified location cd, sl, chdir Copy-Item Copies an item from one location to another location cp, copy Move-Item Moves an item from one location to another location mv, move Remove-Item Deletes the specified items ri, rmdir, rd, del, erase New-Item Creates a new item at the specified location ni Rename-Item Renames an item at the specified location rni Note that some of these cmdlets have additional parameters that can be used to control their behavior. For example, you can use the -Recurse parameter with Remove-Item to delete a directory and all its contents. You can also use wildcards with many of these cmdlets to perform operations on multiple files or directories at once.","title":"Items"},{"location":"files_folders/#get-childitem","text":"This cmdlet lists the contents of a directory. By default, it displays both files and directories. Example: Get-ChildItem C :\\ Users","title":"Get-ChildItem"},{"location":"files_folders/#set-location","text":"This cmdlet changes the current working directory. Example: Set-Location C :\\ Users \\ UserName \\ Desktop","title":"Set-Location"},{"location":"files_folders/#copy-item","text":"This cmdlet copies a file or directory to a new location. Example: Copy-Item C :\\ Users \\ UserName \\ Desktop \\ MyFile . txt C :\\ Temp \\","title":"Copy-Item"},{"location":"files_folders/#move-item","text":"This cmdlet moves a file or directory to a new location. Example: Move-Item C :\\ Users \\ UserName \\ Desktop \\ MyFile . txt C :\\ Temp \\","title":"Move-Item"},{"location":"files_folders/#rename-item","text":"This cmdlet renames a file or directory. Example: Rename-Item C :\\ Temp \\ MyFile . txt MyNewFile . txt","title":"Rename-Item"},{"location":"files_folders/#new-item","text":"This cmdlet creates a new file or directory. Example: New-Item -ItemType File -Path C :\\ Temp \\ NewFile . txt","title":"New-Item"},{"location":"files_folders/#remove-item","text":"This cmdlet deletes a file or directory. Example: Remove-Item C :\\ Temp \\ MyFile . txt","title":"Remove-Item"},{"location":"files_folders/#properties","text":"In PowerShell, cmdlets whose names end with \"Property\" are used to retrieve or manipulate the properties of objects. Properties are attributes or characteristics of an object, such as its name, size, or creation date. The most common cmdlet that ends with \"Property\" is the Get-ItemProperty cmdlet, which is used to retrieve the properties of a file, folder, or registry key. For example, you can use the Get-ItemProperty cmdlet to retrieve the version number of a file or the registry key value for a particular setting. Other examples of cmdlets that end with \"Property\" include the Get-ServiceProperty cmdlet, which is used to retrieve the properties of a Windows service, and the Get-ADUserProperty cmdlet, which is used to retrieve the properties of an Active Directory user. In general, cmdlets that end with \"Property\" are useful for retrieving specific information about an object, which can be used in scripts or further manipulated using other PowerShell cmdlets. Cmdlet Description New-ItemProperty Creates a new property for an item at the specified location Get-ItemProperty Gets the properties of the specified items Set-ItemProperty Sets the value of a property for the specified item Remove-ItemProperty Removes a property from an item at the specified location Some interesting properties are: CreationTime, FullName, LastAccessTime, LastWriteTime, Attributes. For example, to check the creation time of a file: get-itemproperty -path filename -name CreationTime To check the attributes (permissions) of the file: get-itemproperty -path file -name Attributes To set the attributes, the Set-Itemproperty command is used, for example: set-itemproperty -path file -name Attributes -value \"ReadOnly\" Some permission values are ReadOnly, Hidden, System. If you want to set multiple permissions at once, separate their names with commas, and enclose the entire set in quotation marks (as in the example).","title":"Properties"},{"location":"files_folders/#paths","text":"In PowerShell, cmdlets whose names end with \"Path\" are used to work with file and directory paths. These cmdlets are commonly used to manipulate or retrieve information about file and directory paths, such as their locations, names, or extensions. One of the most commonly used cmdlets that ends with \"Path\" is the Split-Path cmdlet, which is used to split a file or directory path into its individual components, such as the directory, filename, and extension. For example, the command \"Split-Path C:\\Temp\\test.txt -Leaf\" would return \"test.txt\", while \"Split-Path C:\\Temp\\test.txt -Parent\" would return \"C:\\Temp\". Another example is the Join-Path cmdlet, which is used to combine two or more path strings into a single path. For example, the command \"Join-Path C:\\Temp test.txt\" would return \"C:\\Temp\\test.txt\". Other examples of cmdlets that end with \"Path\" include the Resolve-Path cmdlet, which is used to resolve a path to its full, absolute form, and the Test-Path cmdlet, which is used to test whether a file or directory path exists. In general, cmdlets that end with \"Path\" are useful for manipulating file and directory paths, which can be useful for scripting or automating tasks that involve working with files and directories. Cmdlet Description Test-Path Determines whether all elements of a path exist Join-Path Joins two or more parts of a path into a single path Split-Path Returns specific parts of a path Convert-Path Converts a path from a relative path to a full path or from a full path to a relative path","title":"Paths"},{"location":"files_folders/#directories-or-folders","text":"Operation Command Creation new-item -itemtype directory -name directory_name Deletion remove-item -path directory_name -Recurse Rename rename-item -path directory_name -newname new_directory_name -Recurse Move move-item -path directory_name -destination new_location Enter cd directory_name Show current directory Get-Location or pwd (same as Linux) Note .(dot) indicates the current directory and ..(dot dot) indicates the parent of the current directory.","title":"Directories or Folders"},{"location":"files_folders/#files","text":"Operation Command Creation new-item -itemtype file -name file_name [-value content] Deletion remove-item -path file_name Renaming rename-item -path file_name -newname new_name Moving move-item -path file_name -destination new_location Text files can be displayed on the console using the Get-Content command, which has the alias \"type\".","title":"Files"},{"location":"filtering/","text":"Command output can be filtered in several ways: Using wildcards in the parameters that support it. For example: get-service -name s * ...displays a list of services whose name starts with S. If the parameter does not support wildcards, the Where-Object (abbreviated Where) cmdlet can be used in the pipeline. For example: Get-Service | where -filter { $_ . Status -like \"Run*\" } ...displays a list of services whose status starts with \"Run\" Some of the comparison operators that can be used are: Operator Meaning -eq Equal -ne not equal -gt Greater than -ge Greater than or equal -lt Less Than -le Less than or equal -like Matches the expression with wildcards -notlike Does not match the expression with wildcards For example: Get-Service | where -filter { $_ . Status -eq \"Running\" } String comparisons are normally not case sensitive. If it is required to do so, a c is placed before the operators (-ceq, -cne, -cgt, -cge...). You can also use the connectives -and and -or. PowerShell also contains the -like operator and its case-sensitive companion, -clike. The -like operator resembles -eq but supports the use of the question mark (?) and asterisk (*) wildcard characters in string comparisons. Other, more advanced operators exist that are beyond the scope of this course. These operators include: The -in and -contains operators, which test whether an object exists in a collection. The -as operator, which tests whether an object is of a specified type. The -match and -cmatch operators, which compare a string to a regular expression. PowerShell also contains many operators that reverse the logic of the comparison, such as -notlike and -notin. For more information, see the help topic about_comparison_operators. Advanced Filtering The advanced syntax of Where-Object uses a filter script. A filter script is a script block that contains the comparison and that you pass by using the -FilterScript parameter. Within that script block, you can use the built-in $PSItem variable (or $_, which is also valid in versions of Windows PowerShell older than 3.0) to reference whatever object was piped into the command. Your filter script runs one time for each object that's piped into the command. When the filter script returns True, that object is passed down the pipeline as output. When the filter script returns False, that object is removed from the pipeline. The following two commands are functionally identical. The first uses the basic syntax, and the second uses the advanced syntax to do the same thing: ## basic syntax Get-Service | Where Status \u2013 eq Running ## advanced syntax Get-Service | Where-Object \u2013 FilterScript { $PSItem . Status \u2013 eq 'Running' } The -FilterScript parameter is positional, and most users omit it. Most users also use the Where alias or the ? alias, which is even shorter. Experienced Windows PowerShell users also use the $ variable instead of $PSItem, because only $ is allowed in Windows PowerShell 1.0 and Windows PowerShell 2.0. The following commands perform the same task as the previous two commands: Get-Service | Where { $PSItem . Status \u2013 eq 'Running' } Get-Service | ? { $_ . Status \u2013 eq 'Running' } Combining multiple criteria The advanced syntax allows you to combine multiple criteria by using the -and and -or Boolean, or logical, operators. Here's an example: Get-EventLog \u2013 LogName Security \u2013 Newest 100 | Where { $PSItem . EventID \u2013 eq 4672 \u2013 and $PSItem . EntryType \u2013 eq 'SuccessAudit' } Accessing properties without limitations Although the basic filtering syntax can access only the direct properties of the object being evaluated, the advanced syntax doesn't have that limitation. For example, to display a list of all the services that have names longer than eight characters, use this command: Get-Service | Where { $PSItem . Name . Length \u2013 gt 8 } Example It is required to draw a list that includes the 10 processes that are consuming the most virtual memory, not including Powershell. At the end, the total virtual memory that these 10 processes are consuming should be presented. The listing should only include the Name and VM columns. The first step (filtering Powershell processes) can be done like this: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } Then it is organized by the VM column, in descending order, and the columns that you want to show are specified: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } | sort VM -desc | select name , vm Finally, the Measure-Object cmdlet is used to find the total virtual memory usage: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } | sort VM | select name , vm -first 10 | Measure-Object -Property vm -sum Other Example Get-Process | Select-Object Name , ID , @{ n = 'VirtualMemory(MB)' ; e ={ '{0:N2}' \u2013 f ( $PSItem . VM / 1MB ) -as [Double] }}, @{ n = 'PagedMemory(MB)' ; e ={ '{0:N2}' \u2013 f ( $PSItem . PM / 1MB ) -as [Double] }} This example uses the Windows PowerShell -f formatting operator. When used with a string, the -f formatting operator instructs Windows PowerShell to replace one or more placeholders in the string with the specified values that follow the operator. In this example, the string that precedes the -f operator instructs Windows PowerShell what data to display. The string '{0:N2}' signifies displaying the first data item as a number with two decimal places. The original mathematical expression comes after the operator. It's in parentheses to make sure that it runs as a single unit. Best Practice is to always filter left , any filtering should occur as far to the left, or as close to the beginning of the command line, as possible. This will have a significant effect on performance.","title":"Filtering"},{"location":"filtering/#advanced-filtering","text":"The advanced syntax of Where-Object uses a filter script. A filter script is a script block that contains the comparison and that you pass by using the -FilterScript parameter. Within that script block, you can use the built-in $PSItem variable (or $_, which is also valid in versions of Windows PowerShell older than 3.0) to reference whatever object was piped into the command. Your filter script runs one time for each object that's piped into the command. When the filter script returns True, that object is passed down the pipeline as output. When the filter script returns False, that object is removed from the pipeline. The following two commands are functionally identical. The first uses the basic syntax, and the second uses the advanced syntax to do the same thing: ## basic syntax Get-Service | Where Status \u2013 eq Running ## advanced syntax Get-Service | Where-Object \u2013 FilterScript { $PSItem . Status \u2013 eq 'Running' } The -FilterScript parameter is positional, and most users omit it. Most users also use the Where alias or the ? alias, which is even shorter. Experienced Windows PowerShell users also use the $ variable instead of $PSItem, because only $ is allowed in Windows PowerShell 1.0 and Windows PowerShell 2.0. The following commands perform the same task as the previous two commands: Get-Service | Where { $PSItem . Status \u2013 eq 'Running' } Get-Service | ? { $_ . Status \u2013 eq 'Running' }","title":"Advanced Filtering"},{"location":"filtering/#combining-multiple-criteria","text":"The advanced syntax allows you to combine multiple criteria by using the -and and -or Boolean, or logical, operators. Here's an example: Get-EventLog \u2013 LogName Security \u2013 Newest 100 | Where { $PSItem . EventID \u2013 eq 4672 \u2013 and $PSItem . EntryType \u2013 eq 'SuccessAudit' }","title":"Combining multiple criteria"},{"location":"filtering/#accessing-properties-without-limitations","text":"Although the basic filtering syntax can access only the direct properties of the object being evaluated, the advanced syntax doesn't have that limitation. For example, to display a list of all the services that have names longer than eight characters, use this command: Get-Service | Where { $PSItem . Name . Length \u2013 gt 8 }","title":"Accessing properties without limitations"},{"location":"filtering/#example","text":"It is required to draw a list that includes the 10 processes that are consuming the most virtual memory, not including Powershell. At the end, the total virtual memory that these 10 processes are consuming should be presented. The listing should only include the Name and VM columns. The first step (filtering Powershell processes) can be done like this: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } Then it is organized by the VM column, in descending order, and the columns that you want to show are specified: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } | sort VM -desc | select name , vm Finally, the Measure-Object cmdlet is used to find the total virtual memory usage: Get Process | where -filter { $_ . Name -notlike \"Powershell*\" } | sort VM | select name , vm -first 10 | Measure-Object -Property vm -sum","title":"Example"},{"location":"filtering/#other-example","text":"Get-Process | Select-Object Name , ID , @{ n = 'VirtualMemory(MB)' ; e ={ '{0:N2}' \u2013 f ( $PSItem . VM / 1MB ) -as [Double] }}, @{ n = 'PagedMemory(MB)' ; e ={ '{0:N2}' \u2013 f ( $PSItem . PM / 1MB ) -as [Double] }} This example uses the Windows PowerShell -f formatting operator. When used with a string, the -f formatting operator instructs Windows PowerShell to replace one or more placeholders in the string with the specified values that follow the operator. In this example, the string that precedes the -f operator instructs Windows PowerShell what data to display. The string '{0:N2}' signifies displaying the first data item as a number with two decimal places. The original mathematical expression comes after the operator. It's in parentheses to make sure that it runs as a single unit. Best Practice is to always filter left , any filtering should occur as far to the left, or as close to the beginning of the command line, as possible. This will have a significant effect on performance.","title":"Other Example"},{"location":"get_member/","text":"The Get-Member cmdlet in PowerShell is an essential tool for exploring objects and their properties, methods, and events. It retrieves the members (properties, methods, and events) of an object and displays their definitions and syntax, which can help users understand the object and how to interact with it. Syntax The syntax for using Get-Member is as follows: Get-Member [ -InputObject ] < PSObject > [ -MemberType { Property | Method | Event | NoteProperty | AliasProperty | ScriptProperty | PropertySet | All }] [ -Force ] [ -Static ] Here's an explanation of the parameters: InputObject: specifies the object for which to retrieve the members. It can be piped to Get-Member or specified as an argument. MemberType: specifies the type of members to retrieve. It can be one of the following: Property (instance properties), Method (instance methods), Event (instance events), NoteProperty (extended properties), AliasProperty (aliases), ScriptProperty (script properties), PropertySet (property sets), or All (all members). Force: forces Get-Member to retrieve hidden or non-public members. Static: retrieves static members of a class. Examples View the properties of an object: Get-Process | Get-Member -MemberType Property This command retrieves the list of properties associated with the Get-Process cmdlet. View the methods of an object: Get-ChildItem | Get-Member -MemberType Method This command retrieves the list of methods associated with the Get-ChildItem cmdlet. Filter the results by name or type: Get-Process | Get-Member -Name \"<Name>\" This command retrieves only the properties with the name \" \" from the Get-Process cmdlet. View the static properties of a .NET class: [System.Math] | Get-Member -Static -MemberType Property This command retrieves the static properties of the .NET class System.Math.","title":"GetMember"},{"location":"get_member/#syntax","text":"The syntax for using Get-Member is as follows: Get-Member [ -InputObject ] < PSObject > [ -MemberType { Property | Method | Event | NoteProperty | AliasProperty | ScriptProperty | PropertySet | All }] [ -Force ] [ -Static ] Here's an explanation of the parameters: InputObject: specifies the object for which to retrieve the members. It can be piped to Get-Member or specified as an argument. MemberType: specifies the type of members to retrieve. It can be one of the following: Property (instance properties), Method (instance methods), Event (instance events), NoteProperty (extended properties), AliasProperty (aliases), ScriptProperty (script properties), PropertySet (property sets), or All (all members). Force: forces Get-Member to retrieve hidden or non-public members. Static: retrieves static members of a class.","title":"Syntax"},{"location":"get_member/#examples","text":"View the properties of an object: Get-Process | Get-Member -MemberType Property This command retrieves the list of properties associated with the Get-Process cmdlet. View the methods of an object: Get-ChildItem | Get-Member -MemberType Method This command retrieves the list of methods associated with the Get-ChildItem cmdlet. Filter the results by name or type: Get-Process | Get-Member -Name \"<Name>\" This command retrieves only the properties with the name \" \" from the Get-Process cmdlet. View the static properties of a .NET class: [System.Math] | Get-Member -Static -MemberType Property This command retrieves the static properties of the .NET class System.Math.","title":"Examples"},{"location":"getalias/","text":"In PowerShell, an alias is an alternate name or shortcut that you can use to refer to a cmdlet, function, executable, or script. Aliases can be used to save time and typing effort, and they can also be customized to match your preferences and habits. For example, instead of typing Get-ChildItem every time you want to list the contents of a directory, you can use the alias ls instead. Similarly, instead of typing Set-Location to change the current directory, you can use the alias cd instead. PowerShell comes with a set of built-in aliases that map common commands to shorter names, such as ls for Get-ChildItem, cd for Set-Location, and dir for Get-ChildItem -Directory. You can use the Get-Alias cmdlet to view the list of built-in aliases. In addition to the built-in aliases, you can create your own aliases or modify existing ones using the New-Alias and Set-Alias cmdlets. For example, you could create an alias wd for Set-Location -Path C:\\Windows, or you could modify the ls alias to include the -Force parameter by using Set-Alias. ls Get-ChildItem -Force While aliases can be useful in PowerShell for saving time and reducing typing, there are also some limitations and potential issues to be aware of: Clarity: Aliases can make code harder to understand, especially for other users who may not be familiar with the specific aliases you're using. It's generally recommended to use the full cmdlet names in scripts and functions to make the code more clear and self-explanatory. Conflicts: Multiple aliases can be defined for the same cmdlet, and aliases can also be defined for other aliases. This can lead to confusion and potential conflicts, especially when using modules or scripts that define their own aliases. Portability: Aliases are specific to the PowerShell session in which they are defined. If you use a script or module that relies on specific aliases, you may run into issues if those aliases are not defined on the system where the script is being run. Autocomplete: PowerShell's autocomplete feature may not work with aliases, depending on the specific environment and tools you're using. Overall, while aliases can be useful in certain situations, it's important to use them judiciously and be aware of their limitations and potential issues. It's generally best to use the full cmdlet names in scripts and functions to ensure clarity and portability, and to avoid potential conflicts with other aliases or scripts. Get-Alias Get-Alias is a PowerShell cmdlet that is used to display the aliases for cmdlets, functions, and scripts. It allows you to see the built-in aliases that are available in PowerShell, as well as any custom aliases that you or other users have created. Here are some common ways to use Get-Alias: List all aliases You can use the Get-Alias cmdlet without any parameters to list all the aliases available in your PowerShell session. Get-Alias List aliases for a specific command You can use the -Definition parameter followed by the name of the command to list all the aliases for that command. Get-Alias -Definition Get-ChildItem Search for a specific alias You can use the -Name parameter followed by a search pattern to find a specific alias or a group of aliases that match the pattern. Get-Alias -Name * s * Export aliases to a file You can use the Export-Alias cmdlet with the -Path parameter followed by the name and location of the file to export the aliases to a file. Get-Alias | Export-Alias -Path C :\\ Aliases . txt Import aliases from a file You can use the Import-Alias cmdlet with the -Path parameter followed by the name and location of the file to import the aliases from a file. Import-Alias -Path C :\\ Aliases . txt Overall, the Get-Alias cmdlet is a powerful tool for managing and customizing your PowerShell experience. It can help you save time and increase your productivity by allowing you to use shorthand commands and aliases that are easier to remember and type. New-Alias In PowerShell, the New-Alias cmdlet is used to create a new alias for a cmdlet, function, or script. The most common usage of New-Alias is to create a shorter, more convenient name for a longer, more complex command that you use frequently. For example, if you use the Get-ChildItem cmdlet frequently to list the contents of a directory, you could create an alias ls that maps to Get-ChildItem. Then, instead of typing Get-ChildItem, you could simply type ls to achieve the same result. This can save you time and typing effort, especially when working with long or complex commands. Here is an example of how to use New-Alias to create an alias: New-Alias -Name ls -Value Get-ChildItem This creates a new alias named ls that maps to the Get-ChildItem cmdlet. You can then use ls to list the contents of a directory, like this: ls C :\\ Windows This will list the contents of the C:\\Windows directory using the Get-ChildItem cmdlet, but you can use the shorter ls alias instead. Another example: new-alias -Name np -Value Notepad Another common use case for New-Alias is to create an alias for a function or script that you use frequently. For example, if you have a script named MyScript.ps1 that you want to run frequently, you could create an alias like this: New-Alias -Name myscript -Value C :\\ Scripts \\ MyScript . ps1 This creates a new alias named myscript that maps to the MyScript.ps1 script located at C:\\Scripts\\MyScript.ps1. You can then use myscript to run the script, like this: myscript This will run the MyScript.ps1 script, but you can use the shorter myscript alias instead. Overall, New-Alias is a useful cmdlet for creating custom aliases that can save you time and typing effort, especially when working with long or complex commands. Set-Alias In PowerShell, the Set-Alias cmdlet is used to change the definition of an existing alias. The most common usage of Set-Alias is to update an existing alias to map to a different cmdlet, function, or script. For example, if you have an alias named ls that currently maps to the Get-ChildItem cmdlet, but you want to change it to map to the Set-Location cmdlet instead, you can use Set-Alias like this: Set-Alias -Name ls -Value Set-Location This changes the definition of the ls alias to map to the Set-Location cmdlet instead of Get-ChildItem. You can then use ls to change to a different directory, like this: ls C :\\ Windows This will change to the C:\\Windows directory using the Set-Location cmdlet, which is now mapped to the ls alias. Another common use case for Set-Alias is to update an alias that was created by a module or script that you are using. For example, if a module that you are using creates an alias named gci that maps to the Get-ChildItem cmdlet, but you want to change it to map to a different cmdlet or function, you can use Set-Alias to update it. Set-Alias -Name gci -Value Get-Content This changes the definition of the gci alias to map to the Get-Content cmdlet instead of Get-ChildItem. You can then use gci to read the contents of a file, like this: gci C :\\ MyFile . txt This will read the contents of the C:\\MyFile.txt file using the Get-Content cmdlet, which is now mapped to the gci alias. Overall, Set-Alias is a useful cmdlet for updating existing aliases to map to different cmdlets, functions, or scripts. This can help you customize your PowerShell environment to better suit your needs and preferences. Other cmdlets In PowerShell, the Import-Alias, Export-Alias, and Remove-Alias cmdlets are used for managing aliases. Here's a brief explanation of each: Import-Alias This cmdlet is used to import a list of aliases from a file or another PowerShell session. It can be useful for setting up a consistent set of aliases across multiple systems or sessions. For example, you could use Import-Alias to load a set of aliases defined in a PowerShell profile or script. Example: Import-Alias -Path C :\\ Aliases \\ MyAliases . txt Export-Alias This cmdlet is used to export a list of aliases to a file or another PowerShell session. It can be useful for backing up or sharing sets of aliases. For example, you could use Export-Alias to save a set of aliases defined on your system and then import them on another system. Example: Export-Alias -Path C :\\ Aliases \\ MyAliases . txt Remove-Alias This cmdlet is used to remove an existing alias. It can be useful for cleaning up aliases that are no longer needed or that are causing conflicts with other aliases or cmdlets. Example: Remove-Alias -Name myAlias Note that when using Remove-Alias, you need to specify the name of the alias you want to remove. If the alias is defined in a PowerShell module or script, you may also need to remove it from those locations in order to fully clean up the alias.","title":"GetAlias"},{"location":"getalias/#get-alias","text":"Get-Alias is a PowerShell cmdlet that is used to display the aliases for cmdlets, functions, and scripts. It allows you to see the built-in aliases that are available in PowerShell, as well as any custom aliases that you or other users have created. Here are some common ways to use Get-Alias: List all aliases You can use the Get-Alias cmdlet without any parameters to list all the aliases available in your PowerShell session. Get-Alias List aliases for a specific command You can use the -Definition parameter followed by the name of the command to list all the aliases for that command. Get-Alias -Definition Get-ChildItem Search for a specific alias You can use the -Name parameter followed by a search pattern to find a specific alias or a group of aliases that match the pattern. Get-Alias -Name * s * Export aliases to a file You can use the Export-Alias cmdlet with the -Path parameter followed by the name and location of the file to export the aliases to a file. Get-Alias | Export-Alias -Path C :\\ Aliases . txt Import aliases from a file You can use the Import-Alias cmdlet with the -Path parameter followed by the name and location of the file to import the aliases from a file. Import-Alias -Path C :\\ Aliases . txt Overall, the Get-Alias cmdlet is a powerful tool for managing and customizing your PowerShell experience. It can help you save time and increase your productivity by allowing you to use shorthand commands and aliases that are easier to remember and type.","title":"Get-Alias"},{"location":"getalias/#new-alias","text":"In PowerShell, the New-Alias cmdlet is used to create a new alias for a cmdlet, function, or script. The most common usage of New-Alias is to create a shorter, more convenient name for a longer, more complex command that you use frequently. For example, if you use the Get-ChildItem cmdlet frequently to list the contents of a directory, you could create an alias ls that maps to Get-ChildItem. Then, instead of typing Get-ChildItem, you could simply type ls to achieve the same result. This can save you time and typing effort, especially when working with long or complex commands. Here is an example of how to use New-Alias to create an alias: New-Alias -Name ls -Value Get-ChildItem This creates a new alias named ls that maps to the Get-ChildItem cmdlet. You can then use ls to list the contents of a directory, like this: ls C :\\ Windows This will list the contents of the C:\\Windows directory using the Get-ChildItem cmdlet, but you can use the shorter ls alias instead. Another example: new-alias -Name np -Value Notepad Another common use case for New-Alias is to create an alias for a function or script that you use frequently. For example, if you have a script named MyScript.ps1 that you want to run frequently, you could create an alias like this: New-Alias -Name myscript -Value C :\\ Scripts \\ MyScript . ps1 This creates a new alias named myscript that maps to the MyScript.ps1 script located at C:\\Scripts\\MyScript.ps1. You can then use myscript to run the script, like this: myscript This will run the MyScript.ps1 script, but you can use the shorter myscript alias instead. Overall, New-Alias is a useful cmdlet for creating custom aliases that can save you time and typing effort, especially when working with long or complex commands.","title":"New-Alias"},{"location":"getalias/#set-alias","text":"In PowerShell, the Set-Alias cmdlet is used to change the definition of an existing alias. The most common usage of Set-Alias is to update an existing alias to map to a different cmdlet, function, or script. For example, if you have an alias named ls that currently maps to the Get-ChildItem cmdlet, but you want to change it to map to the Set-Location cmdlet instead, you can use Set-Alias like this: Set-Alias -Name ls -Value Set-Location This changes the definition of the ls alias to map to the Set-Location cmdlet instead of Get-ChildItem. You can then use ls to change to a different directory, like this: ls C :\\ Windows This will change to the C:\\Windows directory using the Set-Location cmdlet, which is now mapped to the ls alias. Another common use case for Set-Alias is to update an alias that was created by a module or script that you are using. For example, if a module that you are using creates an alias named gci that maps to the Get-ChildItem cmdlet, but you want to change it to map to a different cmdlet or function, you can use Set-Alias to update it. Set-Alias -Name gci -Value Get-Content This changes the definition of the gci alias to map to the Get-Content cmdlet instead of Get-ChildItem. You can then use gci to read the contents of a file, like this: gci C :\\ MyFile . txt This will read the contents of the C:\\MyFile.txt file using the Get-Content cmdlet, which is now mapped to the gci alias. Overall, Set-Alias is a useful cmdlet for updating existing aliases to map to different cmdlets, functions, or scripts. This can help you customize your PowerShell environment to better suit your needs and preferences.","title":"Set-Alias"},{"location":"getalias/#other-cmdlets","text":"In PowerShell, the Import-Alias, Export-Alias, and Remove-Alias cmdlets are used for managing aliases. Here's a brief explanation of each:","title":"Other cmdlets"},{"location":"getalias/#import-alias","text":"This cmdlet is used to import a list of aliases from a file or another PowerShell session. It can be useful for setting up a consistent set of aliases across multiple systems or sessions. For example, you could use Import-Alias to load a set of aliases defined in a PowerShell profile or script. Example: Import-Alias -Path C :\\ Aliases \\ MyAliases . txt","title":"Import-Alias"},{"location":"getalias/#export-alias","text":"This cmdlet is used to export a list of aliases to a file or another PowerShell session. It can be useful for backing up or sharing sets of aliases. For example, you could use Export-Alias to save a set of aliases defined on your system and then import them on another system. Example: Export-Alias -Path C :\\ Aliases \\ MyAliases . txt","title":"Export-Alias"},{"location":"getalias/#remove-alias","text":"This cmdlet is used to remove an existing alias. It can be useful for cleaning up aliases that are no longer needed or that are causing conflicts with other aliases or cmdlets. Example: Remove-Alias -Name myAlias Note that when using Remove-Alias, you need to specify the name of the alias you want to remove. If the alias is defined in a PowerShell module or script, you may also need to remove it from those locations in order to fully clean up the alias.","title":"Remove-Alias"},{"location":"gethelp/","text":"The Get-Help cmdlet is a powerful tool in PowerShell that provides information about commands, cmdlets, and modules. It has several parameters that allow you to customize the help output to suit your needs. Here are some of the most common parameters for the Get-Help cmdlet with examples: 1. -Name This parameter specifies the name of the command or cmdlet that you want help with. For example: Get-Help -Name Get-ChildItem This command will display help for the Get-ChildItem cmdlet, which is used to list the contents of a directory. 2. -Category This parameter specifies the category of help that you want to display. For example: Get-Help -Category Navigation This command will display all cmdlets related to navigation. 3. -Detailed This parameter displays detailed help information, including examples and parameter descriptions. For example: Get-Help -Name Get-ChildItem -Detailed This command will display detailed help information for the Get-ChildItem cmdlet. 4. -Examples This parameter displays examples of how to use the command or cmdlet. For example: Get-Help -Name Get-ChildItem -Examples This command will display examples of how to use the Get-ChildItem cmdlet. 5. -Full This parameter displays the full help information, including syntax and parameter descriptions. For example: Get-Help -Name Get-ChildItem -Full This command will display the full help information for the Get-ChildItem cmdlet. 6. -Parameter This parameter displays help information for a specific parameter of a command or cmdlet. For example: Get-Help -Name Get-ChildItem -Parameter Path This command will display help information for the Path parameter of the Get-ChildItem cmdlet. 7. -Online This parameter opens the online version of the help file for the command or cmdlet. For example: ``` Get-Help -Name Get-ChildItem -Online ``` This command will open the online version of the help file for the Get-ChildItem cmdlet. In summary, the Get-Help cmdlet is a versatile tool that can provide a lot of information about commands, cmdlets, and modules in PowerShell. By using the appropriate parameters, you can customize the help output to suit your needs and become more proficient in PowerShell.","title":"GetHelp"},{"location":"gethelp/#1-name","text":"This parameter specifies the name of the command or cmdlet that you want help with. For example: Get-Help -Name Get-ChildItem This command will display help for the Get-ChildItem cmdlet, which is used to list the contents of a directory.","title":"1. -Name"},{"location":"gethelp/#2-category","text":"This parameter specifies the category of help that you want to display. For example: Get-Help -Category Navigation This command will display all cmdlets related to navigation.","title":"2. -Category"},{"location":"gethelp/#3-detailed","text":"This parameter displays detailed help information, including examples and parameter descriptions. For example: Get-Help -Name Get-ChildItem -Detailed This command will display detailed help information for the Get-ChildItem cmdlet.","title":"3. -Detailed"},{"location":"gethelp/#4-examples","text":"This parameter displays examples of how to use the command or cmdlet. For example: Get-Help -Name Get-ChildItem -Examples This command will display examples of how to use the Get-ChildItem cmdlet.","title":"4. -Examples"},{"location":"gethelp/#5-full","text":"This parameter displays the full help information, including syntax and parameter descriptions. For example: Get-Help -Name Get-ChildItem -Full This command will display the full help information for the Get-ChildItem cmdlet.","title":"5. -Full"},{"location":"gethelp/#6-parameter","text":"This parameter displays help information for a specific parameter of a command or cmdlet. For example: Get-Help -Name Get-ChildItem -Parameter Path This command will display help information for the Path parameter of the Get-ChildItem cmdlet.","title":"6. -Parameter"},{"location":"gethelp/#7-online","text":"This parameter opens the online version of the help file for the command or cmdlet. For example: ``` Get-Help -Name Get-ChildItem -Online ``` This command will open the online version of the help file for the Get-ChildItem cmdlet. In summary, the Get-Help cmdlet is a versatile tool that can provide a lot of information about commands, cmdlets, and modules in PowerShell. By using the appropriate parameters, you can customize the help output to suit your needs and become more proficient in PowerShell.","title":"7. -Online"},{"location":"out_format/","text":"Here is a detailed table of the most common cmdlets available for reading and writing files in different formats in PowerShell: File Format Cmdlet for Reading Cmdlet for Writing Text Files (.txt) Get-Content Set-Content CSV Files (.csv) Import-Csv Export-Csv JSON Files (.json) ConvertFrom-Json ConvertTo-Json XML Files (.xml) Select-Xml Export-Clixml HTML Files Get-Content ConvertTo-Html Here are some examples of how to use these cmdlets: Text Get-Content The Get-Content cmdlet gets the content of the item at the location specified by the path, such as the text in a file or the content of a function. For files, the content is read one line at a time and returns a collection of objects, each of which represents a line of content. Beginning in PowerShell 3.0, Get-Content can also get a specified number of lines from the beginning or end of an item. $computers = Get-Content C :\\ Scripts \\ computers . txt You can use wildcards in the path for Get-Content to obtain data from multiple files at a time. When you use wildcards for the path, you can modify the files selected by using the -Include and -Exclude parameters. When you use -Include, only the specified patterns are included. When you use -Exclude, all files are included except the patterns specified. Using wildcards can be useful when you want to scan all text files for specific content such as an error in log files. Get-Content -Path \"C:\\Scripts\\*\" -Include \"*.txt\" , \"*.log\" You can limit the amount of data that you retrieve with Get-Content by using the -TotalCount and -Tail parameters. The -TotalCount parameter specifies how many lines should be retrieved from the beginning of a file. The -Tail parameter specifies how many lines to retrieve from the end of a file. Get-Content C :\\ Scripts \\ computers . txt -TotalCount 10 Set-Content Set-Content is a string-processing cmdlet that writes new content or replaces the content in a file. Set-Content replaces the existing content and differs from the Add-Content cmdlet that appends content to a file. To send content to Set-Content you can use the Value parameter on the command line or send content through the pipeline. If you need to create files or directories for the following examples, see New-Item. Set-Content C :\\ example . txt \"This is some text.\" This command will write the text \"This is some text\" to the file file.txt located in the C:\\ directory. If the file already exists, its content will be overwritten. If the file does not exist, it will be created. Add-Content The Add-Content cmdlet appends content to a specified item or file. You can specify the content by typing the content in the command or by specifying an object that contains the content. If you need to create files or directories for the following examples, see New-Item. Add-Content -Path .\\*. txt -Exclude help * -Value 'End of file' The Path parameter specifies all .txt files in the current directory, but the Exclude parameter ignores file names that match the specified pattern. The Value parameter specifies the text string that is written to the files. Use Get-Content to display the contents of these files. Clear-Content The Clear-Content cmdlet deletes the contents of an item, such as deleting the text from a file, but it does not delete the item. As a result, the item exists, but it is empty. Clear-Content is similar to Clear-Item, but it works on items with contents, instead of items with values. Clear-Content \"..\\SmpUsers\\*\\init.txt\" This command deletes all of the content from the init.txt files in all subdirectories of the SmpUsers directory. The files are not deleted, but they are empty. CSV A CSV (Comma Separated Values) file is a plain text file format that stores tabular data in a simple, structured way, where each line represents a row, and the data within each row is separated by commas. The first line of the file usually contains the headers, which specify the column names. When working with CSV files in PowerShell, it's important to keep in mind that the file format is very simple and flexible, but can also be prone to errors if the data is not well-formed. It's important to validate and clean the data before working with it, and to always specify the correct headers and data types when importing or exporting CSV files. I/O Import-Csv C :\\ example . csv Import-CSV This cmdlet reads a CSV file and creates custom objects for each row, using the headers as the property names. You can then work with these objects as you would with any other PowerShell object. Here's an example: $csv = Import-CSV C :\\ data \\ users . csv foreach ( $user in $csv ) { Write-Output $user . Name } This code imports a CSV file containing user data, and then outputs the Name property of each user object. Export-CSV $data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | Export-Csv C :\\ example . csv -NoTypeInformation This cmdlet writes a collection of objects to a CSV file, using the object properties as the column names. Here's an example: $users = Get-ADUser -Filter * $users | Select-Object Name , EmailAddress | Export-CSV C :\\ data \\ users . csv -NoTypeInformation This code retrieves all users from Active Directory, selects the Name and EmailAddress properties, and then exports them to a CSV file. Conversion To/From ConvertTo-CSV This cmdlet converts a collection of objects to a CSV format, but does not write it to a file. You can then use other cmdlets (like Out-File or Set-Content) to write the CSV to a file. Here's an example: $processes = Get-Process $processes | Select-Object Name , ID , CPU | ConvertTo-CSV | Out-File C :\\ data \\ processes . csv This code retrieves information about running processes, selects the Name, ID, and CPU properties, converts it to CSV format, and then writes it to a file. Here's another example of how to use ConvertTo-CSV: # Create an array of objects $people = @( [PSCustomObject] @{ Name = \"John\" Age = 35 Occupation = \"Software Engineer\" }, [PSCustomObject] @{ Name = \"Jane\" Age = 28 Occupation = \"Project Manager\" } ) # Convert the objects to CSV format $csv = $people | ConvertTo-CSV # Output the CSV data $csv In this example, we first create an array of custom objects representing people with different attributes like name, age, and occupation. We then pipe this array to the ConvertTo-CSV cmdlet to convert it to CSV format and store the output in a variable called $csv. Finally, we output the CSV data using the $csv variable. ConvertFrom-CSV ConvertFrom-CSV is a cmdlet that allows you to convert CSV data back into PowerShell objects. This cmdlet takes the input CSV data, converts it into PowerShell objects, and outputs the objects. Here's an example of how to use ConvertFrom-CSV: # Convert CSV data to PowerShell objects $csvData = @\" Name,Age,Occupation John,35,Software Engineer Jane,28,Project Manager \"@ | ConvertFrom-CSV # Output the objects $csvData In this example, we first define a CSV string containing data about people, with each person represented as a row with columns for name, age, and occupation. We then pipe this CSV string to the ConvertFrom-CSV cmdlet to convert it into PowerShell objects and store the output in a variable called $csvData. Finally, we output the objects using the $csvData variable. JSON JavaScript Object Notation (JSON) is a lightweight data format that's similar to XML, because it can represent multiple layers of data. JSON is a lightweight data-interchange format compared to XML because of its simpler syntax. Windows PowerShell doesn't include cmdlets that import or export JSON data directly from a file. Instead, if you have JSON data stored in a file, you can retrieve the data by using Get-Content and then convert the data by using the ConvertFrom-Json cmdlet. Reading a JSON file $json = Get-Content .\\ example . json | ConvertFrom-Json Writing to a JSON file $data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | ConvertTo-Json | Out-File .\\ example . json Testing a JSON file \"{'name': 'Ashley', 'age': 25}\" | Test-Json XML XML is a more complex data storage format than CSV files. The main advantage of using XML for Windows PowerShell is that it can hold multiple levels of data. A CSV file works with a table of information in which the columns are the object properties. In a CSV file, it's difficult to work with multivalued attributes, whereas XML can easily represent multivalued attributes or even objects that have other objects as a property. Reading an XML file The use of Import-Clixml to retrieve data from an XML file creates an array of objects. Because XML can be complex, you might not easily be able to understand the object properties by reviewing the contents of the XML file directly. You can use Get-Member to identify the properties of the data that you import. $users = Import-Clixml C :\\ Scripts \\ Users . xml You can limit the data retrieved by Import-Clixml by using the -First and -Skip parameters. The -First parameter specifies to retrieve only the specified number of objects from the beginning of the XML file. The -Skip parameter specifies to ignore the specified number of objects from the beginning of the XML file and to retrieve all the remaining objects. $xml = Select-Xml -Path C :\\ example . xml -XPath \"//book\" Writing to an XML file $data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | Export-Clixml C :\\ example . xml HTML PowerShell provides a variety of cmdlets that can be used to manipulate HTML files, such as Invoke-WebRequest, Invoke-RestMethod, and ConvertTo-Html. Here are some examples of how to use these cmdlets to manipulate HTML files in PowerShell: Downloading an HTML file using Invoke-WebRequest: Invoke-WebRequest -Uri https :// example . com -OutFile example . html Extracting data from an HTML file using Invoke-RestMethod: $response = Invoke-RestMethod -Uri https :// example . com $response . Tables [ 0 ] | ConvertTo-Html -Fragment Converting a PowerShell object to an HTML table using ConvertTo-Html: Get-Process | Select-Object Name , CPU , WorkingSet | ConvertTo-Html -Head \"Process Report\" -PreContent \"<h1>Current Processes</h1>\" These are just a few examples of how to manipulate HTML files in PowerShell. The possibilities are endless, and these cmdlets can be combined with other PowerShell commands to perform more complex tasks. ConvertTo-Html creates a simple list or table that's coded as HTML. You can control the HTML format in a limited way through a variety of parameters, such as: \u2011Head. Specifies the content of an HTML head section. \u2011Title. Sets the value of the HTML title tag. \u2011PreContent. Defines any content that should display before the table or list output. \u2011PostContent. Defines any content that should display after the table or list output. OUTPUT TO FILE OR PRINTER If you want to save the output of a command to an unformatted plain text file, you can use either of these methods (using the get-process command as an example): get-process > processes.txt (using redirection) get-process | out-file processes.txt (using the pipeline) Both versions are functionally equivalent, but the out-file command can receive parameters to change the line width and to avoid overwriting an existing file. To read a plain text file as text strings, you use the Get-Content cmdlet (with aliases cat or type): Get-Content processes . txt PowerShell also supports the text redirection operators (> and >>) that cmd.exe uses. These operators act as an alias for Out-File. The greater than sign (>) at the end of a pipeline directs output to a file, overwriting the content. Two consecutive greater than signs (>>) direct output to a file, appending the output to any text already in the file. Out-File is the easiest way to move data from PowerShell to external storage. However, the text files that Out-File creates are usually intended for reviewing by a person. Therefore, reading the data back into Windows PowerShell in a way that enables data manipulation, sorting, selection, and measurement is frequently difficult or impractical. Out-File doesn't produce any output of its own, which means that the command doesn't put objects into the pipeline. After you run the command, you should expect no output on the screen. If you want to send the output of a command to the printer, you use the out-printer cmdlet: get-process | out-printer","title":"Output Format"},{"location":"out_format/#text","text":"","title":"Text"},{"location":"out_format/#get-content","text":"The Get-Content cmdlet gets the content of the item at the location specified by the path, such as the text in a file or the content of a function. For files, the content is read one line at a time and returns a collection of objects, each of which represents a line of content. Beginning in PowerShell 3.0, Get-Content can also get a specified number of lines from the beginning or end of an item. $computers = Get-Content C :\\ Scripts \\ computers . txt You can use wildcards in the path for Get-Content to obtain data from multiple files at a time. When you use wildcards for the path, you can modify the files selected by using the -Include and -Exclude parameters. When you use -Include, only the specified patterns are included. When you use -Exclude, all files are included except the patterns specified. Using wildcards can be useful when you want to scan all text files for specific content such as an error in log files. Get-Content -Path \"C:\\Scripts\\*\" -Include \"*.txt\" , \"*.log\" You can limit the amount of data that you retrieve with Get-Content by using the -TotalCount and -Tail parameters. The -TotalCount parameter specifies how many lines should be retrieved from the beginning of a file. The -Tail parameter specifies how many lines to retrieve from the end of a file. Get-Content C :\\ Scripts \\ computers . txt -TotalCount 10","title":"Get-Content"},{"location":"out_format/#set-content","text":"Set-Content is a string-processing cmdlet that writes new content or replaces the content in a file. Set-Content replaces the existing content and differs from the Add-Content cmdlet that appends content to a file. To send content to Set-Content you can use the Value parameter on the command line or send content through the pipeline. If you need to create files or directories for the following examples, see New-Item. Set-Content C :\\ example . txt \"This is some text.\" This command will write the text \"This is some text\" to the file file.txt located in the C:\\ directory. If the file already exists, its content will be overwritten. If the file does not exist, it will be created.","title":"Set-Content"},{"location":"out_format/#add-content","text":"The Add-Content cmdlet appends content to a specified item or file. You can specify the content by typing the content in the command or by specifying an object that contains the content. If you need to create files or directories for the following examples, see New-Item. Add-Content -Path .\\*. txt -Exclude help * -Value 'End of file' The Path parameter specifies all .txt files in the current directory, but the Exclude parameter ignores file names that match the specified pattern. The Value parameter specifies the text string that is written to the files. Use Get-Content to display the contents of these files.","title":"Add-Content"},{"location":"out_format/#clear-content","text":"The Clear-Content cmdlet deletes the contents of an item, such as deleting the text from a file, but it does not delete the item. As a result, the item exists, but it is empty. Clear-Content is similar to Clear-Item, but it works on items with contents, instead of items with values. Clear-Content \"..\\SmpUsers\\*\\init.txt\" This command deletes all of the content from the init.txt files in all subdirectories of the SmpUsers directory. The files are not deleted, but they are empty.","title":"Clear-Content"},{"location":"out_format/#csv","text":"A CSV (Comma Separated Values) file is a plain text file format that stores tabular data in a simple, structured way, where each line represents a row, and the data within each row is separated by commas. The first line of the file usually contains the headers, which specify the column names. When working with CSV files in PowerShell, it's important to keep in mind that the file format is very simple and flexible, but can also be prone to errors if the data is not well-formed. It's important to validate and clean the data before working with it, and to always specify the correct headers and data types when importing or exporting CSV files.","title":"CSV"},{"location":"out_format/#io","text":"Import-Csv C :\\ example . csv","title":"I/O"},{"location":"out_format/#import-csv","text":"This cmdlet reads a CSV file and creates custom objects for each row, using the headers as the property names. You can then work with these objects as you would with any other PowerShell object. Here's an example: $csv = Import-CSV C :\\ data \\ users . csv foreach ( $user in $csv ) { Write-Output $user . Name } This code imports a CSV file containing user data, and then outputs the Name property of each user object.","title":"Import-CSV"},{"location":"out_format/#export-csv","text":"$data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | Export-Csv C :\\ example . csv -NoTypeInformation This cmdlet writes a collection of objects to a CSV file, using the object properties as the column names. Here's an example: $users = Get-ADUser -Filter * $users | Select-Object Name , EmailAddress | Export-CSV C :\\ data \\ users . csv -NoTypeInformation This code retrieves all users from Active Directory, selects the Name and EmailAddress properties, and then exports them to a CSV file.","title":"Export-CSV"},{"location":"out_format/#conversion-tofrom","text":"","title":"Conversion To/From"},{"location":"out_format/#convertto-csv","text":"This cmdlet converts a collection of objects to a CSV format, but does not write it to a file. You can then use other cmdlets (like Out-File or Set-Content) to write the CSV to a file. Here's an example: $processes = Get-Process $processes | Select-Object Name , ID , CPU | ConvertTo-CSV | Out-File C :\\ data \\ processes . csv This code retrieves information about running processes, selects the Name, ID, and CPU properties, converts it to CSV format, and then writes it to a file. Here's another example of how to use ConvertTo-CSV: # Create an array of objects $people = @( [PSCustomObject] @{ Name = \"John\" Age = 35 Occupation = \"Software Engineer\" }, [PSCustomObject] @{ Name = \"Jane\" Age = 28 Occupation = \"Project Manager\" } ) # Convert the objects to CSV format $csv = $people | ConvertTo-CSV # Output the CSV data $csv In this example, we first create an array of custom objects representing people with different attributes like name, age, and occupation. We then pipe this array to the ConvertTo-CSV cmdlet to convert it to CSV format and store the output in a variable called $csv. Finally, we output the CSV data using the $csv variable.","title":"ConvertTo-CSV"},{"location":"out_format/#convertfrom-csv","text":"ConvertFrom-CSV is a cmdlet that allows you to convert CSV data back into PowerShell objects. This cmdlet takes the input CSV data, converts it into PowerShell objects, and outputs the objects. Here's an example of how to use ConvertFrom-CSV: # Convert CSV data to PowerShell objects $csvData = @\" Name,Age,Occupation John,35,Software Engineer Jane,28,Project Manager \"@ | ConvertFrom-CSV # Output the objects $csvData In this example, we first define a CSV string containing data about people, with each person represented as a row with columns for name, age, and occupation. We then pipe this CSV string to the ConvertFrom-CSV cmdlet to convert it into PowerShell objects and store the output in a variable called $csvData. Finally, we output the objects using the $csvData variable.","title":"ConvertFrom-CSV"},{"location":"out_format/#json","text":"JavaScript Object Notation (JSON) is a lightweight data format that's similar to XML, because it can represent multiple layers of data. JSON is a lightweight data-interchange format compared to XML because of its simpler syntax. Windows PowerShell doesn't include cmdlets that import or export JSON data directly from a file. Instead, if you have JSON data stored in a file, you can retrieve the data by using Get-Content and then convert the data by using the ConvertFrom-Json cmdlet.","title":"JSON"},{"location":"out_format/#reading-a-json-file","text":"$json = Get-Content .\\ example . json | ConvertFrom-Json","title":"Reading a JSON file"},{"location":"out_format/#writing-to-a-json-file","text":"$data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | ConvertTo-Json | Out-File .\\ example . json","title":"Writing to a JSON file"},{"location":"out_format/#testing-a-json-file","text":"\"{'name': 'Ashley', 'age': 25}\" | Test-Json","title":"Testing a JSON file"},{"location":"out_format/#xml","text":"XML is a more complex data storage format than CSV files. The main advantage of using XML for Windows PowerShell is that it can hold multiple levels of data. A CSV file works with a table of information in which the columns are the object properties. In a CSV file, it's difficult to work with multivalued attributes, whereas XML can easily represent multivalued attributes or even objects that have other objects as a property.","title":"XML"},{"location":"out_format/#reading-an-xml-file","text":"The use of Import-Clixml to retrieve data from an XML file creates an array of objects. Because XML can be complex, you might not easily be able to understand the object properties by reviewing the contents of the XML file directly. You can use Get-Member to identify the properties of the data that you import. $users = Import-Clixml C :\\ Scripts \\ Users . xml You can limit the data retrieved by Import-Clixml by using the -First and -Skip parameters. The -First parameter specifies to retrieve only the specified number of objects from the beginning of the XML file. The -Skip parameter specifies to ignore the specified number of objects from the beginning of the XML file and to retrieve all the remaining objects. $xml = Select-Xml -Path C :\\ example . xml -XPath \"//book\"","title":"Reading an XML file"},{"location":"out_format/#writing-to-an-xml-file","text":"$data = @{ \"Name\" = \"John\" ; \"Age\" = 30 } $data | Export-Clixml C :\\ example . xml","title":"Writing to an XML file"},{"location":"out_format/#html","text":"PowerShell provides a variety of cmdlets that can be used to manipulate HTML files, such as Invoke-WebRequest, Invoke-RestMethod, and ConvertTo-Html. Here are some examples of how to use these cmdlets to manipulate HTML files in PowerShell: Downloading an HTML file using Invoke-WebRequest: Invoke-WebRequest -Uri https :// example . com -OutFile example . html Extracting data from an HTML file using Invoke-RestMethod: $response = Invoke-RestMethod -Uri https :// example . com $response . Tables [ 0 ] | ConvertTo-Html -Fragment Converting a PowerShell object to an HTML table using ConvertTo-Html: Get-Process | Select-Object Name , CPU , WorkingSet | ConvertTo-Html -Head \"Process Report\" -PreContent \"<h1>Current Processes</h1>\" These are just a few examples of how to manipulate HTML files in PowerShell. The possibilities are endless, and these cmdlets can be combined with other PowerShell commands to perform more complex tasks. ConvertTo-Html creates a simple list or table that's coded as HTML. You can control the HTML format in a limited way through a variety of parameters, such as: \u2011Head. Specifies the content of an HTML head section. \u2011Title. Sets the value of the HTML title tag. \u2011PreContent. Defines any content that should display before the table or list output. \u2011PostContent. Defines any content that should display after the table or list output.","title":"HTML"},{"location":"out_format/#output-to-file-or-printer","text":"If you want to save the output of a command to an unformatted plain text file, you can use either of these methods (using the get-process command as an example): get-process > processes.txt (using redirection) get-process | out-file processes.txt (using the pipeline) Both versions are functionally equivalent, but the out-file command can receive parameters to change the line width and to avoid overwriting an existing file. To read a plain text file as text strings, you use the Get-Content cmdlet (with aliases cat or type): Get-Content processes . txt PowerShell also supports the text redirection operators (> and >>) that cmd.exe uses. These operators act as an alias for Out-File. The greater than sign (>) at the end of a pipeline directs output to a file, overwriting the content. Two consecutive greater than signs (>>) direct output to a file, appending the output to any text already in the file. Out-File is the easiest way to move data from PowerShell to external storage. However, the text files that Out-File creates are usually intended for reviewing by a person. Therefore, reading the data back into Windows PowerShell in a way that enables data manipulation, sorting, selection, and measurement is frequently difficult or impractical. Out-File doesn't produce any output of its own, which means that the command doesn't put objects into the pipeline. After you run the command, you should expect no output on the screen. If you want to send the output of a command to the printer, you use the out-printer cmdlet: get-process | out-printer","title":"OUTPUT TO FILE OR PRINTER"},{"location":"pipeline/","text":"The pipeline in PowerShell is a feature that allows you to take the output of one command and pass it as input to another command. This makes it possible to create more complex commands by chaining simple commands together. The pipeline operator, represented by the \"|\" character, is used to connect commands together. When using the Windows PowerShell pipeline, you can pass data through the pipeline and perform operations on it. This capability lets you perform many bulk operations such as: Querying a list of objects. Filtering the objects. Modifying the objects. Displaying the data. Here are some examples of how to use the pipeline in PowerShell: Example 1: Get-ChildItem and Select-Object The Get-ChildItem command is used to list the files and folders in a specified directory. The Select-Object command is used to select specific properties of the objects returned by Get-ChildItem. By using the pipeline, you can pass the output of Get-ChildItem to Select-Object to filter the results. Get-ChildItem | Select-Object Name , Length , LastWriteTime This command lists the files and folders in the current directory and then selects the Name, Length, and LastWriteTime properties of each item. Example 2: Get-Process and Sort-Object The Get-Process command is used to list the running processes on a system. The Sort-Object command is used to sort the results based on a specific property. By using the pipeline, you can pass the output of Get-Process to Sort-Object to sort the results by CPU usage. Get-Process | Sort-Object CPU -Descending This command lists the running processes and then sorts them in descending order based on their CPU usage. Example 3: Get-Service and Where-Object The Get-Service command is used to list the services on a system. The Where-Object command is used to filter the results based on a specific condition. By using the pipeline, you can pass the output of Get-Service to Where-Object to filter the results to only show services that are currently running. Get-Service | Where-Object Status -eq \"Running\" This command lists all of the services on the system and then filters the results to only show services that have a Status property equal to \"Running\". In each of these examples, the pipeline is used to pass the output of one command to another command. This allows you to create more powerful commands by combining simple commands together. Order & Selection The pipeline can be used to select properties of objects that are not displayed by default when using a cmdlet. It can also be used to filter results (using search criteria). To sort, the Sort-Object cmdlet (abbreviated sort) is used, and to select properties, Select-Object (abbreviated select) is used. For example, the process list is normally displayed in alphabetical order by process name. To sort it by Process ID, the command is: get-process | sort id To sort it by virtual memory usage in descending order: get-process | sort vm -desc Note that in this last example, it is sorting by a field that is not normally displayed on the screen. To change the fields that are displayed, select is used: get-process | select -property id , name , vm | sort vm -desc This example shows a table with the identifier, name, and virtual memory usage of the machine's processes, ordered in descending order by virtual memory usage. Remember that to view the properties of an object (the fields that can be displayed), the Get-Member cmdlet (abbreviated gm) is used: Get-Process | gm Best Practice : Always review the property names in the output of Get-Member before you use those property names in another command. By doing this, you can help to ensure that you use the actual property names and not ones created for display purposes. Passing parameters In a pipeline of the type: Command_A | Command_B ...parameters can be passed in two ways: By value (ByValue) In this case, PowerShell analyzes the output type of Command_A and determines which parameter of Command_B can receive this output. Example: Analyzing the command Get-Process | Stop-Process In this case, Get-Process produces Process type objects. Examining the help for Stop-Process, the following parameter is found: -InputObject <Process[]> Specifies the process objects to stop. Enter a variable that contains the objects, or type a command or expression that gets the objects. Required? true Position? 0 Default value None Accept pipeline input? True (ByValue) Accept wildcard characters? false As you can see, this parameter can receive values from the pipeline, using the ByValue method. For this reason, the command works. If you try to connect two commands to the pipeline that do not have compatible output and parameter types, an error occurs. It can also happen that data is passed through the wrong parameter. For example, suppose the file computers.txt contains the names of several computers, and you want to display the list of services on each of these computers. You could use the command: Get-Content computers . txt | get-service This command produces an error because the required parameter (ComputerName) does not accept input through the pipeline using the ByValue method. The command can then be executed using parentheses: get-service -computername ( get-content computers . txt ) When data is passed using ByValue, a parameter can accept complete objects from the pipeline when those objects are of the type that the parameter accepts. A single command can have more than one parameter accepting pipeline input ByValue, but each parameter must accept a different kind of object. For example, Get-Service can accept pipeline input ByValue on both its \u2013InputObject and \u2013Name parameters. Each of those parameters accepts a different kind of object. \u2013InputObject accepts objects of the type ServiceController, and \u2013Name accepts objects of the type String. Consider the following example: 'BITS' , 'WinRM' | Get-Service Here, two string objects are piped into Get-Service. They attach to the \u2013Name parameter because that parameter accepts that kind of object, ByValue, from the pipeline. Generic object types Windows PowerShell recognizes two generic kinds of object, Object and PSObject. Parameters that accept these kinds of objects can accept any kind of object. When you perform ByValue pipeline parameter binding, Windows PowerShell first looks for the most specific object type possible. If the pipeline contains a String, and a parameter can accept String, that parameter will receive the objects. If there's no match for a specific data type, Windows PowerShell will try to match generic data types. That behavior is why commands like Sort-Object and Select-Object work. Each of those commands has a parameter named \u2013InputObject that accepts objects of the type PSObject from the pipeline ByValue. This is why you can pipe any type of object to those commands. Their \u2013InputObject parameter will receive any object from the pipeline because it accepts objects of any kind. By parameter name (ByPropertyName) If Windows PowerShell is unable to bind pipeline input by using the ByValue technique, it tries to use the ByPropertyName technique. When Windows PowerShell uses the ByPropertyName technique, it attempts to match a property of the object passed to a parameter of the command to which the object was passed. This match occurs in a simple manner. If the input object has a Name property, it will be matched with the parameter Name because they're spelled the same. However, it will only pass the property if the parameter is programmed to accept a value by property name. This means that you can pass output from one command to another when they don't logically go together. In this method, you must specify the parameter names. For example, consider a file called alias.txt with the following content: Name,Value np,notepad sel,Select-Object go,Invoke-Command The idea is to use the contents of this file to input it to the new-alias command and create the aliases listed in the file. Note that the first line of the file corresponds to the column headers. If this file is imported with Import-Csv, the following is obtained: PS C :\\ Users \\ Usuario \\ powershell > Import-Csv .\\ alias . txt Name Value ---- ----- np notepad sel Select-Object go Invoke-Command If you use Get-Member to analyze this output, you get: TypeName: System.Management.Automation.PSCustomObject Name MemberType Definition ---- ---------- ---------- Equals Method bool Equals(System.Object obj) GetHashCode Method int GetHashCode() GetType Method type GetType() ToString Method string ToString() Name NoteProperty string Name=np Value NoteProperty string Value=notepad It can be seen that the last two properties are of type String. Let's now analyze the parameters of the New-Alias command: New-Alias [-Name] <String> [-Value] <String> [-Confirm] [-Description <String>] [-Force] [-Option {None | ReadOnly | Constant | Private | AllScope | Unspecified}] [-PassThru] [-Scope <String>] [-WhatIf] [<CommonParameters>] The Name and Value parameters receive String inputs. And if you review the complete help, you can verify that both parameters receive values through the pipeline using the ByPropertyName mode: -Name <String> Specifies the new alias. You can use any alphanumeric characters in an alias, but the first character cannot be a number. Required? true Position? 0 Default value None Accept pipeline input? True (ByPropertyName) Accept wildcard characters? false -Value <String> Specifies the name of the cmdlet or command element that is being aliased. Required? true Position? 1 Default value None Accept pipeline input? True (ByPropertyName) Accept wildcard characters? false Therefore, information can be passed from one command to another in the following way: import-csv alias . txt | new-alias Renaming properties Most often, a property name from an output object doesn't match the name of an input parameter exactly. You can change the name of the property by using Select-Object and create a calculated property. For example, to view the processes running on all computers in your Windows Server Active Directory, try running the following command: Get-ADComputer -Filter * | Get-Process However, this command doesn't work. No parameter for Get-Process matches a property name for the output of Get-ADComputer. View the output of Get-ADComputer | Get-Member and Get-Help Get-Process and you'll see that what you want is to match the Name property of Get-ADComputer with the -ComputerName parameter of Get-Process. You can do that by using Select-Object and changing the property name for the Get-ADComputer command\u2019s Name property to ComputerName, and then passing the results to Get-Process. The following command will work: Get-ADComputer -Filter * | Select-Object @{ n = 'ComputerName' ; e ={ $PSItem . Name }} | Get-Process Remember: Windows PowerShell will always try ByValue first and will use ByPropertyName only if ByValue fails. Parenthetical Commands Another option for passing the results of one command to the parameters of another is by using parenthetical commands. A parenthetical command is a command that is enclosed in parentheses. Just as in math, parentheses tell Windows PowerShell to execute the enclosed command first. The parenthetical command runs, and the results of the command are inserted in its place. You can use parenthetical commands to pass values to parameters that do not accept pipeline input. This means you can have a pipeline that includes data inputs from multiple sources. Consider the following command: Get-ADGroup \"London Users\" | Add-ADGroupMember -Members ( Get-ADUser -Filter { City -eq 'London' }) In this example, output of Get-ADGroup passes to Add-ADGroupMember, telling it which group to modify. However, that is only part of the information needed. We also need to tell Add-ADGroupMember what users to add to the group. The -Members parameter does not accept piped input, and even if it did, we have already piped data to the command. Therefore, we need to use a parenthetical command to provide a list of users that we want added to the group. Parenthetical commands do not rely on pipeline parameter binding. They work with any parameter if the parenthetical command produces the kind of object that the parameter expects. Expand Property Values You can use parenthetical commands to provide parameter input without using the pipeline. In some cases, however, you might have to manipulate the objects produced by a parenthetical command so that the command\u2019s output is of the type that the parameter requires. For example, you might want to list all the processes that are running on every computer in the domain. In this example, imagine that you have a very small lab domain that contains just a few computers. You can get a list of every computer in the domain by running the following command: Get-ADComputer \u2013 Filter * However, this command produces objects of the type ADComputer. You couldn't use those objects directly in a parenthetical command such as in the following command: Get-Process \u2013 ComputerName ( Get-ADComputer \u2013 Filter *) The \u2013ComputerName parameter expects objects of the type String. However, the parenthetical command doesn't produce String type objects. The \u2013ComputerName parameter only wants a computer name. However, the command provides it an object that contains a name, an operating system version, and several other properties. You could try the following command: Get-Process \u2013 ComputerName ( Get-ADComputer \u2013 Filter * | Select-Object \u2013 Property Name ) This command selects only the Name property. This property is still a member of a whole ADComputer object. It's the Name property of an object. Although the Name property contains a string, it isn't itself a string. The \u2013ComputerName parameter expects a string, not an object with a property. Therefore, that command doesn't work either. The following command achieves the goal of passing the computer name as a string to the -ComputerName parameter: Get-Process \u2013 ComputerName ( Get-ADComputer \u2013 Filter * | Select-Object \u2013 ExpandProperty Name ) The \u2013ExpandProperty parameter accepts one, and only one, property name. When you use that parameter, only the contents of the specified property are produced by Select-Object. Some people refer to this feature as extracting the property contents. The official description of the feature is expanding the property contents. In the preceding command, the result of the parenthetical command is a collection of strings that are passed as individual strings, not an array, and that is what the \u2013ComputerName parameter expects. The command will work correctly; however, it might produce an error if one or more of the computers can't be reached on the network. Expanding property values also works when piping output. Consider the following example: Get-ADUser Ty -Properties MemberOf | Get-ADGroup This command returns an error because Windows PowerShell can't match the MemberOf property to any property of Get-ADGroup. However, if you expand the value of the MemberOf property, as in the following example, Windows PowerShell can match the resulting output to a value that Get-ADGroup understands as valid input: Get-ADUser Ty -Properties MemberOf | Select-Object -ExpandProperty MemberOf | Get-ADGroup","title":"Pipeline"},{"location":"pipeline/#order-selection","text":"The pipeline can be used to select properties of objects that are not displayed by default when using a cmdlet. It can also be used to filter results (using search criteria). To sort, the Sort-Object cmdlet (abbreviated sort) is used, and to select properties, Select-Object (abbreviated select) is used. For example, the process list is normally displayed in alphabetical order by process name. To sort it by Process ID, the command is: get-process | sort id To sort it by virtual memory usage in descending order: get-process | sort vm -desc Note that in this last example, it is sorting by a field that is not normally displayed on the screen. To change the fields that are displayed, select is used: get-process | select -property id , name , vm | sort vm -desc This example shows a table with the identifier, name, and virtual memory usage of the machine's processes, ordered in descending order by virtual memory usage. Remember that to view the properties of an object (the fields that can be displayed), the Get-Member cmdlet (abbreviated gm) is used: Get-Process | gm Best Practice : Always review the property names in the output of Get-Member before you use those property names in another command. By doing this, you can help to ensure that you use the actual property names and not ones created for display purposes.","title":"Order &amp; Selection"},{"location":"pipeline/#passing-parameters","text":"In a pipeline of the type: Command_A | Command_B ...parameters can be passed in two ways:","title":"Passing parameters"},{"location":"pipeline/#by-value-byvalue","text":"In this case, PowerShell analyzes the output type of Command_A and determines which parameter of Command_B can receive this output. Example: Analyzing the command Get-Process | Stop-Process In this case, Get-Process produces Process type objects. Examining the help for Stop-Process, the following parameter is found: -InputObject <Process[]> Specifies the process objects to stop. Enter a variable that contains the objects, or type a command or expression that gets the objects. Required? true Position? 0 Default value None Accept pipeline input? True (ByValue) Accept wildcard characters? false As you can see, this parameter can receive values from the pipeline, using the ByValue method. For this reason, the command works. If you try to connect two commands to the pipeline that do not have compatible output and parameter types, an error occurs. It can also happen that data is passed through the wrong parameter. For example, suppose the file computers.txt contains the names of several computers, and you want to display the list of services on each of these computers. You could use the command: Get-Content computers . txt | get-service This command produces an error because the required parameter (ComputerName) does not accept input through the pipeline using the ByValue method. The command can then be executed using parentheses: get-service -computername ( get-content computers . txt ) When data is passed using ByValue, a parameter can accept complete objects from the pipeline when those objects are of the type that the parameter accepts. A single command can have more than one parameter accepting pipeline input ByValue, but each parameter must accept a different kind of object. For example, Get-Service can accept pipeline input ByValue on both its \u2013InputObject and \u2013Name parameters. Each of those parameters accepts a different kind of object. \u2013InputObject accepts objects of the type ServiceController, and \u2013Name accepts objects of the type String. Consider the following example: 'BITS' , 'WinRM' | Get-Service Here, two string objects are piped into Get-Service. They attach to the \u2013Name parameter because that parameter accepts that kind of object, ByValue, from the pipeline.","title":"By value (ByValue)"},{"location":"pipeline/#generic-object-types","text":"Windows PowerShell recognizes two generic kinds of object, Object and PSObject. Parameters that accept these kinds of objects can accept any kind of object. When you perform ByValue pipeline parameter binding, Windows PowerShell first looks for the most specific object type possible. If the pipeline contains a String, and a parameter can accept String, that parameter will receive the objects. If there's no match for a specific data type, Windows PowerShell will try to match generic data types. That behavior is why commands like Sort-Object and Select-Object work. Each of those commands has a parameter named \u2013InputObject that accepts objects of the type PSObject from the pipeline ByValue. This is why you can pipe any type of object to those commands. Their \u2013InputObject parameter will receive any object from the pipeline because it accepts objects of any kind.","title":"Generic object types"},{"location":"pipeline/#by-parameter-name-bypropertyname","text":"If Windows PowerShell is unable to bind pipeline input by using the ByValue technique, it tries to use the ByPropertyName technique. When Windows PowerShell uses the ByPropertyName technique, it attempts to match a property of the object passed to a parameter of the command to which the object was passed. This match occurs in a simple manner. If the input object has a Name property, it will be matched with the parameter Name because they're spelled the same. However, it will only pass the property if the parameter is programmed to accept a value by property name. This means that you can pass output from one command to another when they don't logically go together. In this method, you must specify the parameter names. For example, consider a file called alias.txt with the following content: Name,Value np,notepad sel,Select-Object go,Invoke-Command The idea is to use the contents of this file to input it to the new-alias command and create the aliases listed in the file. Note that the first line of the file corresponds to the column headers. If this file is imported with Import-Csv, the following is obtained: PS C :\\ Users \\ Usuario \\ powershell > Import-Csv .\\ alias . txt Name Value ---- ----- np notepad sel Select-Object go Invoke-Command If you use Get-Member to analyze this output, you get: TypeName: System.Management.Automation.PSCustomObject Name MemberType Definition ---- ---------- ---------- Equals Method bool Equals(System.Object obj) GetHashCode Method int GetHashCode() GetType Method type GetType() ToString Method string ToString() Name NoteProperty string Name=np Value NoteProperty string Value=notepad It can be seen that the last two properties are of type String. Let's now analyze the parameters of the New-Alias command: New-Alias [-Name] <String> [-Value] <String> [-Confirm] [-Description <String>] [-Force] [-Option {None | ReadOnly | Constant | Private | AllScope | Unspecified}] [-PassThru] [-Scope <String>] [-WhatIf] [<CommonParameters>] The Name and Value parameters receive String inputs. And if you review the complete help, you can verify that both parameters receive values through the pipeline using the ByPropertyName mode: -Name <String> Specifies the new alias. You can use any alphanumeric characters in an alias, but the first character cannot be a number. Required? true Position? 0 Default value None Accept pipeline input? True (ByPropertyName) Accept wildcard characters? false -Value <String> Specifies the name of the cmdlet or command element that is being aliased. Required? true Position? 1 Default value None Accept pipeline input? True (ByPropertyName) Accept wildcard characters? false Therefore, information can be passed from one command to another in the following way: import-csv alias . txt | new-alias","title":"By parameter name (ByPropertyName)"},{"location":"pipeline/#renaming-properties","text":"Most often, a property name from an output object doesn't match the name of an input parameter exactly. You can change the name of the property by using Select-Object and create a calculated property. For example, to view the processes running on all computers in your Windows Server Active Directory, try running the following command: Get-ADComputer -Filter * | Get-Process However, this command doesn't work. No parameter for Get-Process matches a property name for the output of Get-ADComputer. View the output of Get-ADComputer | Get-Member and Get-Help Get-Process and you'll see that what you want is to match the Name property of Get-ADComputer with the -ComputerName parameter of Get-Process. You can do that by using Select-Object and changing the property name for the Get-ADComputer command\u2019s Name property to ComputerName, and then passing the results to Get-Process. The following command will work: Get-ADComputer -Filter * | Select-Object @{ n = 'ComputerName' ; e ={ $PSItem . Name }} | Get-Process Remember: Windows PowerShell will always try ByValue first and will use ByPropertyName only if ByValue fails.","title":"Renaming properties"},{"location":"pipeline/#parenthetical-commands","text":"Another option for passing the results of one command to the parameters of another is by using parenthetical commands. A parenthetical command is a command that is enclosed in parentheses. Just as in math, parentheses tell Windows PowerShell to execute the enclosed command first. The parenthetical command runs, and the results of the command are inserted in its place. You can use parenthetical commands to pass values to parameters that do not accept pipeline input. This means you can have a pipeline that includes data inputs from multiple sources. Consider the following command: Get-ADGroup \"London Users\" | Add-ADGroupMember -Members ( Get-ADUser -Filter { City -eq 'London' }) In this example, output of Get-ADGroup passes to Add-ADGroupMember, telling it which group to modify. However, that is only part of the information needed. We also need to tell Add-ADGroupMember what users to add to the group. The -Members parameter does not accept piped input, and even if it did, we have already piped data to the command. Therefore, we need to use a parenthetical command to provide a list of users that we want added to the group. Parenthetical commands do not rely on pipeline parameter binding. They work with any parameter if the parenthetical command produces the kind of object that the parameter expects.","title":"Parenthetical Commands"},{"location":"pipeline/#expand-property-values","text":"You can use parenthetical commands to provide parameter input without using the pipeline. In some cases, however, you might have to manipulate the objects produced by a parenthetical command so that the command\u2019s output is of the type that the parameter requires. For example, you might want to list all the processes that are running on every computer in the domain. In this example, imagine that you have a very small lab domain that contains just a few computers. You can get a list of every computer in the domain by running the following command: Get-ADComputer \u2013 Filter * However, this command produces objects of the type ADComputer. You couldn't use those objects directly in a parenthetical command such as in the following command: Get-Process \u2013 ComputerName ( Get-ADComputer \u2013 Filter *) The \u2013ComputerName parameter expects objects of the type String. However, the parenthetical command doesn't produce String type objects. The \u2013ComputerName parameter only wants a computer name. However, the command provides it an object that contains a name, an operating system version, and several other properties. You could try the following command: Get-Process \u2013 ComputerName ( Get-ADComputer \u2013 Filter * | Select-Object \u2013 Property Name ) This command selects only the Name property. This property is still a member of a whole ADComputer object. It's the Name property of an object. Although the Name property contains a string, it isn't itself a string. The \u2013ComputerName parameter expects a string, not an object with a property. Therefore, that command doesn't work either. The following command achieves the goal of passing the computer name as a string to the -ComputerName parameter: Get-Process \u2013 ComputerName ( Get-ADComputer \u2013 Filter * | Select-Object \u2013 ExpandProperty Name ) The \u2013ExpandProperty parameter accepts one, and only one, property name. When you use that parameter, only the contents of the specified property are produced by Select-Object. Some people refer to this feature as extracting the property contents. The official description of the feature is expanding the property contents. In the preceding command, the result of the parenthetical command is a collection of strings that are passed as individual strings, not an array, and that is what the \u2013ComputerName parameter expects. The command will work correctly; however, it might produce an error if one or more of the computers can't be reached on the network. Expanding property values also works when piping output. Consider the following example: Get-ADUser Ty -Properties MemberOf | Get-ADGroup This command returns an error because Windows PowerShell can't match the MemberOf property to any property of Get-ADGroup. However, if you expand the value of the MemberOf property, as in the following example, Windows PowerShell can match the resulting output to a value that Get-ADGroup understands as valid input: Get-ADUser Ty -Properties MemberOf | Select-Object -ExpandProperty MemberOf | Get-ADGroup","title":"Expand Property Values"},{"location":"tables_lists/","text":"Powershell commands present their output in tables or lists, depending on the command being used and the attributes it is asked to display. The Select-Object command (abbreviated as Select) can be used to determine the attributes that are displayed. However, the display is limited to the attributes related to the invoked command. For example: Get Process | select name , vm ...displays a list of processes, made up only of the name of each process and the amount of virtual memory it uses. The formatting commands allow, in addition to printing the standard attributes, to display attributes calculated from the basic attributes. The display can be done in table, list or wide format mode. Table Format The Format-Table cmdlet (abbreviated as ft) allows you to display the output of a command in table format. The parameters received by this command are the following: Parameters Meaning -Property Allows you to specify the attributes (native or calculated) that you want to display. The wildcard * can be used to specify all of them. -Autosize Allows the command to accommodate the width of the columns in the best possible way. Normally this width is fixed, but this parameter adjusts the width of the columns to the longest value of each attribute. -Groupby This parameter specifies one of the fields. Each time there is a change in the value of this field, a new set of headers is printed. It is recommended to use Sort-Object before doing a Format-Table with Groupby, to avoid unnecessary repetition of headers. -Wrap When a field's value is excessively long, Powershell wraps it, indicating this with an ellipsis (...). The Wrap parameter causes long values to span one or more additional lines, depending on the length of the value. Examples: get-process | ft-Property * ... tries to print all the attributes of the processes. Powershell reviews all lines of the output, and does its best to accommodate all possible fields. Due to this hotfix, the command takes a relatively long time to execute. get-process | ft -Property ID , Name , Responding -AutoSize ...gets a list of processes with ID, Name, and Responding attributes. The width of the columns is optimized. get-process | ft -Property * -autosize ... tries to print all the attributes of the processes. However, this command runs faster, since the width of the columns is optimized. Get-Service | sortStatus | ft Name , Status , DisplayName -groupby Status ... prints a list of services divided into two sections: One of stopped services (Stopped) and another of running services (Running). Get-Service | ft Name , Status , DisplayName -autosize -wrap ...prints a list of services with the attributes Name, Status and DisplayName. The DisplayName attribute (which is the longest) will span multiple lines if necessary. List Format The Format-List cmdlet (abbreviated fl) allows you to display attributes as a series of name-value pairs, for example: Get-Service -name bits | fl -Property * Name : bits RequiredServices : { RpcSs } CanPauseAndContinue : False CanShutdown : False CanStop : False DisplayName : Background Intelligent Transfer Service DependentServices : {} MachineName : . ServiceName : bits ServicesDependedOn : { RpcSs } ServiceHandle : Status : Stopped ServiceType : Win32ShareProcess StartType : Manual Site : Container : Note that the output of the Get-Service command was filtered here, to get only the information for the BITS service (otherwise, Format-List would have returned a similar set of lines for each service). Here Format-List was asked to display all attributes of the service (the -Property parameter with wildcard). Wide Format The wide format allows you to display two or more columns of a particular object property, much like the Linux ls command. The Format-Wide (abbreviated fw) cmdlet is used for this purpose. Examples: get-process | format-wide ... displays two columns of process names (Format-wide defaults to the Name property). get-process | format-wide name -col 4 ...shows 4 columns of process names. Change Of Names Of Attributes An example of renaming an attribute is the following: get service | ft @{ name = 'Service' ; expression ={ $_ . Name }}, Status , DisplayName In this case, a new column is defined, using the expression between the @{ } symbols. Name indicates the name that the column will have. It can be abbreviated as n. Expression defines the content of the column. It can be abbreviated as e. $ is a special variable that holds the object that is currently being processed. For this example, $ .Name means: \"Of the current object, take the Name property.\" The above command could be abbreviated like this: get service | ft @{ n = 'Service' ; e ={ $_ . Name }}, Status , DisplayName The following command: get-process | ft Name ,@{ n = 'VM (MB)' ; e ={ $_ . VM / 1MB }} ...displays a process table with two columns: Name (native property) and VM (MB), which shows the amount of virtual memory used by the process, in megabytes. The command: get-process | ft Name ,@{ n = 'VM (MB)' ; e ={ $_ . VM / 1MB -as [int] }} -AutoSize ...displays a table similar to the one in the previous example, but rounds the virtual memory to an integer value. Using The Format Commands The formatting command to be used (ft, fl or fw) must be the last one in the pipeline before printing to the screen. The output of a format command can only be redirected to a TEXT file. If you try to convert the output to another format (CSV, HTML, XML) the results will be inconsistent.","title":"Formatting"},{"location":"tables_lists/#table-format","text":"The Format-Table cmdlet (abbreviated as ft) allows you to display the output of a command in table format. The parameters received by this command are the following: Parameters Meaning -Property Allows you to specify the attributes (native or calculated) that you want to display. The wildcard * can be used to specify all of them. -Autosize Allows the command to accommodate the width of the columns in the best possible way. Normally this width is fixed, but this parameter adjusts the width of the columns to the longest value of each attribute. -Groupby This parameter specifies one of the fields. Each time there is a change in the value of this field, a new set of headers is printed. It is recommended to use Sort-Object before doing a Format-Table with Groupby, to avoid unnecessary repetition of headers. -Wrap When a field's value is excessively long, Powershell wraps it, indicating this with an ellipsis (...). The Wrap parameter causes long values to span one or more additional lines, depending on the length of the value. Examples: get-process | ft-Property * ... tries to print all the attributes of the processes. Powershell reviews all lines of the output, and does its best to accommodate all possible fields. Due to this hotfix, the command takes a relatively long time to execute. get-process | ft -Property ID , Name , Responding -AutoSize ...gets a list of processes with ID, Name, and Responding attributes. The width of the columns is optimized. get-process | ft -Property * -autosize ... tries to print all the attributes of the processes. However, this command runs faster, since the width of the columns is optimized. Get-Service | sortStatus | ft Name , Status , DisplayName -groupby Status ... prints a list of services divided into two sections: One of stopped services (Stopped) and another of running services (Running). Get-Service | ft Name , Status , DisplayName -autosize -wrap ...prints a list of services with the attributes Name, Status and DisplayName. The DisplayName attribute (which is the longest) will span multiple lines if necessary.","title":"Table Format"},{"location":"tables_lists/#list-format","text":"The Format-List cmdlet (abbreviated fl) allows you to display attributes as a series of name-value pairs, for example: Get-Service -name bits | fl -Property * Name : bits RequiredServices : { RpcSs } CanPauseAndContinue : False CanShutdown : False CanStop : False DisplayName : Background Intelligent Transfer Service DependentServices : {} MachineName : . ServiceName : bits ServicesDependedOn : { RpcSs } ServiceHandle : Status : Stopped ServiceType : Win32ShareProcess StartType : Manual Site : Container : Note that the output of the Get-Service command was filtered here, to get only the information for the BITS service (otherwise, Format-List would have returned a similar set of lines for each service). Here Format-List was asked to display all attributes of the service (the -Property parameter with wildcard).","title":"List Format"},{"location":"tables_lists/#wide-format","text":"The wide format allows you to display two or more columns of a particular object property, much like the Linux ls command. The Format-Wide (abbreviated fw) cmdlet is used for this purpose. Examples: get-process | format-wide ... displays two columns of process names (Format-wide defaults to the Name property). get-process | format-wide name -col 4 ...shows 4 columns of process names.","title":"Wide Format"},{"location":"tables_lists/#change-of-names-of-attributes","text":"An example of renaming an attribute is the following: get service | ft @{ name = 'Service' ; expression ={ $_ . Name }}, Status , DisplayName In this case, a new column is defined, using the expression between the @{ } symbols. Name indicates the name that the column will have. It can be abbreviated as n. Expression defines the content of the column. It can be abbreviated as e. $ is a special variable that holds the object that is currently being processed. For this example, $ .Name means: \"Of the current object, take the Name property.\" The above command could be abbreviated like this: get service | ft @{ n = 'Service' ; e ={ $_ . Name }}, Status , DisplayName The following command: get-process | ft Name ,@{ n = 'VM (MB)' ; e ={ $_ . VM / 1MB }} ...displays a process table with two columns: Name (native property) and VM (MB), which shows the amount of virtual memory used by the process, in megabytes. The command: get-process | ft Name ,@{ n = 'VM (MB)' ; e ={ $_ . VM / 1MB -as [int] }} -AutoSize ...displays a table similar to the one in the previous example, but rounds the virtual memory to an integer value.","title":"Change Of Names Of Attributes"},{"location":"tables_lists/#using-the-format-commands","text":"The formatting command to be used (ft, fl or fw) must be the last one in the pipeline before printing to the screen. The output of a format command can only be redirected to a TEXT file. If you try to convert the output to another format (CSV, HTML, XML) the results will be inconsistent.","title":"Using The Format Commands"},{"location":"wmi_cmi/","text":"WMI and CMI basics A Windows computer contains thousands of items of management information. The WMI (Windows Management Instrumentation) and CIM (Common Information Model) frameworks seek to facilitate and organize these elements. Information in WMI is organized by namespaces. The root\\CIMv2 namespace contains all information about the Windows operating system and the underlying hardware. On client computers, the namespace root\\SecurityCenter2 ( root\\SecurityCenter in earlier versions of the operating system) contains information about firewall, antivirus, and antispyware software installed on the computer. Within each namespace, WMI includes a series of classes. Each class represents a type of management component that WMI knows how to query. For example, the Win32_LogicalDisk class in the root\\CIMv2 namespace contains information about logical disks, while the AntiSpywareProduct class in the root\\SecurityCenterv2 namespace contains information about antispyware products. . If manageable components exist for a certain class, they will appear as instances of that class. Class names in the root\\CIMv2 namespace usually start with Win32_ (even on 64-bit machines) or CIM_ . Typically, the properties of such instances are read-only (that is, you cannot make changes to the parameter values). There are different tools designed to explore the different classes of WMI. One of them is WMI Explorer Get-WmiObject You can use the Get-WmiObject cmdlet to explore WMI namespaces. For example, if you wanted to query the classes related to disks, you could use the following command: Get-WmiObject -Namespace root \\ CIMv2 -list | where name -like '*disk*' The following command displays a complete list of classes within the root\\CIMv2 namespace: Get-WmiObject -Namespace root \\ CIMv2 -list To interrogate a specific class, use the -class parameter: Get-WmiObject -Namespace root \\ CIMv2 -class win32_desktop The above command can be abbreviated, since the default namespace is root\\CIMv2 , and the -class parameter are both positional: Get-WmiObject win32_desktop Get-CimInstance The Get-CimInstance command was introduced in Powershell version 3, and works much like Get-WmiObject , except for the following: The -ClassName parameter is used instead of -Class . There is no -list parameter to list all classes in a namespace. The Get-CimClass cmdlet must be used with the -Namespace parameter. Examples: List the instances of the Win32_LogicalDisk class: Get-CimInstance -ClassName win32_logicaldisk Get the list of classes from root\\CIMv2 , filtering out those that have to do with disks: Get-CimClass -Namespace root \\ CIMv2 | where cimclassname -Like '*disk*'","title":"Windows Management"},{"location":"wmi_cmi/#wmi-and-cmi-basics","text":"A Windows computer contains thousands of items of management information. The WMI (Windows Management Instrumentation) and CIM (Common Information Model) frameworks seek to facilitate and organize these elements. Information in WMI is organized by namespaces. The root\\CIMv2 namespace contains all information about the Windows operating system and the underlying hardware. On client computers, the namespace root\\SecurityCenter2 ( root\\SecurityCenter in earlier versions of the operating system) contains information about firewall, antivirus, and antispyware software installed on the computer. Within each namespace, WMI includes a series of classes. Each class represents a type of management component that WMI knows how to query. For example, the Win32_LogicalDisk class in the root\\CIMv2 namespace contains information about logical disks, while the AntiSpywareProduct class in the root\\SecurityCenterv2 namespace contains information about antispyware products. . If manageable components exist for a certain class, they will appear as instances of that class. Class names in the root\\CIMv2 namespace usually start with Win32_ (even on 64-bit machines) or CIM_ . Typically, the properties of such instances are read-only (that is, you cannot make changes to the parameter values). There are different tools designed to explore the different classes of WMI. One of them is WMI Explorer","title":"WMI and CMI basics"},{"location":"wmi_cmi/#get-wmiobject","text":"You can use the Get-WmiObject cmdlet to explore WMI namespaces. For example, if you wanted to query the classes related to disks, you could use the following command: Get-WmiObject -Namespace root \\ CIMv2 -list | where name -like '*disk*' The following command displays a complete list of classes within the root\\CIMv2 namespace: Get-WmiObject -Namespace root \\ CIMv2 -list To interrogate a specific class, use the -class parameter: Get-WmiObject -Namespace root \\ CIMv2 -class win32_desktop The above command can be abbreviated, since the default namespace is root\\CIMv2 , and the -class parameter are both positional: Get-WmiObject win32_desktop","title":"Get-WmiObject"},{"location":"wmi_cmi/#get-ciminstance","text":"The Get-CimInstance command was introduced in Powershell version 3, and works much like Get-WmiObject , except for the following: The -ClassName parameter is used instead of -Class . There is no -list parameter to list all classes in a namespace. The Get-CimClass cmdlet must be used with the -Namespace parameter. Examples: List the instances of the Win32_LogicalDisk class: Get-CimInstance -ClassName win32_logicaldisk Get the list of classes from root\\CIMv2 , filtering out those that have to do with disks: Get-CimClass -Namespace root \\ CIMv2 | where cimclassname -Like '*disk*'","title":"Get-CimInstance"},{"location":"Advanced/Credentials/","text":"Get-Credential As a best practice, administrators should have two user accounts. Each administrator should have a standard user account that's used for day-to-day activity and a second account with administrative permissions. Separating these roles helps to avoid accidental damage to computer systems and limits the potential effects of malware. The Get-Credential cmdlet can help you use the administrative account while you're still signed in to a standard user account. One way to elevate privileges when you run a script is to use the Run as administrator option when you open the Windows PowerShell prompt. If you use Run as administrator, you're prompted for credentials. So, all actions performed at that Windows PowerShell prompt use the credentials provided. As an alternative to using Run as administrator for running a script, you can have your script prompt for credentials instead. Many Windows PowerShell cmdlets allow an alternate set of credentials to be provided. That way, the credentials that the script obtains can be used to run individual commands in the script. You can prompt for credentials by using Get-Credential. The syntax for using the Get-Credential cmdlet is: $cred = Get-Credential Set-ADUser -Identity $user -Department \"Marketing\" -Credential $cred Storing Credentials By Using Export-Clixml You can store credentials to a file for later reuse without being prompted for credentials. To store credentials to a file, you use Export-Clixml. For a credential object, Export-Clixml encrypts the credential object before storing it in an XML file. Use the following syntax to store a credential object to a file. $cred | Export-Clixml C :\\ cred . xml The encryption used by Export-Clixml is user-specific and computer-specific. That means that if you store the encrypted credentials, only you can retrieve the encrypted credentials and only on the computer you originally used to store them. This action helps keep the credentials secure, but it also means that they can't be shared with other users. By Using The SecretManagement Module Microsoft has released the SecretManagement module that you can use to store and retrieve credentials. This method works better for storing credentials that can be shared among multiple users and computers. The cmdlets included in the SecretManagement module can access credentials from multiple secret vaults. Some well-known vaults are: KeePass LastPass CredMan Azure KeyVault The SecretManagement module is available in the PowerShell Gallery. You can install the SecretManagement module by running the following command: Install-Module Microsoft . PowerShell . SecretManagement Microsoft also provides the SecretStore module that you can use to create a local secret vault for storing credentials. However, similar to using Export-Clixml, the vault is stored on the local machine and in the current user context.","title":"Credentials"},{"location":"Advanced/Credentials/#get-credential","text":"As a best practice, administrators should have two user accounts. Each administrator should have a standard user account that's used for day-to-day activity and a second account with administrative permissions. Separating these roles helps to avoid accidental damage to computer systems and limits the potential effects of malware. The Get-Credential cmdlet can help you use the administrative account while you're still signed in to a standard user account. One way to elevate privileges when you run a script is to use the Run as administrator option when you open the Windows PowerShell prompt. If you use Run as administrator, you're prompted for credentials. So, all actions performed at that Windows PowerShell prompt use the credentials provided. As an alternative to using Run as administrator for running a script, you can have your script prompt for credentials instead. Many Windows PowerShell cmdlets allow an alternate set of credentials to be provided. That way, the credentials that the script obtains can be used to run individual commands in the script. You can prompt for credentials by using Get-Credential. The syntax for using the Get-Credential cmdlet is: $cred = Get-Credential Set-ADUser -Identity $user -Department \"Marketing\" -Credential $cred","title":"Get-Credential"},{"location":"Advanced/Credentials/#storing-credentials","text":"","title":"Storing Credentials"},{"location":"Advanced/Credentials/#by-using-export-clixml","text":"You can store credentials to a file for later reuse without being prompted for credentials. To store credentials to a file, you use Export-Clixml. For a credential object, Export-Clixml encrypts the credential object before storing it in an XML file. Use the following syntax to store a credential object to a file. $cred | Export-Clixml C :\\ cred . xml The encryption used by Export-Clixml is user-specific and computer-specific. That means that if you store the encrypted credentials, only you can retrieve the encrypted credentials and only on the computer you originally used to store them. This action helps keep the credentials secure, but it also means that they can't be shared with other users.","title":"By Using Export-Clixml"},{"location":"Advanced/Credentials/#by-using-the-secretmanagement-module","text":"Microsoft has released the SecretManagement module that you can use to store and retrieve credentials. This method works better for storing credentials that can be shared among multiple users and computers. The cmdlets included in the SecretManagement module can access credentials from multiple secret vaults. Some well-known vaults are: KeePass LastPass CredMan Azure KeyVault The SecretManagement module is available in the PowerShell Gallery. You can install the SecretManagement module by running the following command: Install-Module Microsoft . PowerShell . SecretManagement Microsoft also provides the SecretStore module that you can use to create a local secret vault for storing credentials. However, similar to using Export-Clixml, the vault is stored on the local machine and in the current user context.","title":"By Using The SecretManagement Module"},{"location":"Advanced/ErrorHandling/","text":"As you develop more scripts, you'll find that efficient troubleshooting makes your script development much faster. A large part of efficient troubleshooting is understanding error messages. For some difficult problems, you can use breakpoints to stop a script partially through running to query values for variables. Try/Catch/Finally Try { # Do something with a file. } Catch [System.IO.IOException] { Write-Host \"Something went wrong\" } Catch { # Catch all. It's not an IOException but something else. } Finally { # Clean up resources. } Inspecting errors An exception object contains: A message. The message tells you in a few words what went wrong. The stacktrace. The stacktrace tells you which statements ran before the error. Imagine you have a call to function A, followed by B, followed by C. The script stops responding at C. The stacktrace will show that chain of calls. The offending row. The exception object also tells you which row the script was running when the error occurred. This information can help you debug your code. So how do you inspect an exception object? There's a built-in variable, $ , that has an exception property. To get the error message, for example, you would use $ .exception.message. Try { # Do something with a file. } Catch [System.IO.IOException] { Write-Host \"Something IO went wrong: $( $_ . exception . message ) \" } Catch { Write-Host \"Something else went wrong: $( $_ . exception . message ) \" } Raising errors In some situations, you might want to cause an error: Non-terminating errors. For this type of error, PowerShell just notifies you that something went wrong, by using the Write-Error cmdlet, for example. The script continues to run. That might not be the behavior you want. To raise the severity of the error, you can use a parameter like -ErrorAction to cause an error that can be caught with Try/Catch, like so: Try { Get-Content './file.txt' -ErrorAction Stop } Catch { Write-Error \"File can't be found\" } By using the -ErrorAction parameter and the value Stop, you can cause an error that Try/Catch can catch. Business rules. You might have a situation where the code doesn't actually stop responding, but you want it to for business reasons. Imagine you're sanitizing input and you check whether a parameter is a path. A business requirement might specify only certain paths are allowed, or the path needs to look a certain way. If the checks fail, it makes sense to throw an error. In a situation like this, you can use a Throw block: Try { If ( $Path -eq './forbidden' ) { Throw \"Path not allowed\" } # Carry on. } Catch { Write-Error \" $( $_ . exception . message ) \" # Path not allowed. } In general, don't use Throw for parameter validation. Use validation attributes instead. If you can't make your code work with these attributes, a Throw might be OK. $ErrorActionPreference Windows PowerShell has a built-in, global variable named $ErrorActionPreference. When a command generates a non-terminating error, the command checks that variable to decide what it should do. The variable can have one of the following four possible values: Continue is the default, and it tells the command to display an error message and continue to run. SilentlyContinue tells the command to display no error message, but to continue running. Inquire tells the command to display a prompt asking the user what to do. Stop tells the command to treat the error as terminating and to stop running. $ErrorActionPreference = 'Inquire' Be selective about using SilentlyContinue for $ErrorActionPreference. You might think that this makes your script better for users, but it could make troubleshooting difficult. If you intend to trap an error within your script so that you can manage the error, commands must use the Stop action. You can trap and manage only terminating errors. -ErrorAction parameter All Windows PowerShell commands have the \u2013ErrorAction parameter. This parameter has the alias \u2013EA. The parameter accepts the same values as $ErrorActionPreference, and the parameter overrides the variable for that command. If you expect an error to occur on a command, you use \u2013ErrorAction to set that command\u2019s error action to Stop. Doing this lets you trap and manage the error for that command but leaves all other commands to use the action in $ErrorActionPreference. An example is: Get-WmiObject -Class Win32_BIOS -ComputerName LON-SVR1 , LON-DC1 -ErrorAction Stop The only time that you'll modify $ErrorActionPreference is when you expect an error outside of a Windows PowerShell command, such as when you're running a method such as the following Get-Process \u2013 Name Notepad | ForEach -Object { $PSItem . Kill () } In this example, the Kill() method might generate an error. But because it's not a Windows PowerShell command, it doesn't have the \u2013ErrorAction parameter. You would instead set $ErrorActionPreference to Stop before running the method, and then set the variable back to Continue after you run the method. Breakpoints A breakpoint pauses a script and provides an interactive prompt. At the interactive prompt, you can query or modify variable values and then continue the script. You use breakpoints to troubleshoot scripts when they aren't behaving as expected. At a Windows PowerShell prompt, you can set breakpoints by using the Set-PSBreakPoint cmdlet. Breakpoints can be set based on the line of the script, a specific command being used, or a specific variable being used. Set-PSBreakPoint -Script \"MyScript.ps1\" -Line 23 The following example depicts how to set a breakpoint for a specific command: Set-PSBreakPoint -Command \"Set-ADUser\" -Script \"MyScript.ps1\" When you set a breakpoint based on a command, you can include wildcards. For example, you could use the value *-ADUser to trigger a breakpoint for Get-ADUser, Set-ADUser, New-ADUser, and Remove-ADUser. To set a breakpoint for a specific variable, do the following: Set-PSBreakPoint -Variable \"computer\" -Script \"MyScript.ps1\" -Mode ReadWrite You can use the -Mode parameter for variables to identify whether you want to break when the variable value is read, written, or both. Valid values are Read, Write, and ReadWrite. The default action for Set-PSBreakPoint is break, which provides the interactive prompt. However, you can use the -Action parameter to specify code that runs instead. This allows you to perform complex operations such as evaluating variable values and only breaking if the value is outside a specific range. Breakpoints are stored in memory rather than as part of the script. Breakpoints aren't shared between multiple Windows PowerShell prompts and are removed when the prompt is closed. Microsoft Visual Studio Code allows you to set and use breakpoints with more advanced options and you can configure conditional breakpoints that are triggered when variables are outside of a range or match a specific value. Information about variable contents is also easier to find in Visual Studio Code. After a breakpoint is triggered and you're in the debugger, there's a variables section that displays the contents of variable so that you don't need to interrogate them.","title":"Handling Errors"},{"location":"Advanced/ErrorHandling/#trycatchfinally","text":"Try { # Do something with a file. } Catch [System.IO.IOException] { Write-Host \"Something went wrong\" } Catch { # Catch all. It's not an IOException but something else. } Finally { # Clean up resources. }","title":"Try/Catch/Finally"},{"location":"Advanced/ErrorHandling/#inspecting-errors","text":"An exception object contains: A message. The message tells you in a few words what went wrong. The stacktrace. The stacktrace tells you which statements ran before the error. Imagine you have a call to function A, followed by B, followed by C. The script stops responding at C. The stacktrace will show that chain of calls. The offending row. The exception object also tells you which row the script was running when the error occurred. This information can help you debug your code. So how do you inspect an exception object? There's a built-in variable, $ , that has an exception property. To get the error message, for example, you would use $ .exception.message. Try { # Do something with a file. } Catch [System.IO.IOException] { Write-Host \"Something IO went wrong: $( $_ . exception . message ) \" } Catch { Write-Host \"Something else went wrong: $( $_ . exception . message ) \" }","title":"Inspecting errors"},{"location":"Advanced/ErrorHandling/#raising-errors","text":"In some situations, you might want to cause an error: Non-terminating errors. For this type of error, PowerShell just notifies you that something went wrong, by using the Write-Error cmdlet, for example. The script continues to run. That might not be the behavior you want. To raise the severity of the error, you can use a parameter like -ErrorAction to cause an error that can be caught with Try/Catch, like so: Try { Get-Content './file.txt' -ErrorAction Stop } Catch { Write-Error \"File can't be found\" } By using the -ErrorAction parameter and the value Stop, you can cause an error that Try/Catch can catch. Business rules. You might have a situation where the code doesn't actually stop responding, but you want it to for business reasons. Imagine you're sanitizing input and you check whether a parameter is a path. A business requirement might specify only certain paths are allowed, or the path needs to look a certain way. If the checks fail, it makes sense to throw an error. In a situation like this, you can use a Throw block: Try { If ( $Path -eq './forbidden' ) { Throw \"Path not allowed\" } # Carry on. } Catch { Write-Error \" $( $_ . exception . message ) \" # Path not allowed. } In general, don't use Throw for parameter validation. Use validation attributes instead. If you can't make your code work with these attributes, a Throw might be OK.","title":"Raising errors"},{"location":"Advanced/ErrorHandling/#erroractionpreference","text":"Windows PowerShell has a built-in, global variable named $ErrorActionPreference. When a command generates a non-terminating error, the command checks that variable to decide what it should do. The variable can have one of the following four possible values: Continue is the default, and it tells the command to display an error message and continue to run. SilentlyContinue tells the command to display no error message, but to continue running. Inquire tells the command to display a prompt asking the user what to do. Stop tells the command to treat the error as terminating and to stop running. $ErrorActionPreference = 'Inquire' Be selective about using SilentlyContinue for $ErrorActionPreference. You might think that this makes your script better for users, but it could make troubleshooting difficult. If you intend to trap an error within your script so that you can manage the error, commands must use the Stop action. You can trap and manage only terminating errors.","title":"$ErrorActionPreference"},{"location":"Advanced/ErrorHandling/#-erroraction-parameter","text":"All Windows PowerShell commands have the \u2013ErrorAction parameter. This parameter has the alias \u2013EA. The parameter accepts the same values as $ErrorActionPreference, and the parameter overrides the variable for that command. If you expect an error to occur on a command, you use \u2013ErrorAction to set that command\u2019s error action to Stop. Doing this lets you trap and manage the error for that command but leaves all other commands to use the action in $ErrorActionPreference. An example is: Get-WmiObject -Class Win32_BIOS -ComputerName LON-SVR1 , LON-DC1 -ErrorAction Stop The only time that you'll modify $ErrorActionPreference is when you expect an error outside of a Windows PowerShell command, such as when you're running a method such as the following Get-Process \u2013 Name Notepad | ForEach -Object { $PSItem . Kill () } In this example, the Kill() method might generate an error. But because it's not a Windows PowerShell command, it doesn't have the \u2013ErrorAction parameter. You would instead set $ErrorActionPreference to Stop before running the method, and then set the variable back to Continue after you run the method.","title":"-ErrorAction parameter"},{"location":"Advanced/ErrorHandling/#breakpoints","text":"A breakpoint pauses a script and provides an interactive prompt. At the interactive prompt, you can query or modify variable values and then continue the script. You use breakpoints to troubleshoot scripts when they aren't behaving as expected. At a Windows PowerShell prompt, you can set breakpoints by using the Set-PSBreakPoint cmdlet. Breakpoints can be set based on the line of the script, a specific command being used, or a specific variable being used. Set-PSBreakPoint -Script \"MyScript.ps1\" -Line 23 The following example depicts how to set a breakpoint for a specific command: Set-PSBreakPoint -Command \"Set-ADUser\" -Script \"MyScript.ps1\" When you set a breakpoint based on a command, you can include wildcards. For example, you could use the value *-ADUser to trigger a breakpoint for Get-ADUser, Set-ADUser, New-ADUser, and Remove-ADUser. To set a breakpoint for a specific variable, do the following: Set-PSBreakPoint -Variable \"computer\" -Script \"MyScript.ps1\" -Mode ReadWrite You can use the -Mode parameter for variables to identify whether you want to break when the variable value is read, written, or both. Valid values are Read, Write, and ReadWrite. The default action for Set-PSBreakPoint is break, which provides the interactive prompt. However, you can use the -Action parameter to specify code that runs instead. This allows you to perform complex operations such as evaluating variable values and only breaking if the value is outside a specific range. Breakpoints are stored in memory rather than as part of the script. Breakpoints aren't shared between multiple Windows PowerShell prompts and are removed when the prompt is closed. Microsoft Visual Studio Code allows you to set and use breakpoints with more advanced options and you can configure conditional breakpoints that are triggered when variables are outside of a range or match a specific value. Information about variable contents is also easier to find in Visual Studio Code. After a breakpoint is triggered and you're in the debugger, there's a variables section that displays the contents of variable so that you don't need to interrogate them.","title":"Breakpoints"},{"location":"Advanced/modules/","text":"Modules are groups of related PowerShell capabilities that are bundled together into a single unit. For the purposes of this class, you can think of them as containers hosting multiple cmdlets. Modules help with organizing cmdlets into distributable units. Microsoft and other software companies provide modules as part of the management tools for their applications and services. To use a module's cmdlets, the module must be loaded into the current PowerShell session. This typically takes place automatically but, depending on your configuration, might require that you load modules explicitly by running the Import-Module cmdlet. Autoloading In Windows PowerShell version 3.0 and newer, modules load automatically if you run a cmdlet that is part of that module. This works if the module that contains the cmdlet is in a folder under the module load paths. By default, these folders include %systemdir%\\WindowsPowerShell\\v1.0\\Modules and %userprofiles%\\Documents\\WindowsPowerShell\\Modules. The list of folders is stored in the $env:PSModulePath environment variable. When you explicitly import a module by name, PowerShell checks the locations referenced by that environment variable. For PowerShell 7, the PSModulePath includes the following locations: C:\\Users\\ \\Documents\\PowerShell\\Modules C:\\Program Files\\PowerShell\\Modules C:\\Program Files\\PowerShell\\7\\Modules C:\\Program Files\\WindowsPowerShell\\Modules C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\Modules When using Windows PowerShell, the path %systemdir%\\WindowsPowerShell\\v1.0\\Modules is commonly referred to by using the combination of the $PSHome environment variable (which points to %systemdir%\\WindowsPowerShell\\v1.0) and the Modules path (that is, by using the $PSHome\\Modules notation). For PowerShell 7.0, the $PSHome environment variable refers to C:\\Program Files\\PowerShell\\7 Using Modules To Discover Cmdlets When you use the Get-Module command, it displays a partial list of cmdlets that the module you reference contains. However, you can use the module in another way to find its cmdlets. For example, if you've discovered the module NetAdapter, you would expect that it should contain cmdlets you can use to manage network adapters. You can find all applicable commands in that module by running the Get-Command \u2013Module NetAdapter command. The \u2013Module parameter restricts the results to just those commands in the designated module. PowerShell Gallery The PowerShell Gallery is a central repository for Windows PowerShell\u2013related content, including scripts and modules. The PowerShell Gallery uses the Windows PowerShell module, PowerShellGet. This module is part of Windows PowerShell 5.0 and newer. PowerShellGet contains cmdlets for finding and installing modules, scripts, and commands from the online gallery. For example, the Find-Command cmdlet searches for commands, functions, and aliases. It works similar to the Get-Command cmdlet, including support for wildcards. You can pass the results of the Find-Command cmdlet to the Install-Module cmdlet, which the PowerShellGet module also contains. Install-Module will install the module that contains the cmdlet that you discovered. The following table lists the two cmdlets used most often to find content in the PowerShell Gallery. Table 1: Cmdlets used to find content in the PowerShell Gallery Cmdlet Description Find-Module Use this cmdlet to search for Windows PowerShell modules in the PowerShell Gallery. The simplest usage conducts searches based on the module name, but you can also search based on the command name, version, DscResource, and RoleCapability. Find-Script Use this cmdlet to search for Windows PowerShell scripts in the PowerShell Gallery. The simplest usage conducts searches based on the script name, but you can also search based on the version. Create Modules You can create modules to store functions and share those functions among scripts. After you put your functions into modules, they're discoverable just as cmdlets are. Also, like the modules included with Windows, the modules you create load automatically when a function is required. As a best practice, you should name your functions in modules with a naming structure similar to the cmdlet naming convention. For example, you would use the verb-noun format. Functions in modules can include comment-based help that's discoverable by using Get-Help. To support this, you need to include the help information in each function. In many cases, you already have your functions in a Windows PowerShell script file. To convert a script file containing only functions to a module, rename it with the .psm1 file extension. No structural changes in the file are required. Windows PowerShell uses the $PSModulePath environmental variable to define the paths from which modules are loaded. In Windows PowerShell 5.0, the following paths are listed: C:\\Users\\UserID\\Documents\\WindowsPowerShell\\Modules C:\\Program Files\\WindowsPowerShell\\Modules C:\\Windows\\System32\\WindowsPowerShell\\1.0\\Modules Windows PowerShell 7 includes the following other paths: C:\\Program Files\\PowerShell\\Modules C:\\Program Files\\PowerShell\\7\\Modules If you store modules in C:\\Users\\UserID\\Document\\WindowsPowerShell\\Modules, they're only available to a single user. Modules aren't placed directly in the Modules directory. Instead, you must create a subfolder with the same name as the file and place the file in that folder. For example, if you have a module named AdatumFunctions.psm1, you'd place it in C:\\Program Files\\WindowsPowerShell\\Modules\\AdatumFunctions. Dot Sourcing Dot sourcing is a method for importing another script into the current scope. If you have a script file that contains functions, you can use dot sourcing to load the functions into memory at a Windows PowerShell prompt. Normally, when you run the script file with functions, the functions are removed from memory when the script completes. When you use dot sourcing, the functions remain in memory, and you can use them at the Windows PowerShell prompt. You can also use dot sourcing within a script to import content from another script. Dot sourcing can load from a local file or over the network by using a Universal Naming Convention (UNC) path. The syntax for using dot sourcing is: . C :\\ scripts \\ functions . ps1 At one time, dot sourcing was the only method available to maintain a centralized repository of functions that could be reused across multiple scripts. However, modules are a more standardized and preferred method for maintaining functions used across scripts.","title":"Modules"},{"location":"Advanced/modules/#autoloading","text":"In Windows PowerShell version 3.0 and newer, modules load automatically if you run a cmdlet that is part of that module. This works if the module that contains the cmdlet is in a folder under the module load paths. By default, these folders include %systemdir%\\WindowsPowerShell\\v1.0\\Modules and %userprofiles%\\Documents\\WindowsPowerShell\\Modules. The list of folders is stored in the $env:PSModulePath environment variable. When you explicitly import a module by name, PowerShell checks the locations referenced by that environment variable. For PowerShell 7, the PSModulePath includes the following locations: C:\\Users\\ \\Documents\\PowerShell\\Modules C:\\Program Files\\PowerShell\\Modules C:\\Program Files\\PowerShell\\7\\Modules C:\\Program Files\\WindowsPowerShell\\Modules C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\Modules When using Windows PowerShell, the path %systemdir%\\WindowsPowerShell\\v1.0\\Modules is commonly referred to by using the combination of the $PSHome environment variable (which points to %systemdir%\\WindowsPowerShell\\v1.0) and the Modules path (that is, by using the $PSHome\\Modules notation). For PowerShell 7.0, the $PSHome environment variable refers to C:\\Program Files\\PowerShell\\7","title":"Autoloading"},{"location":"Advanced/modules/#using-modules-to-discover-cmdlets","text":"When you use the Get-Module command, it displays a partial list of cmdlets that the module you reference contains. However, you can use the module in another way to find its cmdlets. For example, if you've discovered the module NetAdapter, you would expect that it should contain cmdlets you can use to manage network adapters. You can find all applicable commands in that module by running the Get-Command \u2013Module NetAdapter command. The \u2013Module parameter restricts the results to just those commands in the designated module.","title":"Using Modules To Discover Cmdlets"},{"location":"Advanced/modules/#powershell-gallery","text":"The PowerShell Gallery is a central repository for Windows PowerShell\u2013related content, including scripts and modules. The PowerShell Gallery uses the Windows PowerShell module, PowerShellGet. This module is part of Windows PowerShell 5.0 and newer. PowerShellGet contains cmdlets for finding and installing modules, scripts, and commands from the online gallery. For example, the Find-Command cmdlet searches for commands, functions, and aliases. It works similar to the Get-Command cmdlet, including support for wildcards. You can pass the results of the Find-Command cmdlet to the Install-Module cmdlet, which the PowerShellGet module also contains. Install-Module will install the module that contains the cmdlet that you discovered. The following table lists the two cmdlets used most often to find content in the PowerShell Gallery. Table 1: Cmdlets used to find content in the PowerShell Gallery Cmdlet Description Find-Module Use this cmdlet to search for Windows PowerShell modules in the PowerShell Gallery. The simplest usage conducts searches based on the module name, but you can also search based on the command name, version, DscResource, and RoleCapability. Find-Script Use this cmdlet to search for Windows PowerShell scripts in the PowerShell Gallery. The simplest usage conducts searches based on the script name, but you can also search based on the version.","title":"PowerShell Gallery"},{"location":"Advanced/modules/#create-modules","text":"You can create modules to store functions and share those functions among scripts. After you put your functions into modules, they're discoverable just as cmdlets are. Also, like the modules included with Windows, the modules you create load automatically when a function is required. As a best practice, you should name your functions in modules with a naming structure similar to the cmdlet naming convention. For example, you would use the verb-noun format. Functions in modules can include comment-based help that's discoverable by using Get-Help. To support this, you need to include the help information in each function. In many cases, you already have your functions in a Windows PowerShell script file. To convert a script file containing only functions to a module, rename it with the .psm1 file extension. No structural changes in the file are required. Windows PowerShell uses the $PSModulePath environmental variable to define the paths from which modules are loaded. In Windows PowerShell 5.0, the following paths are listed: C:\\Users\\UserID\\Documents\\WindowsPowerShell\\Modules C:\\Program Files\\WindowsPowerShell\\Modules C:\\Windows\\System32\\WindowsPowerShell\\1.0\\Modules Windows PowerShell 7 includes the following other paths: C:\\Program Files\\PowerShell\\Modules C:\\Program Files\\PowerShell\\7\\Modules If you store modules in C:\\Users\\UserID\\Document\\WindowsPowerShell\\Modules, they're only available to a single user. Modules aren't placed directly in the Modules directory. Instead, you must create a subfolder with the same name as the file and place the file in that folder. For example, if you have a module named AdatumFunctions.psm1, you'd place it in C:\\Program Files\\WindowsPowerShell\\Modules\\AdatumFunctions.","title":"Create Modules"},{"location":"Advanced/modules/#dot-sourcing","text":"Dot sourcing is a method for importing another script into the current scope. If you have a script file that contains functions, you can use dot sourcing to load the functions into memory at a Windows PowerShell prompt. Normally, when you run the script file with functions, the functions are removed from memory when the script completes. When you use dot sourcing, the functions remain in memory, and you can use them at the Windows PowerShell prompt. You can also use dot sourcing within a script to import content from another script. Dot sourcing can load from a local file or over the network by using a Universal Naming Convention (UNC) path. The syntax for using dot sourcing is: . C :\\ scripts \\ functions . ps1 At one time, dot sourcing was the only method available to maintain a centralized repository of functions that could be reused across multiple scripts. However, modules are a more standardized and preferred method for maintaining functions used across scripts.","title":"Dot Sourcing"},{"location":"Exercises/Exercises1/","text":"Exercises on Get-Help usage Verify if there are cmdlets that allow converting the output of another cmdlet to HTML format. Click me for proposed solution help * html * Verify which cmdlets allow directing output to a printer or a file. Click me for proposed solution Out-Printer Out-File Verify how many cmdlets are used to manage processes. Click me for proposed solution help * Process * Which cmdlet can be used to write an entry to an event log? Click me for proposed solution Write-EventLog Which cmdlets can be used to manage aliases? Click me for proposed solution help * alias * Is there a way to keep a transcript of a PowerShell session and save it to a file? Click me for proposed solution Start-Transcript -Path \"C:\\transcripts\\transcript0.txt\" -NoClobber How can you get the 100 most recent records from the SECURITY event log on a system? Click me for proposed solution Get-EventLog -LogName SECURITY -Newest 100 Is there a way to obtain the list of services that are running on a remote computer? Click me for proposed solution Answer: Yes, you can use the Get-Service cmdlet with the -ComputerName parameter followed by the name of the remote computer to obtain the list of services running on that computer. Example: Get-Service -ComputerName RemoteComputerName Is there a way to obtain the list of services that are running on a remote computer? Click me for proposed solution Answer: Yes, you can use the Get-Process cmdlet with the -ComputerName parameter followed by the name of the remote computer to obtain the list of processes running on that computer. Example: Get-Process -ComputerName RemoteComputerName Review the help of the Out-File cmdlet. What is the line size used by this cmdlet by default? Is there a parameter that allows you to change this size? Click me for proposed solution Answer: The line size used by default by the Out-File cmdlet is 80 characters. You can change this size using the -Width parameter followed by the desired width. Example: Get-Process | Out-File -FilePath C :\\ Processes . txt -Width 120 By default, Out-File overwrites the output file if it already exists. Is there a parameter that prevents the overwriting of an existing file? Click me for proposed solution Answer: Yes, the -NoClobber parameter can be used to prevent the overwriting of an existing file. If this parameter is used and the output file already exists, Out-File will not overwrite the file and will instead display an error message. Example: Get-Process | Out-File -FilePath C :\\ Processes . txt -NoClobber","title":"Exercise 1"},{"location":"Exercises/Exercises1/#exercises-on-get-help-usage","text":"Verify if there are cmdlets that allow converting the output of another cmdlet to HTML format. Click me for proposed solution help * html * Verify which cmdlets allow directing output to a printer or a file. Click me for proposed solution Out-Printer Out-File Verify how many cmdlets are used to manage processes. Click me for proposed solution help * Process * Which cmdlet can be used to write an entry to an event log? Click me for proposed solution Write-EventLog Which cmdlets can be used to manage aliases? Click me for proposed solution help * alias * Is there a way to keep a transcript of a PowerShell session and save it to a file? Click me for proposed solution Start-Transcript -Path \"C:\\transcripts\\transcript0.txt\" -NoClobber How can you get the 100 most recent records from the SECURITY event log on a system? Click me for proposed solution Get-EventLog -LogName SECURITY -Newest 100 Is there a way to obtain the list of services that are running on a remote computer? Click me for proposed solution Answer: Yes, you can use the Get-Service cmdlet with the -ComputerName parameter followed by the name of the remote computer to obtain the list of services running on that computer. Example: Get-Service -ComputerName RemoteComputerName Is there a way to obtain the list of services that are running on a remote computer? Click me for proposed solution Answer: Yes, you can use the Get-Process cmdlet with the -ComputerName parameter followed by the name of the remote computer to obtain the list of processes running on that computer. Example: Get-Process -ComputerName RemoteComputerName Review the help of the Out-File cmdlet. What is the line size used by this cmdlet by default? Is there a parameter that allows you to change this size? Click me for proposed solution Answer: The line size used by default by the Out-File cmdlet is 80 characters. You can change this size using the -Width parameter followed by the desired width. Example: Get-Process | Out-File -FilePath C :\\ Processes . txt -Width 120 By default, Out-File overwrites the output file if it already exists. Is there a parameter that prevents the overwriting of an existing file? Click me for proposed solution Answer: Yes, the -NoClobber parameter can be used to prevent the overwriting of an existing file. If this parameter is used and the output file already exists, Out-File will not overwrite the file and will instead display an error message. Example: Get-Process | Out-File -FilePath C :\\ Processes . txt -NoClobber","title":"Exercises on Get-Help usage"},{"location":"Exercises/Exercises2/","text":"Create two similar text files (with one or two different lines). Compare them using diff. Click me for proposed solution ##Create 1st file New-Item -Path . -Name \"file1.txt\" -ItemType \"file\" -Value \"Hello World.\\nBonjour Monde!\" -Force ##Create 2nd file New-Item -Path . -Name \"file2.txt\" -ItemType \"file\" -Value \"Hello World!\\nBonjour Monde.\" -Force ##Find the difference between two files diff -ReferenceObject ( cat file1 . txt ) -DifferenceObject ( cat file2 . txt ) InputObject SideIndicator ----------- ------------- Hello World! => Bonjour Monde. => Hello World. <= Bonjour Monde! <= What happens if you run: get-service | export-csv servicios . csv | out-file Why? Click me for proposed solution The output of the above command is: out-file: Cannot process argument because the value of the \"path\" argument is NULL. Change the value of the \"path\" argument to a non-null value. At line:1 char:42 + get-service | export-csv servicios.csv | out-file + ~~~~~~~~ + CategoryInfo : InvalidArgument: (:) [Out-File], PSArgumentNullException + FullyQualifiedErrorId : ArgumentNull,Microsoft.PowerShell.Commands.OutFileCommand This is because export-csv servicios.csv creates the csv file and has null output, therefore out-file is not necessary. How would you create a file delimited by semicolons (;)? HINT: Use export-csv, but with an additional parameter. Click me for proposed solution ps | epcsv -delimiter \";\" example . csv ##Same as Get-Process | Export-Csv -delimiter \";\" example . csv Export-cliXML and Export-CSV modify the system, because they can create and overwrite files. Is there a parameter that prevents overwriting an existing file? Is there a parameter that allows the command to ask before overwriting a file? Click me for proposed solution To prevent overwriting the file if it already exists, the -NoClobber attribute can be used. Example: The following command will not overwrite the result from point 3 ps | epcsv example . csv -NoClobber To ask for confirmation, use the -Confirm parameter. ps | epcsv -delimiter \";\" example . csv -Confirm Windows uses regional settings, which includes the list separator. In English Windows, the list separator is a comma (,). How do you tell Export-CSV to use the system separator instead of the comma? Click me for proposed solution The cmdlet get-culture obtains system configuration information, such as language and writing information. ps | epcsv test2 . csv -Delimiter (( get-culture ). textInfo . listSeparator ) Using cat (alias of Get-Content), we can see that the output uses ';' as the Spanish list separator. cat .\\ test2 . csv Identify a cmdlet that allows generating a random number. Click me for proposed solution The cmdlet get-random returns a pseudo-random 32-bit integer. Identify a cmdlet that displays the current date and time. Click me for proposed solution The cmdlet get-date returns an object that represents the current date and time, which can be represented in various formats such as Windows or UNIX. What type of object does the cmdlet in question 7 produce? Click me for proposed solution Using the cmdlet gm, we can obtain the elements that make up the object and the type. As seen below, the object is part of the System package and its type is DateTime. Get-Date | gm TypeName : System . DateTime Using the cmdlet in question 7 and select-object, display only the day of the week as follows: DayOfWeek --------- Thursday Click me for proposed solution get-date | select -property \"dayofweek\" DayOfWeek --------- Friday Identify a cmdlet that displays information about patches (hotfixes) installed on the system. Click me for proposed solution The cmdlet that returns a list of system patches is: get-hotfix Using the cmdlet from question 10, display a list of installed patches. Then extend the expression to sort the list by installation date, and display on the screen only the installation date, the user who installed the patch, and the patch ID. Remember to examine the property names. Click me for proposed solution The cmdlet that returns a list of system patches is: get-hotfix | sort -property installedon | select -property installedon , installedby , hotfixid Complement the solution to question 11 so that the system sorts the results by the patch description, and includes the description, patch ID, and installation date in the listing. Write the results to an HTML file. Click me for proposed solution The cmdlet that returns a list of system patches is: get-hotFix | sort -property description | select -property hotfixid , description , installedon | convertto-html | Out-File hotfix . html Display a list of the 50 newest entries from the System event log. Sort the list so that the oldest entries appear first, and entries produced at the same time should be sorted by index number. Show the index number, time, and source for each entry. Write this information to a plain text file. Click me for proposed solution The cmdlet that returns a list of system patches is: get-eventlog -newest 50 -logname system | sort -property index | sort -property timegenerated -descending | select -property index , timegenerated , source > exercise13 . txt","title":"Exercise 2"},{"location":"Exercises/Exercises3/","text":"Show a table that includes only the names of the processes, their IDs, and whether they are responding to Windows (the Responding property shows that). Make the table take up a minimum of horizontal space, but don't allow the information to be truncated. Click me for proposed solution ps | ft -Property name , id , responding -Wrap Display a table that includes the names of the processes and their IDs. Also include columns for physical and virtual memory usage; Express those values \u200b\u200bin megabytes (MB). Click me for proposed solution ps | ft -Property name , id , @{ n = 'vm [MB]' ; e ={ $_ . vm / 1MB -as [INT] }}, @{ n = 'pm [MB]' ; e ={ $_ . pm / 1MB -as [INT] }} Use the cmdlet Get-EventLog to display a list of available event logs (check the help to find the parameter that will allow you to get that information). Format the output as a table that includes the log display name and the retention period. Column headers must be LogName and Per-Retention. Click me for proposed solution get-eventlog -list | ft -property @{ n = 'NombreLog' ; e ={ $_ . log }}, @{ n = 'Per-Retencion' ; e ={ $_ . MinimumRetentionDays }} Display a list of services, so that the services that are started and those that are stopped are grouped together. Those who are initiated must appear first. Click me for proposed solution gsv | sort -property status -descending | ft -groupby status Display a four-column list of all directories that are at the root of drive C: Click me for proposed solution ls 'C:/' | format-wide name -col 4 Create a formatted list of all .exe files in the C:\\Windows directory. The name, version information, and size of the file should be displayed. The size property is called length in Powershell, but for clarity, the column should be called Size in your listing. Click me for proposed solution ls 'C:\\Windows/*.exe' | ft name , @{ n = 'Size' ; e ={ $_ . Length }}, versionInfo -Wrap Import the NetAdapter module (using the Import-Module NetAdapter command). Using the Get-NetAdapter cmdlet, display a list of non-virtual adapters (adapters whose Virtual property is false. The boolean false is represented by Powershell as $False). Click me for proposed solution Get-NetAdapter | ? { $_ . Virtual -eq $False } | fl Import the DnsClient module. Using the Get-DnsClientCache cmdlet, list the A and AAAA records that are in the cache. Tip: If the cache is empty, visit some websites to populate it. Click me for proposed solution Get-DnsClientCache -type 'A' , 'AAAA' | fl Display a list of all .exe files in the C:\\Windows\\System32 directory that are larger than 5 MB. Click me for proposed solution ls 'C:\\Windows\\System32/*.exe' | ? { $_ . length -gt 5MB } | fl Display a list of patches that are security updates. Click me for proposed solution Get-HotFix | ? { $_ . description -eq \"Security Update\" } | fl Display a list of patches that have been installed by the Administrator user, which are updates. If you don't have any, look for user-installed patches System. Click me for proposed solution Get-HotFix | ? { $_ . Description -like \"*Update*\" -and $_ . InstalledBy -like \"*System*\" } | fl Generate a list of all running processes with the name Conhost or Svchost. Click me for proposed solution ps | ? { $_ . Name -eq 'conhost' -or $_ . Name -eq 'svchost' } | fl","title":"Exercise 3"},{"location":"Exercises/Exercises4/","text":"Which class can be used to query the IP address of a network adapter? Does that class have a method to release a DHCP address lease? Click me for proposed solution Get-WmiObject -List | where name -like ' * networkadapter * ## Method to release a DHCP address gwmi Win32_NetworkAdapter | gm | ? { $_ . membertype -like \"method\" } gwmi Win32_NetworkAdapterConfiguration | gm | ? { $_ . membertype -like \"method\" } Display a list of patches using WMI (Microsoft refers to patches as quick-fix engineering). Is the listing different from the one produced by the Get-Hotfix cmdlet? Click me for proposed solution gwmi Win32_QuickFixEngineering ## No difference with get-hotfix cmdlet diff -ReferenceObject ( gwmi Win32_QuickFixEngineering ) -DifferenceObject ( Get-Hotfix ) Using WMI, display a list of services, including their current status, their startup mode, and the accounts they use to login. Click me for proposed solution gwmi win32_service | fl status , startmode , startname Using CIM cmdlets, list all classes in the SecurityCenter2 namespace, which have product as part of the name. Click me for proposed solution get-cimclass -names root \\ SecurityCenter2 | ? cimclassname -like '*product*' Using CIM cmdlets, and the results of the previous exercise, display the names of the antispyware applications installed on the system. You can also check if there are antivirus products installed on the system. Click me for proposed solution ## Antivirus get-ciminstance -names root \\ SecurityCenter2 -class AntiVirusProduct ## Antispyware get-ciminstance -names root \\ SecurityCenter2 -class AntiSpywareProduct","title":"Exercise 4"},{"location":"Install/differences/","text":"Powershell 5 and Powershell ISE PowerShell 5 is a major version of the Windows PowerShell command-line shell and scripting language that was released in February 2016. It was designed primarily for Windows operating systems and provides a powerful tool for automating administrative tasks and managing systems. Some of the key features of PowerShell 5 include: Classes and enums for creating custom types Enhanced debugging support, including the ability to step through scripts and inspect variables Improved security with the introduction of Just Enough Administration (JEA) and PowerShell Scriptblock Logging PowerShell ISE (Integrated Scripting Environment) is an integrated development environment (IDE) that is included with PowerShell 5. It provides a graphical user interface (GUI) for developing, testing, and debugging PowerShell scripts and modules. Some of the key features of PowerShell ISE include: A code editor with syntax highlighting, code folding, and IntelliSense A console pane for executing PowerShell commands and scripts Debugging tools, including breakpoints and variable inspection Integration with version control systems like Git and Team Foundation Server PowerShell ISE was designed to make it easier for developers and system administrators to work with PowerShell scripts and modules, but it has been deprecated in favor of the new PowerShell 7 Integrated Console. The PowerShell 7 Integrated Console provides many of the same features as PowerShell ISE, but in a more modern and flexible interface that can be used on Windows, Linux, and macOS. Key Differences between Powershell 7 and 5 Cross-Platform Support One of the biggest differences between PowerShell 7 and 5 is cross-platform support. While PowerShell 5 was primarily designed for Windows operating systems, PowerShell 7 is designed to work on Windows, Linux, and macOS. This means that you can use PowerShell 7 to manage and automate tasks on a wide variety of systems, making it a more versatile tool. Improved Performance PowerShell 7 is also faster and more efficient than PowerShell 5. This is due in part to the fact that PowerShell 7 uses .NET Core 3.x, which provides better performance than the .NET Framework used by PowerShell 5. In addition, PowerShell 7 includes a number of performance optimizations that make it faster and more responsive. New Features PowerShell 7 includes many new features and improvements over PowerShell 5. Some of the most notable new features include: Pipeline Parallelization : PowerShell 7 can execute commands in parallel on multi-core CPUs, improving performance for certain operations. Ternary Operators : PowerShell 7 introduces a new ternary operator (condition ? true : false) that makes it easier to write concise code. New Data Types : PowerShell 7 adds support for new data types like System.Text.Json.JsonDocument, making it easier to work with JSON data. New cmdlets : PowerShell 7 includes many new cmdlets for managing systems and applications, as well as improved versions of existing cmdlets. Compatibility Finally, it's worth noting that PowerShell 7 is not fully backwards-compatible with PowerShell 5. While most scripts and modules written for PowerShell 5 should work fine in PowerShell 7, there may be some compatibility issues with certain scripts or modules. It's always a good idea to test your scripts and modules in PowerShell 7 before deploying them to production systems. PowerShell 7 Integrated Console in VSCode PowerShell 7 Integrated Console is a new feature in PowerShell 7 that provides many of the same features as PowerShell ISE, but in a more modern and flexible interface that can be used on Windows, Linux, and macOS. Here are some of the key differences between the two: Cross-Platform Support One of the biggest differences between PowerShell 7 Integrated Console and PowerShell ISE is cross-platform support. While PowerShell ISE was primarily designed for Windows operating systems, PowerShell 7 Integrated Console is designed to work on Windows, Linux, and macOS. This means that you can use PowerShell 7 Integrated Console to manage and automate tasks on a wide variety of systems, making it a more versatile tool. Improved Performance PowerShell 7 Integrated Console is also faster and more efficient than PowerShell ISE. This is due in part to the fact that PowerShell 7 uses .NET Core 3.x, which provides better performance than the .NET Framework used by PowerShell ISE. In addition, PowerShell 7 Integrated Console includes a number of performance optimizations that make it faster and more responsive. Features PowerShell 7 Integrated Console includes many of the same features as PowerShell ISE, such as a code editor with syntax highlighting, code folding, and IntelliSense, a console pane for executing PowerShell commands and scripts, and debugging tools like breakpoints and variable inspection. However, PowerShell 7 Integrated Console also includes some new features, such as: Interactive Notebooks : PowerShell 7 Integrated Console includes a new feature called Interactive Notebooks, which provides a way to create and share rich documents that combine text, code, and output. This feature is similar to Jupyter Notebooks in the Python world. Multiple Tabs : PowerShell 7 Integrated Console supports multiple tabs, so you can work on multiple scripts or tasks at the same time within the same window. Improved UI : PowerShell 7 Integrated Console has a modern and flexible user interface that can be customized to suit your needs. Deprecation Finally, it's worth noting that PowerShell ISE has been deprecated in favor of PowerShell 7 Integrated Console. Microsoft has stated that PowerShell ISE will not receive any new features or updates, and it will be removed in future versions of Windows. While PowerShell ISE will still be available in older versions of Windows that include PowerShell 5, it's recommended that you switch to PowerShell 7 Integrated Console for new development and management tasks. Additional Features of VSCode Powershell Extension The PowerShell extension for VSCode includes a number of additional features that aren't available in PowerShell 7 Integrated Console, such as: Code Snippets : The extension provides a library of code snippets that you can use to quickly insert common PowerShell commands and structures into your code. Task Runner : You can use the extension's Task Runner to automate repetitive tasks like running tests, building modules, or deploying scripts. Integrated Source Control : The extension includes support for integrated source control, so you can use Git or another version control system directly from within the VSCode editor. Overall, the PowerShell extension for VSCode provide powerful tools for working with PowerShell scripts and modules.","title":"Versions"},{"location":"Install/differences/#powershell-5-and-powershell-ise","text":"PowerShell 5 is a major version of the Windows PowerShell command-line shell and scripting language that was released in February 2016. It was designed primarily for Windows operating systems and provides a powerful tool for automating administrative tasks and managing systems. Some of the key features of PowerShell 5 include: Classes and enums for creating custom types Enhanced debugging support, including the ability to step through scripts and inspect variables Improved security with the introduction of Just Enough Administration (JEA) and PowerShell Scriptblock Logging PowerShell ISE (Integrated Scripting Environment) is an integrated development environment (IDE) that is included with PowerShell 5. It provides a graphical user interface (GUI) for developing, testing, and debugging PowerShell scripts and modules. Some of the key features of PowerShell ISE include: A code editor with syntax highlighting, code folding, and IntelliSense A console pane for executing PowerShell commands and scripts Debugging tools, including breakpoints and variable inspection Integration with version control systems like Git and Team Foundation Server PowerShell ISE was designed to make it easier for developers and system administrators to work with PowerShell scripts and modules, but it has been deprecated in favor of the new PowerShell 7 Integrated Console. The PowerShell 7 Integrated Console provides many of the same features as PowerShell ISE, but in a more modern and flexible interface that can be used on Windows, Linux, and macOS.","title":"Powershell 5 and Powershell ISE"},{"location":"Install/differences/#key-differences-between-powershell-7-and-5","text":"","title":"Key Differences between Powershell 7 and 5"},{"location":"Install/differences/#cross-platform-support","text":"One of the biggest differences between PowerShell 7 and 5 is cross-platform support. While PowerShell 5 was primarily designed for Windows operating systems, PowerShell 7 is designed to work on Windows, Linux, and macOS. This means that you can use PowerShell 7 to manage and automate tasks on a wide variety of systems, making it a more versatile tool.","title":"Cross-Platform Support"},{"location":"Install/differences/#improved-performance","text":"PowerShell 7 is also faster and more efficient than PowerShell 5. This is due in part to the fact that PowerShell 7 uses .NET Core 3.x, which provides better performance than the .NET Framework used by PowerShell 5. In addition, PowerShell 7 includes a number of performance optimizations that make it faster and more responsive.","title":"Improved Performance"},{"location":"Install/differences/#new-features","text":"PowerShell 7 includes many new features and improvements over PowerShell 5. Some of the most notable new features include: Pipeline Parallelization : PowerShell 7 can execute commands in parallel on multi-core CPUs, improving performance for certain operations. Ternary Operators : PowerShell 7 introduces a new ternary operator (condition ? true : false) that makes it easier to write concise code. New Data Types : PowerShell 7 adds support for new data types like System.Text.Json.JsonDocument, making it easier to work with JSON data. New cmdlets : PowerShell 7 includes many new cmdlets for managing systems and applications, as well as improved versions of existing cmdlets.","title":"New Features"},{"location":"Install/differences/#compatibility","text":"Finally, it's worth noting that PowerShell 7 is not fully backwards-compatible with PowerShell 5. While most scripts and modules written for PowerShell 5 should work fine in PowerShell 7, there may be some compatibility issues with certain scripts or modules. It's always a good idea to test your scripts and modules in PowerShell 7 before deploying them to production systems.","title":"Compatibility"},{"location":"Install/differences/#powershell-7-integrated-console-in-vscode","text":"PowerShell 7 Integrated Console is a new feature in PowerShell 7 that provides many of the same features as PowerShell ISE, but in a more modern and flexible interface that can be used on Windows, Linux, and macOS. Here are some of the key differences between the two:","title":"PowerShell 7 Integrated Console in VSCode"},{"location":"Install/differences/#cross-platform-support_1","text":"One of the biggest differences between PowerShell 7 Integrated Console and PowerShell ISE is cross-platform support. While PowerShell ISE was primarily designed for Windows operating systems, PowerShell 7 Integrated Console is designed to work on Windows, Linux, and macOS. This means that you can use PowerShell 7 Integrated Console to manage and automate tasks on a wide variety of systems, making it a more versatile tool.","title":"Cross-Platform Support"},{"location":"Install/differences/#improved-performance_1","text":"PowerShell 7 Integrated Console is also faster and more efficient than PowerShell ISE. This is due in part to the fact that PowerShell 7 uses .NET Core 3.x, which provides better performance than the .NET Framework used by PowerShell ISE. In addition, PowerShell 7 Integrated Console includes a number of performance optimizations that make it faster and more responsive.","title":"Improved Performance"},{"location":"Install/differences/#features","text":"PowerShell 7 Integrated Console includes many of the same features as PowerShell ISE, such as a code editor with syntax highlighting, code folding, and IntelliSense, a console pane for executing PowerShell commands and scripts, and debugging tools like breakpoints and variable inspection. However, PowerShell 7 Integrated Console also includes some new features, such as: Interactive Notebooks : PowerShell 7 Integrated Console includes a new feature called Interactive Notebooks, which provides a way to create and share rich documents that combine text, code, and output. This feature is similar to Jupyter Notebooks in the Python world. Multiple Tabs : PowerShell 7 Integrated Console supports multiple tabs, so you can work on multiple scripts or tasks at the same time within the same window. Improved UI : PowerShell 7 Integrated Console has a modern and flexible user interface that can be customized to suit your needs.","title":"Features"},{"location":"Install/differences/#deprecation","text":"Finally, it's worth noting that PowerShell ISE has been deprecated in favor of PowerShell 7 Integrated Console. Microsoft has stated that PowerShell ISE will not receive any new features or updates, and it will be removed in future versions of Windows. While PowerShell ISE will still be available in older versions of Windows that include PowerShell 5, it's recommended that you switch to PowerShell 7 Integrated Console for new development and management tasks.","title":"Deprecation"},{"location":"Install/differences/#additional-features-of-vscode-powershell-extension","text":"The PowerShell extension for VSCode includes a number of additional features that aren't available in PowerShell 7 Integrated Console, such as: Code Snippets : The extension provides a library of code snippets that you can use to quickly insert common PowerShell commands and structures into your code. Task Runner : You can use the extension's Task Runner to automate repetitive tasks like running tests, building modules, or deploying scripts. Integrated Source Control : The extension includes support for integrated source control, so you can use Git or another version control system directly from within the VSCode editor. Overall, the PowerShell extension for VSCode provide powerful tools for working with PowerShell scripts and modules.","title":"Additional Features of VSCode Powershell Extension"},{"location":"Install/installation/","text":"PowerShell 7 is the latest major release of PowerShell, and it provides many new features and improvements over previous versions. Here's how to install it on various operating systems: Windows On Windows, you can download the PowerShell 7 installer from the official PowerShell GitHub repository. Choose the MSI installer for your architecture (either x86 or x64) and download the file. Once the installer is downloaded, double-click on the file to start the installation wizard. Follow the on-screen instructions to complete the installation process. After installation is complete, you can open PowerShell 7 from the Start menu or by typing pwsh in the command prompt. Linux On Linux, you can install PowerShell 7 using your distribution's package manager. Here are the commands for some popular distributions: Ubuntu 18.04 and later, and Debian 10 and later: Run the following commands in the terminal: # Update the list of packages sudo apt - get update # Install pre - requisite packages . sudo apt - get install - y wget apt - transport - https software - properties - common # Download the Microsoft repository GPG keys wget - q \"https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb\" # Register the Microsoft repository GPG keys sudo dpkg - i packages - microsoft - prod . deb # Update the list of packages after we added packages . microsoft . com sudo apt - get update # Install PowerShell sudo apt - get install - y powershell # Start PowerShell pwsh macOS On macOS, you can install PowerShell 7 using Homebrew, a popular package manager for macOS. Run the following command in the terminal: brew install -- cask powershell After installation is complete, you can open PowerShell 7 from the Launchpad or by typing pwsh in the terminal.","title":"Multiplatform"},{"location":"Install/installation/#windows","text":"On Windows, you can download the PowerShell 7 installer from the official PowerShell GitHub repository. Choose the MSI installer for your architecture (either x86 or x64) and download the file. Once the installer is downloaded, double-click on the file to start the installation wizard. Follow the on-screen instructions to complete the installation process. After installation is complete, you can open PowerShell 7 from the Start menu or by typing pwsh in the command prompt.","title":"Windows"},{"location":"Install/installation/#linux","text":"On Linux, you can install PowerShell 7 using your distribution's package manager. Here are the commands for some popular distributions: Ubuntu 18.04 and later, and Debian 10 and later: Run the following commands in the terminal: # Update the list of packages sudo apt - get update # Install pre - requisite packages . sudo apt - get install - y wget apt - transport - https software - properties - common # Download the Microsoft repository GPG keys wget - q \"https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb\" # Register the Microsoft repository GPG keys sudo dpkg - i packages - microsoft - prod . deb # Update the list of packages after we added packages . microsoft . com sudo apt - get update # Install PowerShell sudo apt - get install - y powershell # Start PowerShell pwsh","title":"Linux"},{"location":"Install/installation/#macos","text":"On macOS, you can install PowerShell 7 using Homebrew, a popular package manager for macOS. Run the following command in the terminal: brew install -- cask powershell After installation is complete, you can open PowerShell 7 from the Launchpad or by typing pwsh in the terminal.","title":"macOS"},{"location":"Install/recommendations/","text":"When it comes to setting up your environment for programming in PowerShell, there are a few key tools and configurations that can help make your workflow more efficient and effective. Here are some recommendations for the best setup for programming in PowerShell: 1. Install PowerShell 7 PowerShell 7 is the latest version of PowerShell and includes many new features and improvements over previous versions. It's recommended that you install PowerShell 7 to take advantage of these new features and to ensure compatibility with the latest PowerShell modules and scripts. 2. Install an IDE Using a dedicated Text Editor or Integrated Development Environment IDE can help make your workflow more efficient and productive. Popular options for PowerShell development include Visual Studio Code, PowerShell ISE, and the PowerShell extension for Visual Studio. 3. Install the PowerShell Extension for Your IDE If you're using a text editor or IDE, it's recommended that you install the PowerShell extension for that editor or IDE. This extension provides additional tools and features for working with PowerShell scripts and modules, such as syntax highlighting, IntelliSense, debugging, and code formatting. 4. Install PowerShell Modules PowerShell modules are collections of PowerShell commands and scripts that you can use to extend the functionality of PowerShell. Many modules are available through the PowerShell Gallery, which is a repository of PowerShell modules that you can download and install using the Install-Module command. 5. Configure Your Profile PowerShell allows you to configure your profile to set up your environment with your preferred settings and modules every time you start a new session. You can use your profile to set environment variables, define aliases, and load modules automatically. Your profile is stored in a PowerShell script file named $PROFILE, which you can edit using a text editor or IDE. By following these recommendations, you can set up a powerful and efficient environment for programming in PowerShell. Whether you're a beginner or an experienced developer, having the right tools and configurations can help you write better PowerShell code and automate your tasks more effectively.","title":"Recommendations"},{"location":"Install/recommendations/#1-install-powershell-7","text":"PowerShell 7 is the latest version of PowerShell and includes many new features and improvements over previous versions. It's recommended that you install PowerShell 7 to take advantage of these new features and to ensure compatibility with the latest PowerShell modules and scripts.","title":"1. Install PowerShell 7"},{"location":"Install/recommendations/#2-install-an-ide","text":"Using a dedicated Text Editor or Integrated Development Environment IDE can help make your workflow more efficient and productive. Popular options for PowerShell development include Visual Studio Code, PowerShell ISE, and the PowerShell extension for Visual Studio.","title":"2. Install an IDE"},{"location":"Install/recommendations/#3-install-the-powershell-extension-for-your-ide","text":"If you're using a text editor or IDE, it's recommended that you install the PowerShell extension for that editor or IDE. This extension provides additional tools and features for working with PowerShell scripts and modules, such as syntax highlighting, IntelliSense, debugging, and code formatting.","title":"3. Install the PowerShell Extension for Your IDE"},{"location":"Install/recommendations/#4-install-powershell-modules","text":"PowerShell modules are collections of PowerShell commands and scripts that you can use to extend the functionality of PowerShell. Many modules are available through the PowerShell Gallery, which is a repository of PowerShell modules that you can download and install using the Install-Module command.","title":"4. Install PowerShell Modules"},{"location":"Install/recommendations/#5-configure-your-profile","text":"PowerShell allows you to configure your profile to set up your environment with your preferred settings and modules every time you start a new session. You can use your profile to set environment variables, define aliases, and load modules automatically. Your profile is stored in a PowerShell script file named $PROFILE, which you can edit using a text editor or IDE. By following these recommendations, you can set up a powerful and efficient environment for programming in PowerShell. Whether you're a beginner or an experienced developer, having the right tools and configurations can help you write better PowerShell code and automate your tasks more effectively.","title":"5. Configure Your Profile"},{"location":"Scripting/ConsoleIO/","text":"To enhance the usability of your scripts, you must learn how to accept user input. This skill allows you to create scripts that can be used for multiple purposes. In addition, accepting user input allows you to create scripts that are easier for others to use. Requesting Info The Read-Host cmdlet displays a request message, and then reads a response from the user. For example: Read-Host \"Enter a computer name\" Enter a computer name: SERVER SERVER The cmdlet adds a colon (:) after the request message, and places the user's response in the pipeline. In most cases, the user's response is captured in a variable, as in the following example: $computer = Read-Host \"Enter a computer name\" Enter a computer name : SERVER You can combine a Write-Host command with Read-Host to display text and avoid a colon being appended, as the following example depicts: Write-Host \"How many days? \" -NoNewline $answer = Read-Host Input from Read-Host is limited to 1022 characters. You can mask the input users enter at the prompt by using the -MaskInput or -AsSecureString parameters. Both parameters cause the characters entered by the user to display as asterisks (*). When -MaskInput is used, the response is collected as a String object. When -AsSecureString is used, the response is collected as a SecureString object. A SecureString object is required for scenarios such as setting passwords, where data shouldn't be stored as clear text in memory. Writing Info To write data to the console: Write-Host: Allows you to write data directly to the console, skipping the pipeline. For this reason, its output cannot be captured or redirected to logs. It is recommended not to use it. Write-Output: Allows data to be written to the pipeline. If there is no redirection to another command, the data will be output to the screen. This is the recommended way to print data to the console. Other ways: Powershell has other cmdlets to produce console output. None of them use the pipeline (they function as Write-Host), but their output can be suppressed at will, through the use of environment variables. The commands are the following: Command Description Write-Warning Prints the message in orange, preceded by the word WARNING. Its printing depends on the value of the $WarningPerference variable, which defaults to Continue. Write-Verbose Prints the message in blue, preceded by the word VERBOSE. Its printing depends on the value of the $VerbosePreference variable, which is set to SilentlyContinue by default. Write-Debug Prints the message in blue, preceded by the word DEBUG. Its printing depends on the value of the $DebugPreference variable, which defaults to SilentlyContinue. Write-error Generates an error message. Its printing depends on the value of the $ErrorActionPreference variable, which defaults to Continue. If the variable corresponding to the command has the value Continue, the message is printed. If the value is SilentlyContinue, the printing of the message is suppressed. Out-GridView Out-GridView is primarily used to review data. However, you can also use Out-GridView to create a simple menu selection interface. When the user makes one or more selections in the window presented by Out-GridView, the data for those objects is either passed further through the pipeline or placed into a variable. $selection = $users | Out-GridView -PassThru In the previous example, an array of user accounts is piped to Out-GridView. Out-GridView displays the user accounts on screen, and the user can select one or more rows in the Out-GridView window. When the user selects OK, the selected rows are stored in the $selection variable. You can then perform further processing on the users\u2019 accounts. To retain more control over the amount of data that users can select, you can use the -OutputMode parameter instead of the -PassThru parameter. The following table depicts the values that can be defined for the -OutputMode parameter. -OutputMode parameter Value Description None This is the default value that doesn't pass any objects further down the pipeline. Single This value allows users to select zero rows or one row in the Out-GridView window. Multiple This value allows users to select zero rows, one row, or multiple rows in the Out-GridView window. This value is equivalent to using the -PassThru parameter. Because users aren't forced to select a row in the Out-GridView window, you must ensure that your script properly handles the scenario where a row isn't selected.","title":"Console IO"},{"location":"Scripting/ConsoleIO/#requesting-info","text":"The Read-Host cmdlet displays a request message, and then reads a response from the user. For example: Read-Host \"Enter a computer name\" Enter a computer name: SERVER SERVER The cmdlet adds a colon (:) after the request message, and places the user's response in the pipeline. In most cases, the user's response is captured in a variable, as in the following example: $computer = Read-Host \"Enter a computer name\" Enter a computer name : SERVER You can combine a Write-Host command with Read-Host to display text and avoid a colon being appended, as the following example depicts: Write-Host \"How many days? \" -NoNewline $answer = Read-Host Input from Read-Host is limited to 1022 characters. You can mask the input users enter at the prompt by using the -MaskInput or -AsSecureString parameters. Both parameters cause the characters entered by the user to display as asterisks (*). When -MaskInput is used, the response is collected as a String object. When -AsSecureString is used, the response is collected as a SecureString object. A SecureString object is required for scenarios such as setting passwords, where data shouldn't be stored as clear text in memory.","title":"Requesting Info"},{"location":"Scripting/ConsoleIO/#writing-info","text":"To write data to the console: Write-Host: Allows you to write data directly to the console, skipping the pipeline. For this reason, its output cannot be captured or redirected to logs. It is recommended not to use it. Write-Output: Allows data to be written to the pipeline. If there is no redirection to another command, the data will be output to the screen. This is the recommended way to print data to the console. Other ways: Powershell has other cmdlets to produce console output. None of them use the pipeline (they function as Write-Host), but their output can be suppressed at will, through the use of environment variables. The commands are the following: Command Description Write-Warning Prints the message in orange, preceded by the word WARNING. Its printing depends on the value of the $WarningPerference variable, which defaults to Continue. Write-Verbose Prints the message in blue, preceded by the word VERBOSE. Its printing depends on the value of the $VerbosePreference variable, which is set to SilentlyContinue by default. Write-Debug Prints the message in blue, preceded by the word DEBUG. Its printing depends on the value of the $DebugPreference variable, which defaults to SilentlyContinue. Write-error Generates an error message. Its printing depends on the value of the $ErrorActionPreference variable, which defaults to Continue. If the variable corresponding to the command has the value Continue, the message is printed. If the value is SilentlyContinue, the printing of the message is suppressed.","title":"Writing Info"},{"location":"Scripting/ConsoleIO/#out-gridview","text":"Out-GridView is primarily used to review data. However, you can also use Out-GridView to create a simple menu selection interface. When the user makes one or more selections in the window presented by Out-GridView, the data for those objects is either passed further through the pipeline or placed into a variable. $selection = $users | Out-GridView -PassThru In the previous example, an array of user accounts is piped to Out-GridView. Out-GridView displays the user accounts on screen, and the user can select one or more rows in the Out-GridView window. When the user selects OK, the selected rows are stored in the $selection variable. You can then perform further processing on the users\u2019 accounts. To retain more control over the amount of data that users can select, you can use the -OutputMode parameter instead of the -PassThru parameter. The following table depicts the values that can be defined for the -OutputMode parameter.","title":"Out-GridView"},{"location":"Scripting/ConsoleIO/#-outputmode-parameter","text":"Value Description None This is the default value that doesn't pass any objects further down the pipeline. Single This value allows users to select zero rows or one row in the Out-GridView window. Multiple This value allows users to select zero rows, one row, or multiple rows in the Out-GridView window. This value is equivalent to using the -PassThru parameter. Because users aren't forced to select a row in the Out-GridView window, you must ensure that your script properly handles the scenario where a row isn't selected.","title":"-OutputMode parameter"},{"location":"Scripting/advanced/","text":"Adding the line [CmdletBinding()] after the help comments makes the script advanced, which allows you to return required parameters, set their data type, add aliases for parameters, etc. The final version of the example script is as follows: <# .SYNOPSIS Get-DiskInventory gets logical disk information for one or more computers. .DESCRIPTION Get-DiskInventory uses CIM to query the instances Win32_LogicalDisk from one or more computers. Display for each disk the drive letter, free space, total space, and percentage of free space. .PARAMETER DriveType The type of unit to query. View the Win32_LogicalDisk documentation for more information. 3 indicates a fixed disk, and is the default. .EXAMPLE Get-DiskInventory -DriveType 3 #> [ CmdletBinding ()] param ( [ Parameter ( Mandatory = $True )] [ Alias ( 'Type' )] [ ValidateSet ( 2 , 3 )] [int] $DriveType = 3 ) Get-CimInstance Win32_logicaldisk ` -filter \"drivetype=$DriveType\" | Sort-Object -Property DeviceID | Select-Object -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} The changes from the previous example are as follows: The directive to return the script advanced is included The parameter is now required, and the alias Type is created for it. The parameter is declared as an integer, and the only valid values \u200b\u200bit receives are 2 and 3. If you've configured your script as an advanced script by using CmdletBinding() in the Param() block, you can also use the cmdlets in the following table as part of your script for troubleshooting. Cmdlets for troubleshooting Cmdlet Description Write-Verbose Text specified by Write-Verbose is displayed only when you use the -Verbose parameter when running the script. The value of $VerbosePreference specifies the action to take after the Write-Verbose command. The default action is SilentlyContinue. Write-Debug Text specified by Write-Debug is displayed only when you use the -Debug parameter when running the script. The value of $DebugPreference specifies the action to take after the Write-Debug command. The default action is SilentlyContinue, which displays no information to screen. You need to change this action to Continue so that debug messages are displayed.","title":"Advanced Script"},{"location":"Scripting/advanced/#cmdlets-for-troubleshooting","text":"Cmdlet Description Write-Verbose Text specified by Write-Verbose is displayed only when you use the -Verbose parameter when running the script. The value of $VerbosePreference specifies the action to take after the Write-Verbose command. The default action is SilentlyContinue. Write-Debug Text specified by Write-Debug is displayed only when you use the -Debug parameter when running the script. The value of $DebugPreference specifies the action to take after the Write-Debug command. The default action is SilentlyContinue, which displays no information to screen. You need to change this action to Continue so that debug messages are displayed.","title":"Cmdlets for troubleshooting"},{"location":"Scripting/basic/","text":"Powershell scripts allow you to store a command or series of commands, for easier execution later. To produce a script, it is enough to record the required commands in a text file with the extension .ps1 . You can also use scripts to accomplish more complex tasks than are practical by using a single command. While it's technically possible to make a single Windows PowerShell command that's long and complex, it's impractical to manage. Placing complex tasks in a script makes editing simpler and easier to understand. Reporting is one complex and repetitive task that you can do with Windows PowerShell. You can use Windows PowerShell to create text or HTML-based reports. For example, you can create a script that reports available disk space on your servers, or you can create a script for Exchange that scans the message tracking logs to report on mail flow statistics. Scripts can also use constructs such as ForEach, If, and Switch, which are seldom used in a single command. You can use these constructs to process objects and make decisions in your scripts. For example, consider the following command, which prints a list of fixed disks attached to the system, along with their free space, total size, and free space percentage: Get-CimInstance Win32_logicaldisk ` -filter \"drivetype=3\" | Sort-Object -Property DeviceID | format-table -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} At the end of the first line the backtick ` is used to indicate that the command has not finished yet. In the rest of the lines, this job is done by vertical bars and commas. This way it is easier to read. By copying these lines of code and saving them to a text file called Get-DiskInventory.ps1, a script will be created. Parameterization Scripts can be parameterized, that is, parameters can be created that can be specified at the time the script is executed. For example, in the script of the previous example it is possible to return parameters the name of the computer and the type of unit. The parameterized script would look like this: param ( $DriveType = 3 ) Get-CimInstance Win32_logicaldisk ` -filter \"drivetype=$DriveType\" | Sort-Object -Property DeviceID | format-table -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} Optionally, each parameter can be specified with a default value, as seen in the example above. Parameters are positional by default. If the parameter names aren't specified, then the parameter values are passed to the parameters in order. If you don't put a Param() block in your script, you can still pass data into the script by using unnamed parameters. The values that are provided after the script name are available inside the script in the $args array. Run the script The script can be executed by typing its name in the console. If the script is saved in a different directory than the current one, the full path to the file must be written to execute it. In case the script does not execute, it is necessary to change the script execution policy to a more permissive value, using the Set-ExecutionPolicy cmdlet as administrator. See the cmdlet help for more details. An execution policy is a safety feature. Like requiring the path of a script, a policy can stop you from doing unintentional things. You can set the policy on various levels, like the local computer, current user, or particular session. You can also use a Group Policy setting to set execution policies for computers and users. . ./ Get-DiskInventory . ps1 To run a Windows PowerShell script at the Windows PowerShell prompt, you can use the following methods: Enter the full path to the script; for example, C:\\Scripts\\MyScript.ps1. Enter a relative path to the script; for example, \\Scripts\\MyScript.ps1. Reference the current directory; for example, .\\MyScript.ps1. Execution Policy You can control whether Windows PowerShell scripts can be run on Windows computers. You do this task by setting the execution policy on the computer. The default execution policy on a computer varies depending on the operating system version. To be sure of the current configuration, you can use the Get-ExecutionPolicy cmdlet. The options for the execution policy are: Restricted. No scripts are allowed to be run. AllSigned. Scripts can be run only if they're digitally signed. RemoteSigned. Scripts that are downloaded can only be run if they're digitally signed. Unrestricted. All scripts can be run, but a confirmation prompt displays when running unsigned scripts that are downloaded. Bypass. All scripts are run without prompts. Setting the script execution policy provides a safety net that can prevent untrusted scripts from being run accidentally. However, the execution policy can always be overridden. You can set the execution policy on a computer by using the Set-ExecutionPolicy cmdlet. However, this setting is difficult to manage across many computers. When you configure the execution policy for many computers, you can use the Computer Configuration\\Policies\\Administrative Templates\\Windows Components\\Windows PowerShell\\Turn on Script Execution Group Policy setting to override the local setting. You can override the execution policy for an individual Windows PowerShell instance. This setting is useful if company policy requires the execution policy to be set as Restricted, but you still must run scripts occasionally. To override the execution policy, run PowerShell.exe with the -ExecutionPolicy parameter. Powershell . exe -ExecutionPolicy ByPass If you've modified a script downloaded from the internet, the script still has the attributes that identify it as a downloaded file. To remove that status from a script, use the Unblock-File cmdlet. AppLocker While the Windows PowerShell script execution policy provides a safety net for inexperienced users, it's not very flexible. When you set an execution policy, you can only check that the script was downloaded and that it's signed. Another alternative for controlling the use of Windows PowerShell scripts is AppLocker. With AppLocker, you can set various restrictions that limit the running of specific scripts or scripts in specific locations. Also, unlike the AllSigned execution policy, AppLocker can allow scripts that are signed only by specific publishers.","title":"Basic Scripting"},{"location":"Scripting/basic/#parameterization","text":"Scripts can be parameterized, that is, parameters can be created that can be specified at the time the script is executed. For example, in the script of the previous example it is possible to return parameters the name of the computer and the type of unit. The parameterized script would look like this: param ( $DriveType = 3 ) Get-CimInstance Win32_logicaldisk ` -filter \"drivetype=$DriveType\" | Sort-Object -Property DeviceID | format-table -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} Optionally, each parameter can be specified with a default value, as seen in the example above. Parameters are positional by default. If the parameter names aren't specified, then the parameter values are passed to the parameters in order. If you don't put a Param() block in your script, you can still pass data into the script by using unnamed parameters. The values that are provided after the script name are available inside the script in the $args array.","title":"Parameterization"},{"location":"Scripting/basic/#run-the-script","text":"The script can be executed by typing its name in the console. If the script is saved in a different directory than the current one, the full path to the file must be written to execute it. In case the script does not execute, it is necessary to change the script execution policy to a more permissive value, using the Set-ExecutionPolicy cmdlet as administrator. See the cmdlet help for more details. An execution policy is a safety feature. Like requiring the path of a script, a policy can stop you from doing unintentional things. You can set the policy on various levels, like the local computer, current user, or particular session. You can also use a Group Policy setting to set execution policies for computers and users. . ./ Get-DiskInventory . ps1 To run a Windows PowerShell script at the Windows PowerShell prompt, you can use the following methods: Enter the full path to the script; for example, C:\\Scripts\\MyScript.ps1. Enter a relative path to the script; for example, \\Scripts\\MyScript.ps1. Reference the current directory; for example, .\\MyScript.ps1.","title":"Run the script"},{"location":"Scripting/basic/#execution-policy","text":"You can control whether Windows PowerShell scripts can be run on Windows computers. You do this task by setting the execution policy on the computer. The default execution policy on a computer varies depending on the operating system version. To be sure of the current configuration, you can use the Get-ExecutionPolicy cmdlet. The options for the execution policy are: Restricted. No scripts are allowed to be run. AllSigned. Scripts can be run only if they're digitally signed. RemoteSigned. Scripts that are downloaded can only be run if they're digitally signed. Unrestricted. All scripts can be run, but a confirmation prompt displays when running unsigned scripts that are downloaded. Bypass. All scripts are run without prompts. Setting the script execution policy provides a safety net that can prevent untrusted scripts from being run accidentally. However, the execution policy can always be overridden. You can set the execution policy on a computer by using the Set-ExecutionPolicy cmdlet. However, this setting is difficult to manage across many computers. When you configure the execution policy for many computers, you can use the Computer Configuration\\Policies\\Administrative Templates\\Windows Components\\Windows PowerShell\\Turn on Script Execution Group Policy setting to override the local setting. You can override the execution policy for an individual Windows PowerShell instance. This setting is useful if company policy requires the execution policy to be set as Restricted, but you still must run scripts occasionally. To override the execution policy, run PowerShell.exe with the -ExecutionPolicy parameter. Powershell . exe -ExecutionPolicy ByPass If you've modified a script downloaded from the internet, the script still has the attributes that identify it as a downloaded file. To remove that status from a script, use the Unblock-File cmdlet.","title":"Execution Policy"},{"location":"Scripting/basic/#applocker","text":"While the Windows PowerShell script execution policy provides a safety net for inexperienced users, it's not very flexible. When you set an execution policy, you can only check that the script was downloaded and that it's signed. Another alternative for controlling the use of Windows PowerShell scripts is AppLocker. With AppLocker, you can set various restrictions that limit the running of specific scripts or scripts in specific locations. Also, unlike the AllSigned execution policy, AppLocker can allow scripts that are signed only by specific publishers.","title":"AppLocker"},{"location":"Scripting/break_cont/","text":"Break and Continue are two commands that you can use to modify the default behavior of a loop. Continue ends the processing for the current iteration of the loop. Break completely stops the loop processing. You typically use these commands when the data you're processing has an invalid value. In this example, the use of Continue prevents modification of the Administrator user account in the list of users to be modified: ForEach ( $user in $users ) { If ( $user . Name -eq \"Administrator\" ) { Continue } Write-Host \"Modify user object\" } In this example, Break is used to end the loop when a maximum number of accounts has been modified: ForEach ( $user in $users ) { $number ++ Write-Host \"Modify User object $number\" If ( $number -ge $max ) { Break } }","title":"Break & Continue"},{"location":"Scripting/comments/","text":"Scripts can be documented in such a way that they provide help similar to that provided by Powershell. The documented script would look like this: <# .SYNOPSIS Get-DiskInventory gets logical disk information for one or more computers. .DESCRIPTION Get-DiskInventory uses CIM to query the instances Win32_LogicalDisk from one or more computers. Display for each disk the drive letter, free space, total space, and percentage of free space. .PARAMETER DriveType The type of unit to query. View the Win32_LogicalDisk documentation for more information. 3 indicates a fixed disk, and is the default. .EXAMPLE Get-DiskInventory -DriveType 3 #> param ( $DriveType = 3 ) Get-CimInstance -Class Win32_logicaldisk ` -filter \"drivetype=$DriveType\" | Sort-Object -Property DeviceID | Select-Object -Property DeviceID , @{ n = 'FreeSpace(MB)' ; e ={ $_ . FreeSpace / 1MB -as [int] }}, @{ n = 'Size(GB)' ; e ={ $_ . Size / 1GB -as [int] }}, @{ n = '%Free' ; e ={ $_ . FreeSpace / $_ . Size * 100 -as [int] }} Comments can be specified with a # symbol before each comment line, or with the notation <# #> if there are several consecutive lines of comments. A slight change was also made to the script: instead of using the Format-Table cmdlet, Select-Object is used, so as not to produce a formatted table as output. Using Select-Object the final output of the script is an object, so the end user can chain the script with other commands using the pipeline.","title":"Script Documentation"},{"location":"Scripting/cond/","text":"Flow control refers to how your code runs in your console or script. If, ElseIf, and Else You can use an If construct to determine if an expression is True or False. $True indicates that an expression is True. $False indicates that an expression is False. # _FullyTax.ps1_ # Possible values: 'Minor', 'Adult', 'Senior Citizen' $Status = 'Minor' If ( $Status -eq 'Minor' ) { Write-Host $False } ElseIf ( $Status -eq 'Adult' ) { Write-Host $True } Else { Write-Host $False } You can use the If construct in Windows PowerShell to make decisions. You also can use it to evaluate data you've queried or user input. For example, you could have an If statement that displays a warning if available disk space is low. The If construct uses the following syntax: If ( $freeSpace -le 5GB ) { Write-Host \"Free disk space is less than 5 GB\" } ElseIf ( $freeSpace -le 10GB ) { Write-Host \"Free disk space is less than 10 GB\" } Else { Write-Host \"Free disk space is more than 10 GB\" } Switch The Switch construct is similar to an If construct that has multiple ElseIf sections. The Switch construct evaluates a single variable or item against multiple values and has a script block for each value. The script block for each value is run if that value matches the variable. There's also a Default section that runs only if there are no matches. The Switch construct uses the following syntax: Switch ( $choice ) { 1 { Write-Host \"You selected menu item 1\" } 2 { Write-Host \"You selected menu item 2\" } 3 { Write-Host \"You selected menu item 3\" } Default { Write-Host \"You did not select a valid option\" } } In addition to matching values, the Switch construct can also be used to match patterns. You can use the -wildcard parameter to perform pattern matching by using the same syntax as the -like operator. Alternatively, you can use the -regex parameter to perform matching by using regular expressions. It's important to be aware that when you use pattern matching, multiple matches are possible. When there are multiple matches, the script blocks for all matching patterns are run. This is different from an If construct in which only one script block is run. The following example uses pattern matching: Switch -WildCard ( $ip ) { \"10.*\" { Write-Host \"This computer is on the internal network\" } \"10.1.*\" { Write-Host \"This computer is in London\" } \"10.2.*\" { Write-Host \"This computer is in Vancouver\" } Default { Write-Host \"This computer is not on the internal network\" } } For values of $ip on the London or Vancouver networks, two messages will be displayed. If $ip includes an IP address on the 10.x.x.x network, the messages will indicate that the computer is on the internal network and that the computer is in either London or Vancouver. If $ip is not an IP address on the 10.x.x.x network, the message indicates that it's not on the internal network. If you provide multiple values in an array to a Switch construct, each item in the array is evaluated. In the previous example, if the variable $ip was an array with two IP addresses, then both IP addresses would be processed. The actions appropriate for each item in the array would be performed.","title":"Conditionals"},{"location":"Scripting/cond/#if-elseif-and-else","text":"You can use an If construct to determine if an expression is True or False. $True indicates that an expression is True. $False indicates that an expression is False. # _FullyTax.ps1_ # Possible values: 'Minor', 'Adult', 'Senior Citizen' $Status = 'Minor' If ( $Status -eq 'Minor' ) { Write-Host $False } ElseIf ( $Status -eq 'Adult' ) { Write-Host $True } Else { Write-Host $False } You can use the If construct in Windows PowerShell to make decisions. You also can use it to evaluate data you've queried or user input. For example, you could have an If statement that displays a warning if available disk space is low. The If construct uses the following syntax: If ( $freeSpace -le 5GB ) { Write-Host \"Free disk space is less than 5 GB\" } ElseIf ( $freeSpace -le 10GB ) { Write-Host \"Free disk space is less than 10 GB\" } Else { Write-Host \"Free disk space is more than 10 GB\" }","title":"If, ElseIf, and Else"},{"location":"Scripting/cond/#switch","text":"The Switch construct is similar to an If construct that has multiple ElseIf sections. The Switch construct evaluates a single variable or item against multiple values and has a script block for each value. The script block for each value is run if that value matches the variable. There's also a Default section that runs only if there are no matches. The Switch construct uses the following syntax: Switch ( $choice ) { 1 { Write-Host \"You selected menu item 1\" } 2 { Write-Host \"You selected menu item 2\" } 3 { Write-Host \"You selected menu item 3\" } Default { Write-Host \"You did not select a valid option\" } } In addition to matching values, the Switch construct can also be used to match patterns. You can use the -wildcard parameter to perform pattern matching by using the same syntax as the -like operator. Alternatively, you can use the -regex parameter to perform matching by using regular expressions. It's important to be aware that when you use pattern matching, multiple matches are possible. When there are multiple matches, the script blocks for all matching patterns are run. This is different from an If construct in which only one script block is run. The following example uses pattern matching: Switch -WildCard ( $ip ) { \"10.*\" { Write-Host \"This computer is on the internal network\" } \"10.1.*\" { Write-Host \"This computer is in London\" } \"10.2.*\" { Write-Host \"This computer is in Vancouver\" } Default { Write-Host \"This computer is not on the internal network\" } } For values of $ip on the London or Vancouver networks, two messages will be displayed. If $ip includes an IP address on the 10.x.x.x network, the messages will indicate that the computer is on the internal network and that the computer is in either London or Vancouver. If $ip is not an IP address on the 10.x.x.x network, the message indicates that it's not on the internal network. If you provide multiple values in an array to a Switch construct, each item in the array is evaluated. In the previous example, if the variable $ip was an array with two IP addresses, then both IP addresses would be processed. The actions appropriate for each item in the array would be performed.","title":"Switch"},{"location":"Scripting/ds/","text":"Array An array is a data structure that's designed to store a collection of items of the same type. You can think of an array as a variable containing multiple values or objects. Variables that contain a single value are useful, but for complex tasks you often need to work with groups of items. For example, you might need to update the Voice over IP (VoIP) attribute on multiple domain user accounts. Or you might need to check the status of a group of services and restart all of them that are stopped. When you put multiple objects or values into a variable, it becomes an array. Creating Arrays You can create an array by providing multiple values in a comma-separated list. For example: $computers = \"LON-DC1\" , \"LON-SRV1\" , \"LON-SRV2\" $numbers = 228 , 43 , 102 To create an array of strings, you put quotes around each item. If you put one set of quotes around all the items, it's treated as a single string. You also can create an array by using the output from a command. For example: $users = Get-ADUser -Filter * $files = Get-ChildItem C :\\ ou can verify whether a variable is an array by using the GetType() method on the variable. The BaseType listed will be System.Array. You can create an empty array before you're ready to put content in it. This can be useful when you have a loop later on in a script that adds items to the array. For example: $newUsers = @() You also can force an array to be created when adding a single value to a variable. This creates an array with a single value into which you can add items later. For example: [array] $computers = \"LON-DC1\" Working With Arrays Display Item $users [ 0 ] Add Item $users = $users + $user1 # or $users += $user1 To Identify To identify what you can do with the content in an array, use the Get-Member cmdlet. Pipe the contents of the array to Get-Member, and the results returned identify the properties and methods that you can use for the items in the array. For example: $files | Get-Member When you pipe an array containing mixed data types to Get-Member, results are returned for each data type. This is also a helpful way of determining which data types are in the array. To review the properties and methods available for an array rather than the items within the array, use the following syntax: Get-Member -InputObject $files ArrayLists The default type of array that Windows PowerShell creates is a fixed-size array. This means that when you add an item to the array, the array is actually recreated with the additional item. When you work with relatively small arrays, this is not a concern. However, if you add thousands of items to an array one by one, recreating an array each time has a negative performance impact. The other concern when using fixed-size arrays is removing items. There's no simple method to remove an item from a fixed-size array. To address the shortcomings of arrays, you can use an array list. An array list functions similar to an array, except that it doesn't have a fixed size. This means that you can use methods to add and remove items. Creating ArrayLists [System.Collections.ArrayList] $computers = \"LON-DC1\" , \"LON-SVR1\" , \"LON-CL1\" To create an array list that's empty and ready to add items, use the following syntax: $computers = New-Object System . Collections . ArrayList ArrayList Methods $computers . Add ( \"LON-SRV2\" ) $computers . Remove ( \"LON-CL1\" ) When you remove an item from an array list, if there are multiple matching items then only the first instance is removed. If you want to remove an item from an array list based on the index number, you use the RemoveAt() method. For example: $computers . RemoveAt ( 1 ) Hash Tables A hash table represents a similar concept to an array since it stores multiple items. However, unlike an array which uses an index number to identify each item, a hash table uses for this purpose a unique key. The key is a string that's a unique identifier for the item. Each key in a hash table is associated with a value. You can use a hash table to store both IP addresses and the computer names as the following table depicts. Key Value LON-DC1 192.168.0.10 LON-SRV1 192.168.0.11 LON-SRV2 192.168.0.12 If the hash table is named $servers, then you access the first item in the hash table by using either of the following options: $servers . 'LON-DC1' $servers [ 'LON-DC1' ] You only need to use single quote marks to enclose keys that contain special characters. In the previous example, the hyphen in the computer names is a special character, which requires the key name to be enclosed in single quote marks. Working with Hash Tables Working with hash tables is similar to working with an array, except that to add items to a hash table you need to provide both the key for the item and the value. $servers = @{ \"LON-DC1\" = \"172.16.0.10\" ; \"LON-SRV1\" = \"172.16.0.11\" } Notice the following syntax in the previous example: It begins with the at (@) symbol. The keys and associated values are enclosed in braces. The items are separated by a semicolon. The semicolon between hash table items is required in the previous example because they're all on the same line. If you place each item on a separate line, it's not necessary to use semicolons as separators. $servers . Add ( \"LON-SRV2\" , \"172.16.0.12\" ) $servers . Remove ( \"LON-DC1\" ) # Update the value for a key $servers . \"LON-SRV2\" = \"172.16.0.100\"","title":"Data Structures"},{"location":"Scripting/ds/#array","text":"An array is a data structure that's designed to store a collection of items of the same type. You can think of an array as a variable containing multiple values or objects. Variables that contain a single value are useful, but for complex tasks you often need to work with groups of items. For example, you might need to update the Voice over IP (VoIP) attribute on multiple domain user accounts. Or you might need to check the status of a group of services and restart all of them that are stopped. When you put multiple objects or values into a variable, it becomes an array.","title":"Array"},{"location":"Scripting/ds/#creating-arrays","text":"You can create an array by providing multiple values in a comma-separated list. For example: $computers = \"LON-DC1\" , \"LON-SRV1\" , \"LON-SRV2\" $numbers = 228 , 43 , 102 To create an array of strings, you put quotes around each item. If you put one set of quotes around all the items, it's treated as a single string. You also can create an array by using the output from a command. For example: $users = Get-ADUser -Filter * $files = Get-ChildItem C :\\ ou can verify whether a variable is an array by using the GetType() method on the variable. The BaseType listed will be System.Array. You can create an empty array before you're ready to put content in it. This can be useful when you have a loop later on in a script that adds items to the array. For example: $newUsers = @() You also can force an array to be created when adding a single value to a variable. This creates an array with a single value into which you can add items later. For example: [array] $computers = \"LON-DC1\"","title":"Creating Arrays"},{"location":"Scripting/ds/#working-with-arrays","text":"","title":"Working With Arrays"},{"location":"Scripting/ds/#display-item","text":"$users [ 0 ]","title":"Display Item"},{"location":"Scripting/ds/#add-item","text":"$users = $users + $user1 # or $users += $user1","title":"Add Item"},{"location":"Scripting/ds/#to-identify","text":"To identify what you can do with the content in an array, use the Get-Member cmdlet. Pipe the contents of the array to Get-Member, and the results returned identify the properties and methods that you can use for the items in the array. For example: $files | Get-Member When you pipe an array containing mixed data types to Get-Member, results are returned for each data type. This is also a helpful way of determining which data types are in the array. To review the properties and methods available for an array rather than the items within the array, use the following syntax: Get-Member -InputObject $files","title":"To Identify"},{"location":"Scripting/ds/#arraylists","text":"The default type of array that Windows PowerShell creates is a fixed-size array. This means that when you add an item to the array, the array is actually recreated with the additional item. When you work with relatively small arrays, this is not a concern. However, if you add thousands of items to an array one by one, recreating an array each time has a negative performance impact. The other concern when using fixed-size arrays is removing items. There's no simple method to remove an item from a fixed-size array. To address the shortcomings of arrays, you can use an array list. An array list functions similar to an array, except that it doesn't have a fixed size. This means that you can use methods to add and remove items.","title":"ArrayLists"},{"location":"Scripting/ds/#creating-arraylists","text":"[System.Collections.ArrayList] $computers = \"LON-DC1\" , \"LON-SVR1\" , \"LON-CL1\" To create an array list that's empty and ready to add items, use the following syntax: $computers = New-Object System . Collections . ArrayList","title":"Creating ArrayLists"},{"location":"Scripting/ds/#arraylist-methods","text":"$computers . Add ( \"LON-SRV2\" ) $computers . Remove ( \"LON-CL1\" ) When you remove an item from an array list, if there are multiple matching items then only the first instance is removed. If you want to remove an item from an array list based on the index number, you use the RemoveAt() method. For example: $computers . RemoveAt ( 1 )","title":"ArrayList Methods"},{"location":"Scripting/ds/#hash-tables","text":"A hash table represents a similar concept to an array since it stores multiple items. However, unlike an array which uses an index number to identify each item, a hash table uses for this purpose a unique key. The key is a string that's a unique identifier for the item. Each key in a hash table is associated with a value. You can use a hash table to store both IP addresses and the computer names as the following table depicts. Key Value LON-DC1 192.168.0.10 LON-SRV1 192.168.0.11 LON-SRV2 192.168.0.12 If the hash table is named $servers, then you access the first item in the hash table by using either of the following options: $servers . 'LON-DC1' $servers [ 'LON-DC1' ] You only need to use single quote marks to enclose keys that contain special characters. In the previous example, the hyphen in the computer names is a special character, which requires the key name to be enclosed in single quote marks.","title":"Hash Tables"},{"location":"Scripting/ds/#working-with-hash-tables","text":"Working with hash tables is similar to working with an array, except that to add items to a hash table you need to provide both the key for the item and the value. $servers = @{ \"LON-DC1\" = \"172.16.0.10\" ; \"LON-SRV1\" = \"172.16.0.11\" } Notice the following syntax in the previous example: It begins with the at (@) symbol. The keys and associated values are enclosed in braces. The items are separated by a semicolon. The semicolon between hash table items is required in the previous example because they're all on the same line. If you place each item on a separate line, it's not necessary to use semicolons as separators. $servers . Add ( \"LON-SRV2\" , \"172.16.0.12\" ) $servers . Remove ( \"LON-DC1\" ) # Update the value for a key $servers . \"LON-SRV2\" = \"172.16.0.100\"","title":"Working with Hash Tables"},{"location":"Scripting/functions/","text":"When you create many scripts, you'll have snippets of code that you want to reuse. You'll also have snippets of code that you want to reuse within the same script. Rather than having the same code display multiple times in a script, you can create a function that displays once in the script, but is called multiple times. If you need to use the same code across multiple scripts, then you can put the function into a module that can be shared by multiple scripts. When you call a function, you can pass data to it. You use the Param() block for a function in the same way as you do for a script. After the declaration for the function, insert the Param() block and the definitions for any variables that are expected to be passed to the function. Function Get-SecurityEvent { Param ( [string] $ComputerName ) #end Param Get-EventLog -LogName Security -ComputerName - $ComputerName -Newest 10 } To call the function within a script, use the following syntax: Get-SecurityEvent -ComputerName LON-DC1 Variable Scopes Scope Description Global The global scope is for the Windows PowerShell prompt. Variables set at the Windows PowerShell prompt can be reviewed in all the scripts started at that Windows PowerShell prompt. Variables created at a Windows PowerShell prompt don't exist in other Windows PowerShell prompts or in instances of the Windows PowerShell Integrated Scripting Environment (ISE). Script The script scope is for a single script. Variables set within a script can be reviewed by all the functions within that script. If you set a variable value in the script scope that already exists in the global scope, a new variable is created in the script scope. There are then two variables of the same name in two separate scopes. At this point, when you review the value of the variable in the script, the value of the variable in the script scope is returned. Function The function scope is for a single function. Variables set within a function aren't shared with other functions or the script. If you set a variable value in the function scope that already exists in the global or script scope, a new variable is created in the function scope. Then, there are two variables of the same name in two separate scopes. In addition to reviewing a variable in a higher-level scope, you can also modify that variable by specifically referencing the scope of the variable when you modify it. To modify a script scope variable from a function, use the following syntax: $script:var = \"Modified from function\" It's a best practice to avoid modifying variables between scopes, because doing so can cause confusion. Instead, set the script scope variable equal to the output of the function. If the data in the function is in a variable, you can use Return() to pass it back to the script. The following is an example of using Return() at the end of a function to pass a variable value back to the script scope: Return ( $users ) Using Return() in a function adds the specified data to the pipeline of data being returned, but doesn't replace existing data in the pipeline. As part of script development, you need to verify exactly which data is being returned by a function.","title":"Functions"},{"location":"Scripting/functions/#variable-scopes","text":"Scope Description Global The global scope is for the Windows PowerShell prompt. Variables set at the Windows PowerShell prompt can be reviewed in all the scripts started at that Windows PowerShell prompt. Variables created at a Windows PowerShell prompt don't exist in other Windows PowerShell prompts or in instances of the Windows PowerShell Integrated Scripting Environment (ISE). Script The script scope is for a single script. Variables set within a script can be reviewed by all the functions within that script. If you set a variable value in the script scope that already exists in the global scope, a new variable is created in the script scope. There are then two variables of the same name in two separate scopes. At this point, when you review the value of the variable in the script, the value of the variable in the script scope is returned. Function The function scope is for a single function. Variables set within a function aren't shared with other functions or the script. If you set a variable value in the function scope that already exists in the global or script scope, a new variable is created in the function scope. Then, there are two variables of the same name in two separate scopes. In addition to reviewing a variable in a higher-level scope, you can also modify that variable by specifically referencing the scope of the variable when you modify it. To modify a script scope variable from a function, use the following syntax: $script:var = \"Modified from function\" It's a best practice to avoid modifying variables between scopes, because doing so can cause confusion. Instead, set the script scope variable equal to the output of the function. If the data in the function is in a variable, you can use Return() to pass it back to the script. The following is an example of using Return() at the end of a function to pass a variable value back to the script scope: Return ( $users ) Using Return() in a function adds the specified data to the pipeline of data being returned, but doesn't replace existing data in the pipeline. As part of script development, you need to verify exactly which data is being returned by a function.","title":"Variable Scopes"},{"location":"Scripting/loops/","text":"While there are some simple scripts that use only simple Windows PowerShell commands, most scripts use scripting constructs to perform more complex actions. You can use the ForEach construct to process all of the objects in an array. You can use If..Else and Switch constructs to make decisions in your scripts. Finally, there are less common looping constructs such as For, While, and Do..While loops that can be used when appropriate. ForEach When you perform piping, the commands in the pipeline are applied to each object. In some cases, you might need to use the ForEach-Object cmdlet to process the data in the pipeline. When you store data in an array, the ForEach construct allows you to process each item in the array. The ForEach construct uses the following syntax: ForEach ( $user in $users ) { Set-ADUser $user -Department \"Marketing\" } In a script, the ForEach construct is the most common way to process items that you've placed into an array. It's easy to use because you don't need to know the number of items to process them. Parallel performance In PowerShell 7, the -Parallel parameter was added to the ForEach-Object cmdlet. This allows the pipeline to process multiple objects simultaneously. Processing multiple objects simultaneously can provide better performance than a standard ForEach loop. $users | ForEach -Object -Parallel { Set-ADUser $user -Department \"Marketing\" } By default, the -Parallel parameter allows five items to be processed at a time. You can modify this to be larger or smaller by using the -ThrottleLimit parameter. For The For construct performs a series of loops similar to a ForEach construct. However, when using the For construct, you must define how many loops occur, which is useful when you want an action to be performed a specific number of times. For example, you could create a specific number of user accounts in a test environment. The For construct uses the following syntax: For ( $i = 1 ; $i -le 10 ; $i ++) { Write-Host \"Creating User $i\" } The For construct uses an initial state, a condition, and an action. In the previous example, the initial state is $i=1. The condition is $i -le 10. When the condition specified is true, another loop is processed. After each loop is processed, the action is performed. In this example, the action is $i++, which increments $i by 1. The script block inside the braces is run each time the loop is processed. In the previous example, this loop is processed 10 times. When you're processing an array of objects, using the ForEach construct is preferred because you don't need to calculate the number of items in the array before processing. Other Loops There are other less common looping constructs that you can use. These looping constructs are Do..While, Do..Until, and While. All these looping constructs process a script block until a condition is met, but they vary in how they do it. Do..While The Do..While construct runs a script block until a specified condition isn't true. This construct guarantees that the script block is run at least once. The Do..While construct uses the following syntax: Do { Write-Host \"Script block to process\" } While ( $answer -eq \"go\" ) Do..Until The Do..Until construct runs a script block until a specified condition is true. This construct guarantees that the script block is run at least once. The Do..Until construct uses the following syntax: Do { Write-Host \"Script block to process\" } Until ( $answer -eq \"stop\" ) While The While construct runs a script block until a specified condition is false. While it's similar to the Do..While construct, it doesn't guarantee that the script block is run. The While construct uses the following syntax: While ( $answer -eq \"go\" ) { Write-Host \"Script block to process\" }","title":"Loops"},{"location":"Scripting/loops/#foreach","text":"When you perform piping, the commands in the pipeline are applied to each object. In some cases, you might need to use the ForEach-Object cmdlet to process the data in the pipeline. When you store data in an array, the ForEach construct allows you to process each item in the array. The ForEach construct uses the following syntax: ForEach ( $user in $users ) { Set-ADUser $user -Department \"Marketing\" } In a script, the ForEach construct is the most common way to process items that you've placed into an array. It's easy to use because you don't need to know the number of items to process them.","title":"ForEach"},{"location":"Scripting/loops/#parallel-performance","text":"In PowerShell 7, the -Parallel parameter was added to the ForEach-Object cmdlet. This allows the pipeline to process multiple objects simultaneously. Processing multiple objects simultaneously can provide better performance than a standard ForEach loop. $users | ForEach -Object -Parallel { Set-ADUser $user -Department \"Marketing\" } By default, the -Parallel parameter allows five items to be processed at a time. You can modify this to be larger or smaller by using the -ThrottleLimit parameter.","title":"Parallel performance"},{"location":"Scripting/loops/#for","text":"The For construct performs a series of loops similar to a ForEach construct. However, when using the For construct, you must define how many loops occur, which is useful when you want an action to be performed a specific number of times. For example, you could create a specific number of user accounts in a test environment. The For construct uses the following syntax: For ( $i = 1 ; $i -le 10 ; $i ++) { Write-Host \"Creating User $i\" } The For construct uses an initial state, a condition, and an action. In the previous example, the initial state is $i=1. The condition is $i -le 10. When the condition specified is true, another loop is processed. After each loop is processed, the action is performed. In this example, the action is $i++, which increments $i by 1. The script block inside the braces is run each time the loop is processed. In the previous example, this loop is processed 10 times. When you're processing an array of objects, using the ForEach construct is preferred because you don't need to calculate the number of items in the array before processing.","title":"For"},{"location":"Scripting/loops/#other-loops","text":"There are other less common looping constructs that you can use. These looping constructs are Do..While, Do..Until, and While. All these looping constructs process a script block until a condition is met, but they vary in how they do it.","title":"Other Loops"},{"location":"Scripting/loops/#dowhile","text":"The Do..While construct runs a script block until a specified condition isn't true. This construct guarantees that the script block is run at least once. The Do..While construct uses the following syntax: Do { Write-Host \"Script block to process\" } While ( $answer -eq \"go\" )","title":"Do..While"},{"location":"Scripting/loops/#dountil","text":"The Do..Until construct runs a script block until a specified condition is true. This construct guarantees that the script block is run at least once. The Do..Until construct uses the following syntax: Do { Write-Host \"Script block to process\" } Until ( $answer -eq \"stop\" )","title":"Do..Until"},{"location":"Scripting/loops/#while","text":"The While construct runs a script block until a specified condition is false. While it's similar to the Do..While construct, it doesn't guarantee that the script block is run. The While construct uses the following syntax: While ( $answer -eq \"go\" ) { Write-Host \"Script block to process\" }","title":"While"},{"location":"Scripting/variables/","text":"Powershell allows you to store values \u200b\u200bin variables. All variable names begin with the $ sign, and are made up of letters, numbers, and the underscore (_). The assignment operator is the equal sign (=). Some examples: Command Description $server = \"localhost\" The variable will contain a text string $number = 5 The variable will contain an integer $services = Get-Service The variable will contain a list of services If you want to query the type of data a variable contains, you can do so with the Get-Member cmdlet. Get-Member also displays the variable's properties and methods. For example, variables of the System.String type have the ToUpper() method, which converts the content of the variable to uppercase. $server . ToUpper () LOCALHOST Variables can be used to replace any parameter in a cmdlet call. You can store all types of values in PowerShell variables. For example, store the results of commands, and store elements that are used in commands and expressions, such as names, paths, settings, and values. To get a list of all the variables in your PowerShell session, type Get-Variable. The variable names are displayed without the preceding dollar ($) sign that is used to reference variables. Variables in Powershell There are several different types of variables in PowerShell. User-created variables : User-created variables are created and maintained by the user. By default, the variables that you create at the PowerShell command line exist only while the PowerShell window is open. When the PowerShell windows is closed, the variables are deleted. To save a variable, add it to your PowerShell profile. You can also create variables in scripts with global, script, or local scope. Automatic variables : Automatic variables store the state of PowerShell. These variables are created by PowerShell, and PowerShell changes their values as required to maintain their accuracy. Users can't change the value of these variables. For example, the $PSHOME variable stores the path to the PowerShell installation directory.For more information, a list, and a description of the automatic variables, see about_Automatic_Variables . Preference variables : Preference variables store user preferences for PowerShell. These variables are created by PowerShell and are populated with default values. Users can change the values of these variables. For example, the $MaximumHistoryCount variable determines the maximum number of entries in the session history. For more information, a list, and a description of the preference variables, see about_Preference_Variables . Working With Variables To create a new variable, use an assignment statement to assign a value to the variable. You don't have to declare the variable before using it. The default value of all variables is $null $MyVariable = 1 , 2 , 3 $Path = \"C:\\Windows\\System32\" Variables are useful for storing the results of commands. For example: $Processes = Get-Process $Today = ( Get-Date ). DateTime To change the value of a variable, assign a new value to the variable. The Variable Cmdlets Cmdlet Name Description Clear-Variable Deletes the value of a variable. Get-Variable Gets the variables in the current console. New-Variable Creates a new variable. Remove-Variable Deletes a variable and its value. Set-Variable Changes the value of a variable. Variable Types You can store any type of object in a variable, including integers, strings, arrays, and hash tables. And, objects that represent processes, services, event logs, and computers. PowerShell variables are loosely typed, which means that they aren't limited to a particular type of object. A single variable can even contain a collection, or array, of different types of objects at the same time. The data type of a variable is determined by the .NET types of the values of the variable. To view a variable's object type, use Get-Member. $a = 12 # System.Int32 $a = \"Word\" # System.String $a = 12 , \"Word\" # array of System.Int32, System.String $a = Get-ChildItem C :\\ Windows # FileInfo and DirectoryInfo types Casting To use cast notation, enter a type name, enclosed in brackets, before the variable name (on the left side of the assignment statement). The following example creates a $number variable that can contain only integers, a $words variable that can contain only strings, and a $dates variable that can contain only DateTime objects. [int] $number = 8 $number = \"12345\" # The string is converted to an integer. $number = \"Hello\" #Casting Error Casting is useful when asking user input: # If no casting the number will be concatenated instead of multiplied PS > [int] $num = read-host \"Enter any number:\" Enter any number : 1024 PS > $num = $num * 10 PS > $num 10240 Using Variables in Commands and Expressions To use a variable in a command or expression, type the variable name, preceded by the dollar ($) sign. If the variable name and dollar sign aren't enclosed in quotation marks, or if they're enclosed in double quotation (\") marks, the value of the variable is used in the command or expression. If the variable name and dollar sign are enclosed in single quotation (') marks, the variable name is used in the expression. For more information about using quotation marks in PowerShell, see about_Quoting_Rules . Single quotes are used to assign to a variable the exact text that is placed between them, for example: PS > $var = 'Hello' PS > $var = 'The content of the variable is $var' PS > $var The content of the variable is $var The single quotes prevent the $ sign from being interpreted as the start of a variable name. To get Powershell to interpret the $ sign as the start of a variable name, the assignment is done with double quotes: PS > $var = 'Hello' PS > $var = \"Variable contains $var\" PS > $var Variable contains Hello The backtick ` causes Powershell to ignore the meaning of the following special character, for example: PS > $var = 'Hello' PS > $var = \"Variable `$ var contains $var\" PS > $var The variable $var contains Hello It can also be used to give special meaning to certain characters (equivalent to \\ in C and Java, for example \\n, \\t...). An example of use is the following: PS > $computername = 'localhost' PS > $phrase = \" `$ computername `n contains `n $computername\" PS > $phrase $computername contains localhost As you can see, `n stands for the carriage return character. To create or display a variable name that includes spaces or special characters, enclose the variable name with the curly braces ({}) characters. The curly braces direct PowerShell to interpret the variable name's characters as literals. ${ save-items } = \"a\" , \"b\" , \"c\" ${ save-items } To reference a variable name that includes braces, enclose the variable name in braces, and use the backtick character to escape the braces. For example, to create a variable named this{value}is type: ${ this `{ value `} is } = \"This variable name uses braces and backticks.\" ${ this `{ value `} is } List Variables It is possible to create a list type variable, separating the values \u200b\u200bof the list with commas: PS > $computers = 'server' , 'localhost' , 'server_2' PS > $computers server localhost server_2 List elements can be accessed by index number. Lists are numbered from zero: PS > $computers [ 0 ] server PS > $computers . count 3 Starting with Powershell version 3, if you pass a list as a parameter to a cmdlet, Powershell iterates over the items in the list. It is also possible to iterate over a list using the Foreach-Object cmdlet. These two commands do the same thing: $computers = $computers . tolower () $computers = $computers | ForEach -Object { $_ . tolower ()}","title":"Variables"},{"location":"Scripting/variables/#variables-in-powershell","text":"There are several different types of variables in PowerShell. User-created variables : User-created variables are created and maintained by the user. By default, the variables that you create at the PowerShell command line exist only while the PowerShell window is open. When the PowerShell windows is closed, the variables are deleted. To save a variable, add it to your PowerShell profile. You can also create variables in scripts with global, script, or local scope. Automatic variables : Automatic variables store the state of PowerShell. These variables are created by PowerShell, and PowerShell changes their values as required to maintain their accuracy. Users can't change the value of these variables. For example, the $PSHOME variable stores the path to the PowerShell installation directory.For more information, a list, and a description of the automatic variables, see about_Automatic_Variables . Preference variables : Preference variables store user preferences for PowerShell. These variables are created by PowerShell and are populated with default values. Users can change the values of these variables. For example, the $MaximumHistoryCount variable determines the maximum number of entries in the session history. For more information, a list, and a description of the preference variables, see about_Preference_Variables .","title":"Variables in Powershell"},{"location":"Scripting/variables/#working-with-variables","text":"To create a new variable, use an assignment statement to assign a value to the variable. You don't have to declare the variable before using it. The default value of all variables is $null $MyVariable = 1 , 2 , 3 $Path = \"C:\\Windows\\System32\" Variables are useful for storing the results of commands. For example: $Processes = Get-Process $Today = ( Get-Date ). DateTime To change the value of a variable, assign a new value to the variable.","title":"Working With Variables"},{"location":"Scripting/variables/#the-variable-cmdlets","text":"Cmdlet Name Description Clear-Variable Deletes the value of a variable. Get-Variable Gets the variables in the current console. New-Variable Creates a new variable. Remove-Variable Deletes a variable and its value. Set-Variable Changes the value of a variable.","title":"The Variable Cmdlets"},{"location":"Scripting/variables/#variable-types","text":"You can store any type of object in a variable, including integers, strings, arrays, and hash tables. And, objects that represent processes, services, event logs, and computers. PowerShell variables are loosely typed, which means that they aren't limited to a particular type of object. A single variable can even contain a collection, or array, of different types of objects at the same time. The data type of a variable is determined by the .NET types of the values of the variable. To view a variable's object type, use Get-Member. $a = 12 # System.Int32 $a = \"Word\" # System.String $a = 12 , \"Word\" # array of System.Int32, System.String $a = Get-ChildItem C :\\ Windows # FileInfo and DirectoryInfo types","title":"Variable Types"},{"location":"Scripting/variables/#casting","text":"To use cast notation, enter a type name, enclosed in brackets, before the variable name (on the left side of the assignment statement). The following example creates a $number variable that can contain only integers, a $words variable that can contain only strings, and a $dates variable that can contain only DateTime objects. [int] $number = 8 $number = \"12345\" # The string is converted to an integer. $number = \"Hello\" #Casting Error Casting is useful when asking user input: # If no casting the number will be concatenated instead of multiplied PS > [int] $num = read-host \"Enter any number:\" Enter any number : 1024 PS > $num = $num * 10 PS > $num 10240","title":"Casting"},{"location":"Scripting/variables/#using-variables-in-commands-and-expressions","text":"To use a variable in a command or expression, type the variable name, preceded by the dollar ($) sign. If the variable name and dollar sign aren't enclosed in quotation marks, or if they're enclosed in double quotation (\") marks, the value of the variable is used in the command or expression. If the variable name and dollar sign are enclosed in single quotation (') marks, the variable name is used in the expression. For more information about using quotation marks in PowerShell, see about_Quoting_Rules . Single quotes are used to assign to a variable the exact text that is placed between them, for example: PS > $var = 'Hello' PS > $var = 'The content of the variable is $var' PS > $var The content of the variable is $var The single quotes prevent the $ sign from being interpreted as the start of a variable name. To get Powershell to interpret the $ sign as the start of a variable name, the assignment is done with double quotes: PS > $var = 'Hello' PS > $var = \"Variable contains $var\" PS > $var Variable contains Hello The backtick ` causes Powershell to ignore the meaning of the following special character, for example: PS > $var = 'Hello' PS > $var = \"Variable `$ var contains $var\" PS > $var The variable $var contains Hello It can also be used to give special meaning to certain characters (equivalent to \\ in C and Java, for example \\n, \\t...). An example of use is the following: PS > $computername = 'localhost' PS > $phrase = \" `$ computername `n contains `n $computername\" PS > $phrase $computername contains localhost As you can see, `n stands for the carriage return character. To create or display a variable name that includes spaces or special characters, enclose the variable name with the curly braces ({}) characters. The curly braces direct PowerShell to interpret the variable name's characters as literals. ${ save-items } = \"a\" , \"b\" , \"c\" ${ save-items } To reference a variable name that includes braces, enclose the variable name in braces, and use the backtick character to escape the braces. For example, to create a variable named this{value}is type: ${ this `{ value `} is } = \"This variable name uses braces and backticks.\" ${ this `{ value `} is }","title":"Using Variables in Commands and Expressions"},{"location":"Scripting/variables/#list-variables","text":"It is possible to create a list type variable, separating the values \u200b\u200bof the list with commas: PS > $computers = 'server' , 'localhost' , 'server_2' PS > $computers server localhost server_2 List elements can be accessed by index number. Lists are numbered from zero: PS > $computers [ 0 ] server PS > $computers . count 3 Starting with Powershell version 3, if you pass a list as a parameter to a cmdlet, Powershell iterates over the items in the list. It is also possible to iterate over a list using the Foreach-Object cmdlet. These two commands do the same thing: $computers = $computers . tolower () $computers = $computers | ForEach -Object { $_ . tolower ()}","title":"List Variables"}]}